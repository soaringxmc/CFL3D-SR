<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html xml:lang="en" lang="en">
<head>
   <title>Updates/Corrections</title>
</head>
<! <body bgcolor="#FFFFFF">
<body background="Gifs/page.gif">

<p><a NAME="top"></a></p>

<hr>

<center>
<h2>Version 6.0 Updates and Corrections</h2>
<p><strong>Date of last Version 6.0 release: Oct  6, 1999</strong></p>
</center> 

<hr>

<p><strong><u>CONTENTS</u></strong></p>

<ul>
<li type=circle><a href="#corr1">Updates as of August 2, 2000.</a>
</ul>

<hr>
<hr>


<hr>

<p><a NAME="corr1"></a><strong><u>UPDATES AS OF AUGUST 2, 2000</u></strong>

<p>The changes described below affect the following routines, subsequent to the
version released on October 6, 1999:

<pre>

  cfl3dv6/source/cfl3d/dist/bc_blkint.F
  cfl3dv6/source/cfl3d/dist/cfl3d.F
  cfl3dv6/source/cfl3d/dist/main.F
  cfl3dv6/source/cfl3d/dist/mgbl.F
  cfl3dv6/source/cfl3d/dist/plot3c.F
  cfl3dv6/source/cfl3d/dist/plot3d.F
  cfl3dv6/source/cfl3d/dist/plot3t.F
  cfl3dv6/source/cfl3d/dist/pre_bc.F
  cfl3dv6/source/cfl3d/dist/qout.F
  cfl3dv6/source/cfl3d/dist/setslave.F      (NEW)
  cfl3dv6/source/cfl3d/dist/setup.F
  cfl3dv6/source/cfl3d/dist/setup_modgen.F (formally setup.F_modgen)
  cfl3dv6/source/cfl3d/dist/sizer.F
  cfl3dv6/source/cfl3d/dist/trnsfr_vals.F
  cfl3dv6/source/cfl3d/dist/updatedg.F
  cfl3dv6/source/cfl3d/libs/amafi.F
  cfl3dv6/source/cfl3d/libs/amafj.F
  cfl3dv6/source/cfl3d/libs/amafk.F
  cfl3dv6/source/cfl3d/libs/augmntq.F        (NEW)
  cfl3dv6/source/cfl3d/libs/avghole.F        (NEW)
  cfl3dv6/source/cfl3d/libs/bc_info.F
  cfl3dv6/source/cfl3d/libs/bc_xmera.F
  cfl3dv6/source/cfl3d/libs/blnkfr.F         (NEW)
  cfl3dv6/source/cfl3d/libs/ccomplex.F
  cfl3dv6/source/cfl3d/libs/ctime1.F
  cfl3dv6/source/cfl3d/libs/deform.F
  cfl3dv6/source/cfl3d/libs/diagi.F
  cfl3dv6/source/cfl3d/libs/diagj.F
  cfl3dv6/source/cfl3d/libs/diagk.F
  cfl3dv6/source/cfl3d/libs/fhat.F
  cfl3dv6/source/cfl3d/libs/getdelt.F        (NEW)
  cfl3dv6/source/cfl3d/libs/global.F
  cfl3dv6/source/cfl3d/libs/global0.F
  cfl3dv6/source/cfl3d/libs/gradinfo.F       (NEW)
  cfl3dv6/source/cfl3d/libs/histout_img.F
  cfl3dv6/source/cfl3d/libs/init_ae.F
  cfl3dv6/source/cfl3d/libs/init_rb.F        (NEW)
  cfl3dv6/source/cfl3d/libs/init_trim.F      (NEW)
  cfl3dv6/source/cfl3d/libs/initvist.F
  cfl3dv6/source/cfl3d/libs/metric.F
  cfl3dv6/source/cfl3d/libs/moddefl.F
  cfl3dv6/source/cfl3d/libs/rb_corr.F        (NEW)
  cfl3dv6/source/cfl3d/libs/rb_pred.F        (NEW)
  cfl3dv6/source/cfl3d/libs/readkey.F
  cfl3dv6/source/cfl3d/libs/rie1d.F
  cfl3dv6/source/cfl3d/libs/rsurf.F          (NEW)
  cfl3dv6/source/cfl3d/libs/setseg.F
  cfl3dv6/source/cfl3d/libs/swafi.F
  cfl3dv6/source/cfl3d/libs/swafk.F
  cfl3dv6/source/cfl3d/libs/tdq.F
  cfl3dv6/source/cfl3d/libs/tinvr.F
  cfl3dv6/source/cfl3d/libs/umalloc.F
  cfl3dv6/source/cfl3d/libs/umalloc_c.F
  cfl3dv6/source/cfl3d/libs/umalloc_r.F
  cfl3dv6/source/maggie/maggie.F        (also note change to .F)
  cfl3dv6/source/precfl3d/main.F
  cfl3dv6/source/ronnie/main.F
  cfl3dv6/source/ronnie/main_pre.F
  cfl3dv6/source/ronnie/ronnie.F
  cfl3dv6/source/ronnie/setup.F
  cfl3dv6/source/ronnie/sizer.F
  cfl3dv6/source/splitter/cfl3d_to_tlns3d.F
  cfl3dv6/source/splitter/getdhdr.F
  cfl3dv6/source/splitter/ingrd.F
  cfl3dv6/source/splitter/ingrd_cmplx.F
  cfl3dv6/source/splitter/ipadd.F
  cfl3dv6/source/splitter/ipfix.F
  cfl3dv6/source/splitter/iprvsg.F
  cfl3dv6/source/splitter/main.F
  cfl3dv6/source/splitter/main_cmplx.F
  cfl3dv6/source/splitter/mapblk.F
  cfl3dv6/source/splitter/mapin.F
  cfl3dv6/source/splitter/mapout.F
  cfl3dv6/source/splitter/mapsplt.F
  cfl3dv6/source/splitter/mkintr.F
  cfl3dv6/source/splitter/mkseg.F
  cfl3dv6/source/splitter/movseg.F
  cfl3dv6/source/splitter/outgrd.F
  cfl3dv6/source/splitter/outgrd_cmplx.F
  cfl3dv6/source/splitter/renmbr.F
  cfl3dv6/source/splitter/shortinp.F
  cfl3dv6/source/splitter/sizer.F
  cfl3dv6/source/splitter/splitter.F
  cfl3dv6/source/splitter/splitter_cmplx.F
  cfl3dv6/source/splitter/splt2.F
  cfl3dv6/source/splitter/spltsg.F
  cfl3dv6/source/splitter/termn8.F
  cfl3dv6/source/splitter/tlns3d_to_cfl3d.F
  cfl3dv6/source/tools/Get_FD.F
  cfl3dv6/source/tools/grid_perturb.F
  cfl3dv6/source/tools/grid_perturb_cmplx.F
  cfl3dv6/source/tools/moovmaker.F
  cfl3dv6/source/tools/XINTOUT_to_ovrlp.F    (NEW)
  cfl3dv6/source/tools/p3d_to_INGRID.F       (NEW)
  cfl3dv6/source/tools/INGRID_to_p3d.F       (NEW)
</pre>

<p>NOTE: Any .f files in the source code directories have been renamed as .F.
This makes an explicit call to the c-preprocessor (cpp) (which caused
some portability issues) unnecessary. 

<p>Finally, the following scripts/makefiles are also affected:

<pre>
  cfl3dv6/build/cfl/libs/makefile
  cfl3dv6/build/cfl/seq/makefile
  cfl3dv6/build/cfl/mpi/makefile
  cfl3dv6/build/cflcmplx/libs/makefile
  cfl3dv6/build/cflcmplx/seq/makefile
  cfl3dv6/build/cflcmplx/mpi/makefile
  cfl3dv6/build/precfl/seq/makefile
  cfl3dv6/build/preron/seq/makefile
  cfl3dv6/build/split/seq/makefile
  cfl3dv6/build/splitcmplx/seq/makefile
  cfl3dv6/build/tools/seq/makefile
  cfl3dv6/build/ron/seq/makefile
  cfl3dv6/build/mag/seq/makefile
  cfl3dv6/build/Install
</pre>

<p>Version 6 users can get the corrected routines on tabdemo.larc.nasa.gov,
using the user name and password they were provided. If you find the
password is no longer valid (it WILL change with time), call Bob Biedron at 
(757) 864-2156 for the current one. The routines are in
the directory ftp/incoming/biedron/Cfl3dv6/Corrections. 

<p>A compressed tar file, 
corrections.tar.Z.<strong><em>date</em></strong>, contains all the changes in a 
directory structure that parallels the
standard Version 6 release directory with the top level 
directory as cfl3dv6_corrections, rather than cfl3dv6. For example, 
the updated main.F routine for cfl3d, which is normally found in
cfl3dv6/source/cfl3d/dist/main.F can be found in
cfl3dv6_corrections/source/cfl3d/dist/main.F.
Similarly, the updated makefile for the mpi version of cfl3d, which is 
normally found in cfl3dv6/build/cfl/mpi/makefile can be found in
cfl3dv6_corrections/build/cfl/mpi/makefile.

<p>A machine-generated list_of_diffs.<strong><em>date</em></strong> is also available in the
Corrections directory. The description of the differences given below 
<em>should</em> be equivalent to the machine-generated list.
Although the "Why Changed" information is missing from the machine-generated
list (and it is less readable), the hand-generated list below may be
subject to typographical errors and errors of oversight.

<pre>
--------------------
--------------------
SUMMARY OF CHANGES :
--------------------
--------------------

Number:           1

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/ronnie

Subroutine(s):    ronnie.F

Change:

  c     implementation, contact Bob Biedron, 804-864-2156

To:

  c     implementation, contact Bob Biedron, 757-864-2156

After:

      string = '    timing for complete run - time in seconds     '
      call cputim(-1,nnodes,string,myhost,myid,mycomm,25)

Add:    

c
c     free memory
c
      ifree = 1
      if (ifree.gt.0) then
         call ufree(ip_work)
         call ufree(ip_lw)
         call ufree(ip_lw2)
         call ufree(ip_mglevg)
         call ufree(ip_nemgl)
         call ufree(ip_levelg)
         call ufree(ip_jtest)
         call ufree(ip_ktest)
         call ufree(ip_itest)
         call ufree(ip_nblg)
         call ufree(ip_iemg)
         call ufree(ip_igridg)
         call ufree(ip_jdimg)
         call ufree(ip_kdimg)
         call ufree(ip_idimg)
         call ufree(ip_nblcg)
         call ufree(ip_ncgg)
         call ufree(ip_xorig)
         call ufree(ip_yorig)
         call ufree(ip_zorig)
         call ufree(ip_windex)
         call ufree(ip_iindex)
         call ufree(ip_llimit)
         call ufree(ip_iitmax)
         call ufree(ip_mmcxie)
         call ufree(ip_mmceta)
         call ufree(ip_ncheck)
         call ufree(ip_iifit)
         call ufree(ip_nblkpt)
         call ufree(ip_iic0)
         call ufree(ip_iiorph)
         call ufree(ip_iitoss)
         call ufree(ip_ifiner)
         call ufree(ip_dx)
         call ufree(ip_dy)
         call ufree(ip_dz)
         call ufree(ip_dthetx)
         call ufree(ip_dthety)
         call ufree(ip_dthetz)
         call ufree(ip_lout)
         call ufree(ip_xif1)
         call ufree(ip_xif2)
         call ufree(ip_etf1)
         call ufree(ip_etf2)
         call ufree(ip_jjmax1)
         call ufree(ip_kkmax1)
         call ufree(ip_iiint1)
         call ufree(ip_iiint2)
         call ufree(ip_jimage)
         call ufree(ip_kimage)
         call ufree(ip_jte)
         call ufree(ip_kte)
         call ufree(ip_jmm)
         call ufree(ip_kmm)
         call ufree(ip_nblk1)
         call ufree(ip_nblk2)
         call ufree(ip_xte)
         call ufree(ip_yte)
         call ufree(ip_zte)
         call ufree(ip_xmi)
         call ufree(ip_ymi)
         call ufree(ip_zmi)
         call ufree(ip_xmie)
         call ufree(ip_ymie)
         call ufree(ip_zmie)
         call ufree(ip_sxie)
         call ufree(ip_seta)
         call ufree(ip_sxie2)
         call ufree(ip_seta2)
         call ufree(ip_xie2s)
         call ufree(ip_eta2s)
         call ufree(ip_temp)
         call ufree(ip_x2)
         call ufree(ip_y2)
         call ufree(ip_z2)
         call ufree(ip_x1)
         call ufree(ip_y1)
         call ufree(ip_z1)
         call ufree(ip_factjlo)
         call ufree(ip_factjhi)
         call ufree(ip_factklo)
         call ufree(ip_factkhi)
         call ufree(ip_ifrom)
         call ufree(ip_isav_pat)
         call ufree(ip_isav_pat_b)
         call ufree(ip_mblk2nd)
         call ufree(ip_ireq_ar)
      end if


Why corrected: Free up memory after use...just good coding practice. Also
               corrected phone number area code.

--------------------
--------------------

Number:           2

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F

Change:
          do 132 j = 2+jdmi1,jdmi2  
To:
          do 132 j = 2+jdmi1,jdmi2-1  

Change:
          do 133 j = 2+jdmi1,jdmi2  
To:
          do 133 j = 2+jdmi1,jdmi2-1  

Change:
          do 134 j = 2+jdmi1,jdmi2  
To:
          do 134 j = 2+jdmi1,jdmi2-1  

Change:
          do 135 j = 2+jdmi1,jdmi2  
To:
          do 135 j = 2+jdmi1,jdmi2-1  

Change:
         do 136 j = 1+jdmi1,jdmi2
To:
         do 136 j = 2+jdmi1,jdmi2-1 

Change:
         do 138 j = 1+jdmi1,jdmi2
To:
         do 138 j = 2+jdmi1,jdmi2-1 

Change:
          do 252 j = 2+jdmi1,jdmi2  
To:
          do 252 j = 2+jdmi1,jdmi2-1  

Change:
          do 253 j = 2+jdmi1,jdmi2  
To:
          do 253 j = 2+jdmi1,jdmi2-1  

Change:
          do 254 j = 2+jdmi1,jdmi2  
To:
          do 254 j = 2+jdmi1,jdmi2-1  

Change:
          do 255 j = 2+jdmi1,jdmi2  
To:
          do 255 j = 2+jdmi1,jdmi2-1  


Why corrected: Incorrect bounds on do loops, accessing array elements beyond
               the declared array dimensions when using the spring analogy
               deforming mesh option (ismooth > 0); seems to have no impact
               on the results.

--------------------
--------------------

Number:           3

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    setseg.F

Change (6 places):

                nsegdfrm(nbl)      = nsegdfrm(nbl) + 1
                iseg               = nsegdfrm(nbl)

To (6 places):

                iseg               = nsegdfrm(nbl) + 1
                nsegdfrm(nbl)      = iseg

Why corrected: F90 compiler on Cray C90 mangled the loop in which the
               original statements appeared if the optimization level
               was greater than -O0. The new statements are syntactically
               the same and don't seem to cause the Cray F90 compiler any
               problems.

--------------------
--------------------

Number:           4

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    gdsa (contained within deform.F)

After:
         common /sklton/ isklton

Add:
         common /zero/ iexp

After:
          jdi5 = 5*jdim*idim

Add: 
          eps = 10.**(-iexp+1)
          eps1= 10.*eps

Change:
          xjd(j,1)= (dxi*(dyjp*dzjm-dyjm*dzjp)
     .              +dyi*(dzjp*dxjm-dzjm*dxjp)
     .              +dzi*(dxjp*dyjm-dxjm*dyjp))/
     .  (ripm*(rjp*rjm-(dxjp*dxjm+dyjp*dyjm+dzjp*dzjm)))
          xid(j,1)=-(dxj1*(dyip*dzim-dyim*dzip)
     .              +dyj1*(dzip*dxim-dzim*dxip)
     .              +dzj1*(dxip*dyim-dxim*dyip))/
     .  (rjpm*(rip*rim-(dxip*dxim+dyip*dyim+dzip*dzim)))

To:
          term1   = (dxi*(dyjp*dzjm-dyjm*dzjp)
     .              +dyi*(dzjp*dxjm-dzjm*dxjp)
     .              +dzi*(dxjp*dyjm-dxjm*dyjp))-eps1
          term2   = (ripm*(rjp*rjm-
     .            (dxjp*dxjm+dyjp*dyjm+dzjp*dzjm)+eps))
          xjd(j,1)= term1/term2
          term3   =-(dxj1*(dyip*dzim-dyim*dzip)
     .             +dyj1*(dzip*dxim-dzim*dxip)
     .             +dzj1*(dxip*dyim-dxim*dyip))-eps1
          term4    = (rjpm*(rip*rim-
     .            (dxip*dxim+dyip*dyim+dzip*dzim)+eps))
          xid(j,1)= term3/term4

Change:
          xjd(j,2)=-(dxi*(dyjp*dzjm-dyjm*dzjp)
     .              +dyi*(dzjp*dxjm-dzjm*dxjp)
     .              +dzi*(dxjp*dyjm-dxjm*dyjp))/
     .  (ripm*(rjp*rjm-(dxjp*dxjm+dyjp*dyjm+dzjp*dzjm)))
          xid(j,2)= (dxj1*(dyip*dzim-dyim*dzip)
     .              +dyj1*(dzip*dxim-dzim*dxip)
     .              +dzj1*(dxip*dyim-dxim*dyip))/
     .  (rjpm*(rip*rim-(dxip*dxim+dyip*dyim+dzip*dzim)))

To:
          term1   =-(dxi*(dyjp*dzjm-dyjm*dzjp)
     .              +dyi*(dzjp*dxjm-dzjm*dxjp)
     .              +dzi*(dxjp*dyjm-dxjm*dyjp))-eps1
          term2   = (ripm*(rjp*rjm-
     .            (dxjp*dxjm+dyjp*dyjm+dzjp*dzjm)+eps))
          xjd(j,2)= term1/term2
          term3   = (dxj1*(dyip*dzim-dyim*dzip)
     .             +dyj1*(dzip*dxim-dzim*dxip)
     .             +dzj1*(dxip*dyim-dxim*dyip))-eps1
          term4    = (rjpm*(rip*rim-
     .            (dxip*dxim+dyip*dyim+dzip*dzim)+eps))
          xid(j,2)= term3/term4

Change:
          xjd(j,1)= (dxi*(dyjp*dzjm-dyjm*dzjp)
     .              +dyi*(dzjp*dxjm-dzjm*dxjp)
     .              +dzi*(dxjp*dyjm-dxjm*dyjp))/
     .  (ripm*(rjp*rjm-(dxjp*dxjm+dyjp*dyjm+dzjp*dzjm)))
          xid(j,1)=-(dxj1*(dyip*dzim-dyim*dzip)
     .              +dyj1*(dzip*dxim-dzim*dxip)
     .              +dzj1*(dxip*dyim-dxim*dyip))/
     .  (rjpm*(rip*rim-(dxip*dxim+dyip*dyim+dzip*dzim)))

To:
          term1   = (dxi*(dyjp*dzjm-dyjm*dzjp)
     .              +dyi*(dzjp*dxjm-dzjm*dxjp)
     .              +dzi*(dxjp*dyjm-dxjm*dyjp))-eps1
          term2   = (ripm*(rjp*rjm-
     .            (dxjp*dxjm+dyjp*dyjm+dzjp*dzjm)+eps))
          xjd(j,1)= term1/term2
          term3   =-(dxj1*(dyip*dzim-dyim*dzip)
     .              +dyj1*(dzip*dxim-dzim*dxip)
     .             +dzj1*(dxip*dyim-dxim*dyip))-eps1
          term4    = (rjpm*(rip*rim-
     .            (dxip*dxim+dyip*dyim+dzip*dzim)+eps))
          xid(j,1)= term3/term4

Change:
          xjd(j,2)=-(dxi*(dyjp*dzjm-dyjm*dzjp)
     .              +dyi*(dzjp*dxjm-dzjm*dxjp)
     .              +dzi*(dxjp*dyjm-dxjm*dyjp))/
     .  (ripm*(rjp*rjm-(dxjp*dxjm+dyjp*dyjm+dzjp*dzjm)))
          xid(j,2)= (dxj1*(dyip*dzim-dyim*dzip)
     .              +dyj1*(dzip*dxim-dzim*dxip)
     .              +dzj1*(dxip*dyim-dxim*dyip))/
     .  (rjpm*(rip*rim-(dxip*dxim+dyip*dyim+dzip*dzim)))

To:
          term1   =-(dxi*(dyjp*dzjm-dyjm*dzjp)
     .              +dyi*(dzjp*dxjm-dzjm*dxjp)
     .              +dzi*(dxjp*dyjm-dxjm*dyjp))-eps1
          term2   = (ripm*(rjp*rjm-
     .            (dxjp*dxjm+dyjp*dyjm+dzjp*dzjm)+eps))
          xjd(j,2)= term1/term2
          term3   = (dxj1*(dyip*dzim-dyim*dzip)
     .             +dyj1*(dzip*dxim-dzim*dxip)
     .             +dzj1*(dxip*dyim-dxim*dyip))-eps1
          term4    = (rjpm*(rip*rim-
     .            (dxip*dxim+dyip*dyim+dzip*dzim)+eps))
          xid(j,2)= term3/term4

Change:
        do 156 j = 1+jdmi1,jdmi2
          dyj(j,1)=1./sqrt((xkm(j,1)*xkp(j,1)-xjp(j,1)*xip(j,1))
     .              *(xkm(j,1)*xkp(j,1)-xjp(j,1)*xip(j,1))
     .                    +dxj(j,1)*dxj(j,1)+dzj(j,1)*dzj(j,1))
          dyj(j,2)=1./sqrt((xkm(j,2)*xkp(j,2)-xjp(j,2)*xip(j,2))
     .              *(xkm(j,2)*xkp(j,2)-xjp(j,2)*xip(j,2))
     .                    +dxj(j,2)*dxj(j,2)+dzj(j,2)*dzj(j,2))
156       continue
        do 164 j = 1,jdm*idm
          dxj(j,1) = dxj(j,1)*dyj(j,1)
          dzj(j,1) = dzj(j,1)*dyj(j,1)
          dxj(j,2) = dxj(j,2)*dyj(j,2)
          dzj(j,2) = dzj(j,2)*dyj(j,2)
164     continue

To:
        do 156 j = 1+jdmi1,jdmi2
          term1 =  sqrt((xkm(j,1)*xkp(j,1)-xjp(j,1)*xip(j,1))
     .              *(xkm(j,1)*xkp(j,1)-xjp(j,1)*xip(j,1))
     .                    +dxj(j,1)*dxj(j,1)+dzj(j,1)*dzj(j,1))
          term2 =  sqrt((xkm(j,2)*xkp(j,2)-xjp(j,2)*xip(j,2))
     .              *(xkm(j,2)*xkp(j,2)-xjp(j,2)*xip(j,2))
     .                    +dxj(j,2)*dxj(j,2)+dzj(j,2)*dzj(j,2))
          dyj(j,1) = 1./(term1+eps)
          dxj(j,1) = dxj(j,1)*dyj(j,1)
          dzj(j,1) = dzj(j,1)*dyj(j,1)
          dyj(j,2) = 1./(term2+eps)
          dxj(j,2) = dxj(j,2)*dyj(j,2)
          dzj(j,2) = dzj(j,2)*dyj(j,2)
156     continue

Change:
        do 276 j = 1+jdmi1,jdmi2
          dvol(j+jdi1) =1./sqrt((xkm(j,1)*xkp(j,1)-xjp(j,1)*xip(j,1))
     .              *(xkm(j,1)*xkp(j,1)-xjp(j,1)*xip(j,1))
     .            +dvol(j)*dvol(j)+dvol(j+jdi2)*dvol(j+jdi2))
          dvol(j+jdi4) =1./sqrt((xkm(j,2)*xkp(j,2)-xjp(j,2)*xip(j,2))
     .              *(xkm(j,2)*xkp(j,2)-xjp(j,2)*xip(j,2))
     .         +dvol(j+jdi3)*dvol(j+jdi3)+dvol(j+jdi5)*dvol(j+jdi5))
276       continue
        do 284 j = 1+jdmi1,jdmi2
          dvol(j)      = dvol(j     )*dvol(j+jdi1)
          dvol(j+jdi2) = dvol(j+jdi2)*dvol(j+jdi1)
          dvol(j+jdi3) = dvol(j+jdi3)*dvol(j+jdi4)
          dvol(j+jdi5) = dvol(j+jdi5)*dvol(j+jdi4)
284     continue

       if(idm.gt.2) then

To:
        do 276 j = 1+jdmi1,jdmi2
          term1 =  sqrt((xkm(j,1)*xkp(j,1)-xjp(j,1)*xip(j,1))
     .              *(xkm(j,1)*xkp(j,1)-xjp(j,1)*xip(j,1))
     .            +dvol(j)*dvol(j)+dvol(j+jdi2)*dvol(j+jdi2))
          term2 =  sqrt((xkm(j,2)*xkp(j,2)-xjp(j,2)*xip(j,2))
     .              *(xkm(j,2)*xkp(j,2)-xjp(j,2)*xip(j,2))
     .         +dvol(j+jdi3)*dvol(j+jdi3)+dvol(j+jdi5)*dvol(j+jdi5))
          dvol(j+jdi1) = 1./(term1+eps)
          dvol(j)      = dvol(j     )*dvol(j+jdi1)
          dvol(j+jdi2) = dvol(j+jdi2)*dvol(j+jdi1)
          dvol(j+jdi4) = 1./(term2+eps)
          dvol(j+jdi3) = dvol(j+jdi3)*dvol(j+jdi4)
          dvol(j+jdi5) = dvol(j+jdi5)*dvol(j+jdi4)
276     continue

       if(i2d.eq.0) then

Why corrected: Correct errors in surface normal/curvature evaluation for cases
               where the angle between adjacent elements is 0 or 2pi.  The
               change impacts only certain deforming mesh solutions, and only
               and only when the spring analogy is used (ismooth>0).

--------------------
--------------------

Number:           5

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    initvist.F

Change:

                zk2=-const1*(smin(j,k,i)*refac)**2 + const2*smin(j,k,i)

To:
                zk2=-const1*(smin(j,k,i)*refac)**2 +
     +               const2*smin(j,k,i)*refac

Why corrected: This Version 5 change issued April 23, 1999 was missed in
               Version 6...the first smin got multiplied by refac as required,
               but not the second.

--------------------
--------------------

Number:           6

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/build

Subroutine(s):    Install (a script, not a subroutine)

Change:

     Just get the new script

Why corrected: Minor modifications to remove outdated compiler options on HP 
               workstation; also removed the -v5 option for installing the code
               to emulate version 5 as closely as possible. Version 5 emulation
               is now handled via input options - will have no impact on users

--------------------
--------------------

Number:           7

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    dmsetup0,dmsetup1,dmsetup,bdata,permut_ijkxyz,unperm_ijkxyz,
                  gdsa (all contained within deform.F)

After:

    each subroutine statement 

Add:

#   ifdef CMPLX
      implicit complex(a-h,o-z)
#   endif
 

Why corrected:  All subroutines in Version 6 need to have the complex
                option; these did not.

--------------------
--------------------

Number:           8

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Change:

        xmach = ccabs(realval(1))

To:

        xmach = realval(1)

Change:

        sref = ccabs(realval(1))

To:

        sref = realval(1)

Why corrected: Wrong argument type for the complex function ccabs; could
               lead to wrong solution in the complex version.

--------------------
--------------------

Number:           9

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    readkey.F

Change:

           resupdt = -ccabs(realval(1))
To:

           resupdt = -abs(realval(1))
Change:

           cflturb = ccabs(realval(1))
To:

           cflturb = abs(realval(1))

Why corrected: Wrong argument type for the complex function ccabs; could
               lead to wrong solution in the complex version.

--------------------
--------------------

Number:           10

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    readkey.F

After:

      common /key/ nkey
 
Add:

      common /is_blockbc/ is_blk(5),ie_blk(5),ivolint
      common /elastic_ss/ idef_ss
      common /bin/ ibin,iblnk,iblnkfr,ip3dgrad
      common /memory/ memadd,memaddi
      common /deformz/ beta1,ismooth,negvol

After:

      nfreeze  = 0
      nkey     = nkey + 1
c

Add:

c     flag for using/not using the exact volume terms on 1-1 block
c     boundaries (1...use the exact volumes)
c
      ivolint  = 1
      nkey     = nkey + 1
c
c
c     flag for mesh deformation in steady-state mode
c     default of zero does not deform mesh to fit a new
c     surface shape
c
      idef_ss  = 0
      nkey     = nkey + 1
c
c     flag for writing unformated/formatted plot3d files
c     default is unformatted (except on T3E)
c
      ibin     = 1
#   ifdef T3E
      ibin     = 0
#   endif
     nkey     = nkey + 1
c
c     flag for enabling/disabling the writing of the iblank
c     array in the plot3d grid file. default is enabled
c
      iblnk    = 1
      nkey     = nkey + 1
c
c     flag for enabling/disabling the blanking of fringe points
c     in the plot3d grid file for overset grids. default is
c     endabled
c
      iblnkfr  = 1
      nkey     = nkey + 1
c
c     flag to switch from solution output to derivative output
c     in the plot3d "q" file. default is solution output
c
      ip3dgrad = 0
      nkey     = nkey + 1
c
c     size of complex perturbation to surface grid onto which
c     the volume grid is to be deformed
c     (this should be consitant with the input complex grid)
c
        surf_img  = 0.
        nkey      = nkey + 1
c
c     additional user-specified memory to allocate to the
c     work array sizes (memadd to mwork, memeaddi to mworki)
c     used to offset any underestimation by the sizer routine
c
      memadd    = 0
      nkey      = nkey + 1
      memaddi   = 0
      nkey      = nkey + 1
c
c     flag to turn off stops when negative volumes/bad metrics
c     are encountered - use only to debug mesh deformation!
c     default is to stop when negative volumes/bad metrics are
c     found
c
      negvol    = 0
      nkey      = nkey + 1

After:

           read(inpstr(lc2:lcl),*) nfreeze
  c

Add:

        else if (inpstr(lc1:lc2).eq.'ivolint') then
           lc2 = lc2 +1
           read(inpstr(lc2:lcl),*) ivolint
        else if (inpstr(lc1:lc2).eq.'idef_ss') then
           lc2 = lc2 +1
           read(inpstr(lc2:lcl),*) idef_ss
  c
        else if (inpstr(lc1:lc2).eq.'ibin') then
           lc2 = lc2 +1
           read(inpstr(lc2:lcl),*) ibin
  c
        else if (inpstr(lc1:lc2).eq.'iblnk') then
           lc2 = lc2 +1
           read(inpstr(lc2:lcl),*) iblnk
  c
        else if (inpstr(lc1:lc2).eq.'iblnkfr') then
           lc2 = lc2 +1
           read(inpstr(lc2:lcl),*) iblnkfr
c
      else if (inpstr(lc1:lc2).eq.'ip3dgrad') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) ip3dgrad
  c
        else if (inpstr(lc1:lc2).eq.'surf_img') then
           lc2 = lc2 +1
           read(inpstr(lc2:lcl),*) realval(1)
           surf_img = realval(1)
  c
  c        must also have idef_ss option enabled as well
  c
           if (idef_ss.eq.0) then
              nou(1) = min(nou(1)+1,ibufdim)
              write(bou(nou(1),1),'(''stopping...must have idef_ss = 1 '',
       .           ''if surf_img .ne. 0.'')')
              call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)
           end if
c
      else if (inpstr(lc1:lc2).eq.'memadd') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) memadd
c
      else if (inpstr(lc1:lc2).eq.'memaddi') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) memaddi
c
      else if (inpstr(lc1:lc2).eq.'negvol') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) negvol


Why corrected: 1) Add keyword for ivolint, so that exact 1-1 boundary volumes
               can be turned on and off (previously done with installation
               option -v5); 2) Add keyword for new capability to read in an
               updated surface grid and deform the current volume grid to
               that new surface; 3) Add keywords for unformatted/formated
               plot3d files with and without iblanking; 4) Add keyword for 
               derivative evaluation with surface deformation 5) Add 
               keyword for adding to real and integer work arrays in the 
               event of a sizer error 6) Add keyword to turn off the
               built-in stops that are triggered by negative volumes or
               extremely poor mesh quality; 7) Add keyword to toggle between
               solution output to plot3d files and derivative output to plot3d
               files (active in complex version only)

--------------------
--------------------

Number:           11

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist  cfl3dv6/source/cfl3d/libs

Subroutine(s):    bc_blkint.F,pre_bc.F,sizer.F,bc_info.F

Change:

        common /is_blockbc/ is_blk(5),ie_blk(5)

To:

        common /is_blockbc/ is_blk(5),ie_blk(5),ivolint

Why corrected: store keyword ivolint, so that exact 1-1 boundary volumes
               can be turned on and off (previously done with installation
               option -v5)

--------------------
--------------------

Number:           12

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    bc_blkint.F

Delete:

  c
  #if defined V5
        ivolint = 0
  #else
        ivolint = 1
  #endif

Why corrected: Remove dependence on install option -v5 (no longer used).
               ivolint is now defaulted to 1 (exact 1-1 boundary volumes),
               and may be altered via a keyword.

--------------------
--------------------

Number:           13

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    amafi.F,amafj.F,amafk.F,ctime1.F,diagi.F,diagj.F,diagk.F,
                  fhat.F,rie1d.F,swafi.F,swafk.F,tdq.F,tinvr.F 

Change:

        Considerable re-arrangement of code; just get the new routines

Why corrected: More efficient execution when preconditioning is not used.
               The changes basically constitue a replacement of the 
               "#if def V5" segments with standard "if..,then" statements
               that check for the use of preconditioning. 


--------------------
--------------------

Number:           14

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/maggie

Subroutine(s):    maggie.f

Change:

  c     implementation, contact Bob Biedron, 804-864-2156

To:

  c     implementation, contact Bob Biedron, 757-864-2156

Why corrected: Updated area code on phone number.

--------------------
--------------------

Number:           15

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgbl.F

Delete:

  #ifdef V5
  c
           write(11,'(/,'' version 5 emulation enabled'')')
  #endif

Why corrected: Remove reference to install option -v5 (no longer used).
               Version 5 emulation is now obtained using the keyword 
               ivolint 0

--------------------
--------------------

Number:           16

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    plot3c.F

Change:

  #if defined V5
        ip3dsurf = 0
  #endif

To:

  c     ip3dsurf = 0

Why corrected: Remove reference to install option -v5 (no longer used).
               The comment could be removed to force cell center data
               (rather than cell face center data) when nplot3d < 0.

--------------------
--------------------

Number:           17

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    plot3d.F

Change: 

  #if defined V5

        (retain code in between # signs)

  #endif

To:

  c
        iold = 0
        if (iold .gt. 0) then

        (retain code in between # signs)

        end if

Why corrected: Remove reference to install option -v5 (no longer used).
               The hardwired flag could be set to 1 in order to force
               the old (Version 5) evaluation method of eddy viscosity
               on the surface.

--------------------
--------------------

Number:           18

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    trnsfr_vals.F

Change:

        common /is_blockbc/ is_blk(5),ie_blk(5)

To:

        common /is_blockbc/ is_blk(5),ie_blk(5),ivolint

Change:

        common /deformz/ beta1,ismooth

To:

        common /deformz/ beta1,ismooth,negvol

After:

        common /entfix/ epsa_l,epsa_r

Add:

        common /elastic_ss/ idef_ss
        common /bin/ ibin,iblnk,iblnkfr,ip3dgrad
        common /memory/ memadd,memaddi

After:

           work(nlast+20) = epsa_r
           work(nlast+21) = nfreeze


Add:

           work(nlast+22) = ivolint
           work(nlast+23) = idef_ss
           work(nlast+24) = ibin
           work(nlast+25) = iblnk
           work(nlast+26) = surf_img
           work(nlast+27) = memadd
           work(nlast+28) = memaddi
           work(nlast+29) = negvol
           work(nlast+30) = iblnkfr

After:

           epsa_r    = work(nlast+20)
           nfreeze   = int(work(nlast+21))

Add:

           ivolint   = int(work(nlast+22))
           idef_ss   = int(work(nlast+23))
           ibin      = int(work(nlast+24))
           iblnk     = int(work(nlast+25))
           surf_img  = work(nlast+26)
           memadd    = int(work(nlast+27))
           memaddi   = int(work(nlast+28))
           negvol    = int(work(nlast+29))
           iblnkfr   = int(work(nlast+30))

Why corrected: Pass the new keywords ivolint,idef_ss,ibin,iblnk,surf_img,
               and iblnkfr to all the processors for parallel execution.

--------------------
--------------------

Number:           19

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    qout.F, plot3d.F, plot3c.F, plot3t.F

Change:

       common /bin/ ibin

To:

       common /bin/ ibin,iblnk,iblnkfr,ip3dgrad

Why corrected: Introduce new parameter to allow blank array in the plot3d
               output file to be turned on or off.

--------------------
--------------------

Number:           20

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgbl.F

After:

      common /motionmc/ xmc0,ymc0,zmc0,utransmc,vtransmc,wtransmc,
     .                  omegaxmc,omegaymc,omegazmc,xorigmc,yorigmc,
     .                  zorigmc,xorig0mc,yorig0mc,zorig0mc,thetaxmc,
     .                  thetaymc,thetazmc,dxmxmc,dymxmc,dzmxmc,
     .                  dthxmxmc,dthymxmc,dthzmxmc,rfreqtmc,
     .                  rfreqrmc,itransmc,irotatmc,time2mc

Add:

      common /bin/ ibin,iblnk,iblnkfr,ip3dgrad

After:

c
c     write header to cfl3d.alpha file if specified Cl option is used
c
      if (ialphit.ne.0 .and. myid.eq.myhost) then
            write(27,'(''       it    log(res)           cl'',
     .      ''            alpha'')')
      end if

Add:

c
c     open plot3d/printout files
c
      if (myid.eq.myhost) then
c
      if (ibin.eq.1) then
      open(unit=3,file=plt3dg,form='unformatted',status='unknown')
      open(unit=4,file=plt3dq,form='unformatted',status='unknown')
      else
         open(unit=3,file=plt3dg,form='formatted',status='unknown')
         open(unit=4,file=plt3dq,form='formatted',status='unknown')
      end if
      open(unit=17,file=printout,form='formatted',status='unknown')
c
      end if

Why corrected: Now open plot3d/print files in mgbl rather than main, in order 
               to allow ibin as an input keyword

--------------------
--------------------

Number:           21

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    plot3d.F

Change:

c     currently don't need blanking data for printout option (iflag=2),
c     so only compute blank2 array for plot3d output option
c
      if (iflag.eq.1) then

To:

c     currently don't need blanking data for printout option (iflag=2),
c     so only compute blank2 array for plot3d output option
c     also, don't compute blanking info if iblnk = 0
c
      if (iflag.eq.1 .or. iblnk.gt.0) then

Change:

         if (i2d .eq. 1) then
#ifdef T3E
 2041       format(3x,39hplot3d files to be read with /mgrid/for,
     .      14h/2d qualifiers)
#else
 2041       format(3x,41hplot3d files to be read with /mgrid/blank,
     .      14h/2d qualifiers)
#endif
         else
            write(11,2042)
#ifdef T3E
 2042       format(3x,39hplot3d files to be read with /mgrid/for,
     .      11h qualifiers)
#else
 2042       format(3x,41hplot3d files to be read with /mgrid/blank,
     .      11h qualifiers)
#endif
         end if

To:

         if (i2d .eq. 1) then
            if (iblnk .eq. 0) then
               write(11,2041)
 2041          format(3x,39hplot3d files to be read with /mgrid/for,
     .         14h/2d qualifiers)
            else
               write(11,2141)
 2141          format(3x,41hplot3d files to be read with /mgrid/blank,
     .         14h/2d qualifiers)
            end if
         else
            if (iblnk .eq. 0) then
               write(11,2042)
 2042          format(3x,39hplot3d files to be read with /mgrid/for,
     .         11h qualifiers)
            else
               write(11,2142)
 2142          format(3x,41hplot3d files to be read with /mgrid/blank,
     .         11h qualifiers)
            end if
         end if

Change:

      if (myid.eq.myhost) then
c
c     ialph > 0 for a grid that was read in plot3d format with alpha measured
c               in the xy plane (TLNS3D convention)
c
c     output grid
c
      if(ibin.eq.0) then
        if(i2d.eq.0) then
        if(ialph.eq.0) then
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        else
        do i=1,iw
           do j=1,jw
              do k=1,kw
                 xg(j,k,i,2) = -xg(j,k,i,2)
              end do
           end do
        end do
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
        else
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
      else
        if(i2d.eq.0) then
        if(ialph.eq.0) then
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .      (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        else
        do i=1,iw
           do j=1,jw
              do k=1,kw
                 xg(j,k,i,2) = -xg(j,k,i,2)
              end do
           end do
        end do
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .      (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
        else
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .      (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
      end if
c
      end if
c
#if defined DIST_MPI
      if (mblk2nd(nblk).eq.myid) then


To:

      if (myid.eq.myhost .and. icall1.eq.0) then
c
c     ialph > 0 for a grid that was read in plot3d format with alpha measured
c               in the xy plane (TLNS3D convention)
c
      if (ialph.ne.0 .and. i2d.ne.1) then
         do i=1,iw
            do j=1,jw
               do k=1,kw
                  temp        = xg(j,k,i,2)
                  xg(j,k,i,2) = xg(j,k,i,3)
                  xg(j,k,i,3) = -temp
               end do
            end do
         end do
      end if
c
c     output grid
c
      if (ibin.eq.0) then
         if (i2d.eq.0) then
            if (iblnk.eq.0) then
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
                 write(3,'(5e14.6)')
     .                     (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                     (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                     (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .                 (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         else
            if (iblnk.eq.0) then
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .               (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         end if
      else
         if (i2d.eq.0) then
            if (iblnk.eq.0) then
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .             (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         else
            if (iblnk.eq.0) then
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .             (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         end if
      end if
c
      end if
c
#if defined DIST_MPI
      if (mblk2nd(nblk).eq.myid) then

Change:  (all occurances)

      write(4,*)

To:

      write(4,'(5e14.6)')

Why corrected: Introduce new parameter to allow blank array in the plot3d
               output file to be turned on or off; some recoding to make 
               nested "ifs" more readble; also replace "*" format with one
               readable by C codes.

--------------------
--------------------

Number:           22

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    plot3c.F

Change:

c     currently don't need blanking data for printout option (iflag=2),
c     so only compute blank2 array for plot3d output option
c
      if (iflag.eq.1) then

To:

c     currently don't need blanking data for printout option (iflag=2),
c     so only compute blank2 array for plot3d output option
c     also, don't compute blanking info if iblnk = 0
c
      if (iflag.eq.1 .or. iblnk.gt.0) then

Change:

         if (i2d .eq. 1) then
#ifdef T3E
 2041       format(3x,39hplot3d files to be read with /mgrid/for,
     .      14h/2d qualifiers)
#else
 2041       format(3x,41hplot3d files to be read with /mgrid/blank,
     .      14h/2d qualifiers)
#endif
         else
            write(11,2042)
#ifdef T3E
 2042       format(3x,39hplot3d files to be read with /mgrid/for,
     .      11h qualifiers)
#else
 2042       format(3x,41hplot3d files to be read with /mgrid/blank,
     .      11h qualifiers)
#endif
         end if

To:

         if (i2d .eq. 1) then
            if (iblnk .eq. 0) then
               write(11,2041)
 2041          format(3x,39hplot3d files to be read with /mgrid/for,
     .         14h/2d qualifiers)
            else
               write(11,2141)
 2141          format(3x,41hplot3d files to be read with /mgrid/blank,
     .         14h/2d qualifiers)
            end if
         else
            if (iblnk .eq. 0) then
               write(11,2042)
 2042          format(3x,39hplot3d files to be read with /mgrid/for,
     .         11h qualifiers)
            else
               write(11,2142)
 2142          format(3x,41hplot3d files to be read with /mgrid/blank,
     .         11h qualifiers)
            end if
         end if

Change:

      if (myid.eq.myhost) then
c
c     ialph > 0 for a grid that was read in plot3d format with alpha measured
c               in the xy plane (TLNS3D convention)
c
c     output grid
c
      if(ibin.eq.0) then
        if(i2d.eq.0) then
        if(ialph.eq.0) then
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        else
        do i=1,iw
           do j=1,jw
              do k=1,kw
                 xg(j,k,i,2) = -xg(j,k,i,2)
              end do
           end do
        end do
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
        else
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
      else
        if(i2d.eq.0) then
        if(ialph.eq.0) then
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .     (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        else
        do i=1,iw
           do j=1,jw
              do k=1,kw
                 xg(j,k,i,2) = -xg(j,k,i,2)
              end do
           end do
        end do
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .      (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
        else
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .      (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
      end if
c
      end if
c
#if defined DIST_MPI
      if (mblk2nd(nblk).eq.myid) then

To:

      if (myid.eq.myhost .and. icall1.eq.0) then
c
c     ialph > 0 for a grid that was read in plot3d format with alpha measured
c               in the xy plane (TLNS3D convention)
c
      if (ialph.ne.0 .and. i2d.ne.1) then
         do i=1,iw
            do j=1,jw
               do k=1,kw
                  temp        = xg(j,k,i,2)
                  xg(j,k,i,2) = xg(j,k,i,3)
                  xg(j,k,i,3) = -temp
               end do
            end do
         end do
      end if
c
c     output grid
c
      if (ibin.eq.0) then
         if (i2d.eq.0) then
            if (iblnk.eq.0) then
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
                 write(3,'(5e14.6)')
     .                     (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                     (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                     (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .                 (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         else
            if (iblnk.eq.0) then
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .               (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         end if
      else
         if (i2d.eq.0) then
            if (iblnk.eq.0) then
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .             (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         else
            if (iblnk.eq.0) then
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .             (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         end if
      end if
c
      end if
c
#if defined DIST_MPI
      if (mblk2nd(nblk).eq.myid) then

Change:  (all occurances)

      write(4,*)

To:

      write(4,'(5e14.6)')

Why corrected: Introduce new parameter to allow blank array in the plot3d
               output file to be turned on or off; some recoding to make
               nested "ifs" more readble; also replace "*" output format
               with one readable by C codes

--------------------
--------------------

Number:           23

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    plot3t.F

After:

c***********************************************************************
c     set iblank (blank2) array
c***********************************************************************
c

Add:

c     don't compute blanking info if iblnk = 0
c
      if (iblnk .gt. 0) then
c

After:

  413    continue
      end if
c
#if defined DIST_MPI
      end if
c
#endif

Add:

      end if

Change:

         if (i2d .eq. 1) then
#ifdef T3E
            write(11,'(''writing turb plot3d file for JDIM X'',
     .      '' KDIM ='',i5,'' x '',i5,'' grid'')') jdim,kdim
            write(11,'(''   plot3d files to be read with 2d/mgrid'',
     .      '' /for qualifiers'')')
#else
            write(11,'(''writing turb plot3d file for JDIM X'',
     .      '' KDIM ='',i5,'' x '',i5,'' grid'')') jdim,kdim
            write(11,'(''   plot3d files to be read with 2d/mgrid'',
     .      ''/blank qualifiers'')')
#endif
         else
            write(11,93)idim,jdim,kdim
   93       format(48h writing turb plot3d file for IDIM X JDIM X KDIM,
     .      2h =,i5,3h x ,i5,3h x ,i5,5h grid)
            write(11,2042)
#ifdef T3E
 2042       format(3x,39hplot3d files to be read with /mgrid/for,
     .      11h qualifiers)
#else
 2042       format(3x,41hplot3d files to be read with /mgrid/blank,
     .      11h qualifiers)
#endif
         end if

To:

         if (i2d .eq. 1) then
            if (iblnk .eq. 0) then
               write(11,'(''writing turb plot3d file for JDIM X'',
     .         '' KDIM ='',i5,'' x '',i5,'' grid'')') jdim,kdim
               write(11,'(''   plot3d files to be read with 2d/mgrid'',
     .         '' qualifiers'')')
            else
               write(11,'(''writing turb plot3d file for JDIM X'',
     .         '' KDIM ='',i5,'' x '',i5,'' grid'')') jdim,kdim
               write(11,'(''   plot3d files to be read with 2d/mgrid'',
     .         ''/blank qualifiers'')')
            end if
         else
            write(11,93)idim,jdim,kdim
   93       format(48h writing turb plot3d file for IDIM X JDIM X KDIM,
     .      2h =,i5,3h x ,i5,3h x ,i5,5h grid)
            if (iblnk .eq. 0) then
               write(11,2042)
 2042          format(3x,35hplot3d files to be read with /mgrid,
     .         11h qualifiers)
            else
               write(11,2142)
 2142          format(3x,41hplot3d files to be read with /mgrid/blank,
     .         11h qualifiers)
            end if
         end if

Change:

      if (myid.eq.myhost) then
c
c     ialph > 0 for a grid that was read in plot3d format with alpha measured
c               in the xy plane (TLNS3D convention)
c
c     output grid
c
      if(ibin.eq.0) then
        if(i2d.eq.0) then
        if(ialph.eq.0) then
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        else
        do i=1,iw
           do j=1,jw
              do k=1,kw
                 xg(j,k,i,2) = -xg(j,k,i,2)
              end do
           end do
        end do
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
        else
        if(icall1.eq.0)
     .  write(3,*)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .            (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .        (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
      else
        if(i2d.eq.0) then
        if(ialph.eq.0) then
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .      (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        else
        do i=1,iw
           do j=1,jw
              do k=1,kw
                 xg(j,k,i,2) = -xg(j,k,i,2)
              end do
           end do
        end do
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .      (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
        else
        if(icall1.eq.0)
     .  write(3)(((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
#ifdef T3E
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
#else
     .          (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .     (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
#endif
        end if
      end if
c
      end if
c
#if defined DIST_MPI
      if (mblk2nd(nblk).eq.myid) then

To:

      if (myid.eq.myhost .and. iblnk.gt.0) then
c
c     ialph > 0 for a grid that was read in plot3d format with alpha measured
c               in the xy plane (TLNS3D convention)
c
      if (ialph.ne.0 .and. i2d.ne.1) then
         do i=1,iw
            do j=1,jw
               do k=1,kw
                  temp        = xg(j,k,i,2)
                  xg(j,k,i,2) = xg(j,k,i,3)
                  xg(j,k,i,3) = -temp
               end do
            end do
         end do
      end if
c
c     output grid
c
      if (ibin.eq.0) then
         if (i2d.eq.0) then
            if (iblnk .eq. 0) then
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .               (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         else
            if (iblnk .eq. 0) then
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3,'(5e14.6)')
     .                   (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                   (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .               (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         end if
      else
         if (i2d.eq.0) then
            if (iblnk .eq. 0) then
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,2),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .             (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         else
            if (iblnk .eq. 0) then
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw)
            else
               write(3)
     .                 (((xg(j,k,i,1),i=1,iw),j=1,jw),k=1,kw),
     .                 (((xg(j,k,i,3),i=1,iw),j=1,jw),k=1,kw),
     .            (((int(xg(j,k,i,4)),i=1,iw),j=1,jw),k=1,kw)
            end if
         end if
      end if
c
      end if
c
#if defined DIST_MPI
      if (mblk2nd(nblk).eq.myid) then

Change:  (all occurances)

      write(4,*)

To:

      write(4,'(5e14.6)')

Why corrected: Introduce new parameter to allow blank array in the plot3d
               output file to be turned on or off; some recoding to make
               nested "ifs" more readble;  also replace "*" output format 
               with one readable by C codes

--------------------
--------------------

Number:           24

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    main.F

Delete:

      common /bin/ ibin

Delete:

c     ibin controls the formatting of the plot3d output files:
c       ibin = 0 - formatted
c       ibin = 1 - unformatted
c
      ibin = 1
#ifdef T3E
      ibin = 0
#endif
c

Delete:

      if (ibin.eq.1) then
         open(unit=3,file=plt3dg,form='unformatted',status='unknown')
         open(unit=4,file=plt3dq,form='unformatted',status='unknown')
      else
         open(unit=3,file=plt3dg,form='formatted',status='unknown')
         open(unit=4,file=plt3dq,form='formatted',status='unknown')
      end if

Delete:

      open(unit=17,file=printout,form='formatted',status='unknown')

After:

c           34......genforce.dat
c           35......cfl3d.sd_res

Add:

c           39......newsurf.p3d


Why corrected: Now open plot3d/print files in mgbl rather than main, in order
               to allow ibin as an input keyword; also add comment for unit
               number for reading in new grid surface data.

--------------------
--------------------

Number:           25

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    getdelt.F, rsurf.F (NEW SUBROUTINES)

Why corrected: Add new capability to read in an updated surface grid (compared
               to the corresponding surface in the volume grid file) and
               deform the current volume grid to that new surface shape
               (steady state mode)

--------------------
--------------------

Number:           26

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global0.F

After:

      common /unit5/ iunit5

Add:

      common /elastic_ss/ idef_ss

Change:

      maxsegdg0 = 1
c
      if (iunst.gt.1) then

To:

      maxsegdg0 = 1
c
      if (iunst.gt.1 .or. idef_ss.gt.0) then


Why corrected: Add new capability to read in an updated surface grid (compared
               to the corresponding surface in the volume grid file) and
               deform the current volume grid to that new surface shape
               (steady state mode)

--------------------
--------------------

Number:           27

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

After:

      common /elastic/ ndefrm,naesrf

Add:

      common /elastic_ss/ idef_ss

Change:

c
c     deforming mesh data
c
      if (iunst.gt.1) then

To:

c
c     deforming mesh data
c
      if (iunst.gt.1 .or. idef_ss.gt.0) then


Why corrected: Add new capability to read in an updated surface grid (compared
               to the corresponding surface in the volume grid file) and
               deform the current volume grid to that new surface shape
               (steady state mode)

--------------------
--------------------

Number:           28

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgbl.F

Change (in call to subroutine setup):

     .           slavept,nslave,iskip,jskip,kskip,bmat,stm,stmi,
     .           gforcn,gforcnm,xxn,nsegdfrm,idfrmseg,iaesurf,
     .           maxsegdg,nmaster,aehist,timekeep)

To:

     .           slavept,nslave,iskip,jskip,kskip,bmat,stm,stmi,
     .           gforcn,gforcnm,xxn,nsegdfrm,idfrmseg,iaesurf,
     .           maxsegdg,nmaster,aehist,timekeep,inpl3d,nplots,
     .           nplot3d,levelg,iadvance,xs,gforcs)


Why corrected: Add new capability to read in an updated surface grid (compared
               to the corresponding surface in the volume grid file) and
               deform the current volume grid to that new surface shape

--------------------
--------------------

Number:           29

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    readkey.F

After:

         if (iunit11.gt.0) then
            write(iunit11,1595)

Add:

            call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)

Change:

 1595 format('*** WARNING: The keyword above is not supported. ***')

To:

 1595 format('*** STOPPING: The keyword above is not supported. ***')

Why corrected: Much safer to stop if incorrect keyword is used

--------------------
--------------------

Number:           30

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F


Change (in subroutine argument list):

     .                 kskip,bmat,stm,stmi,gforcn,gforcnm,xxn,
     .                 nsegdfrm,idfrmseg,iaesurf,maxsegdg,nmaster,
     .                 aehist,timekeep)

To:

     .                 kskip,bmat,stm,stmi,gforcn,gforcnm,xxn,
     .                 nsegdfrm,idfrmseg,iaesurf,maxsegdg,nmaster,
     .                 aehist,timekeep,inpl3d,nplots,nplot3d,levelg,
     .                 iadvance,xs,gforcs)

Change:

      dimension bmat(2*nmds,2*nmds,maxaes),stm(2*nmds,2*nmds,maxaes),
     .          stmi(2*nmds,2*nmds,maxaes),xxn(2*nmds,maxaes),
     .          gforcn(2*nmds,maxaes),gforcnm(2*nmds,maxaes)

To:

      dimension bmat(2*nmds,2*nmds,maxaes),stm(2*nmds,2*nmds,maxaes),
     .          stmi(2*nmds,2*nmds,maxaes),xxn(2*nmds,maxaes),
     .          gforcn(2*nmds,maxaes),gforcnm(2*nmds,maxaes),
     .          gforcs(2*nmds,maxaes),xs(2*nmds,maxaes)

And Add:

      dimension inpl3d(nplots,11),levelg(maxbl),iadvance(maxbl)

After:

      common /elastic/ ndefrm,naesrf

Add:

      common /elastic_ss/ idef_ss

After:

 1000 continue
c

Add:

      if (idef_ss .gt. 0) then
c
c        read in new surface grid and deform mesh to reflect the
c        new surface
c
#if defined DIST_MPI
         if (myid .eq. myhost) then
#endif
         iunitr = 39
         open (unit=iunitr,file='newsurf.p3d',form='formatted',
     .         status='old')
         read(iunitr,*) ndum
         read(iunitr,*) (idum,jdum,kdum,ll=1,ndum)
#if defined DIST_MPI
         end if
#endif
c
c        read in the new surface data and temporarily store in
c        the deltj/deltk/delti arrays
c
         do igrid = 1,ngrid
            nbl = nblg(igrid)
            if (idefrm(nbl) .eq. 1) then
               call lead(nbl,lw,lw2,maxbl)
#if defined DIST_MPI
               if (myid .eq. myhost) then
#endif
               do iseg=1,nsegdfrm(nbl)
                  call rsurf(maxbl,maxsegdg,idim,jdim,kdim,w(ldelti),
     .                       w(ldeltj),w(ldeltk),nbl,icsi,icsf,jcsi,
     .                       jcsf,kcsi,kcsf,iseg,nou,bou,nbuf,
     .                       ibufdim,iunitr)
               end do
#if defined DIST_MPI
               end if
c
c              the following mpi call passes all the deltas in one
c              message; requires contiguous storge of the deltas
c
               nd_dest = mblk2nd(nbl)
c              nvals   = (jdim*kdim+jdim*idim+kdim*idim)*3*2
c
               nvals   = kdim*idim*3*2
               mytag = itag_x + nbl
               if (myid .eq. myhost) then
                  call MPI_Send(w(ldeltj),nvals,MY_MPI_REAL,
     .                          nd_dest,mytag,mycomm,ierr)
               else if (mblk2nd(nbl).eq.myid) then
                  call MPI_Recv(w(ldeltj),nvals,MY_MPI_REAL,
     .                          myhost,mytag,mycomm,istat,ierr)
               end if
c
               nvals   = jdim*idim*3*2
               mytag = itag_y + nbl
               if (myid .eq. myhost) then
                  call MPI_Send(w(ldeltk),nvals,MY_MPI_REAL,
     .                          nd_dest,mytag,mycomm,ierr)
               else if (mblk2nd(nbl).eq.myid) then
                  call MPI_Recv(w(ldeltk),nvals,MY_MPI_REAL,
     .                          myhost,mytag,mycomm,istat,ierr)
               end if
c
               nvals   = jdim*kdim*3*2
               mytag = itag_z + nbl
               if (myid .eq. myhost) then
                  call MPI_Send(w(ldelti),nvals,MY_MPI_REAL,
     .                          nd_dest,mytag,mycomm,ierr)
               else if (mblk2nd(nbl).eq.myid) then
                  call MPI_Recv(w(ldelti),nvals,MY_MPI_REAL,
     .                          myhost,mytag,mycomm,istat,ierr)
               end if
c
#endif
c
c              calculate delta displacement between new surface and
c              current surface
c
#if defined DIST_MPI
               if (mblk2nd(nbl).eq.myid) then
#endif
               lwk1 = 1
               lwk2 = lwk1 + kdim*idim*2
               lwk3 = lwk2 + jdim*idim*2
               lwk4 = lwk3 + jdim*kdim*2
               if (nwork.lt.lwk4) then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),444)
                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
               end if
  444          format(37h not enough work space for subroutine,
     .                 8h getdelt)
c
c              wk(lwk1-lwk4) contain a flag that prevents points common
c              to multiple segments from being updated more than once
c
               do lll=lwk1,lwk4
                  wk(lll) = 1.
               end do
c
               do iseg=1,nsegdfrm(nbl)
                  call getdelt(maxbl,maxsegdg,idim,jdim,kdim,w(ldelti),
     .                        w(ldeltj),w(ldeltk),w(lx),w(ly),w(lz),
     .                        nbl,icsi,icsf,jcsi,jcsf,kcsi,kcsf,
     .                        iseg,nou,bou,nbuf,ibufdim,wk(lwk1),
     .                        wk(lwk2),wk(lwk3))
               end do
#if defined DIST_MPI
               end if
#endif
c
            end if
         end do
c
c        deform volume grid to fit new surface
c
         iwk1 = maxbl
         iwork1 = iwork - iwk1
         if (iwork1.lt.0) then
            nou(1) = min(nou(1)+1,ibufdim)
            write(bou(nou(1),1),'(''stopping...not enough'',
     .           ''integer work space for subroutine updatedg'')')
            call termn8(myid,-1,ibufdim,nbuf,bou,nou)
         end if
         do iii = 1,iwk1
            iwk(iii) = 0
         end do
         iseqr  = mseq
         iupdat = 1
         call updatedg(lw,lw2,w,mgwk,wk,nwork,iupdat,iseqr,maxbl,
     .                 maxgr,maxseg,nbci0,nbcj0,nbck0,nbcidim,
     .                 nbcjdim,nbckdim,ibcinfo,jbcinfo,kbcinfo,
     .                 nblock,levelg,igridg,idefrm,ncgg,iadvance,nou,
     .                 bou,nbuf,ibufdim,myid,myhost,mycomm,mblk2nd,
     .                 utrnsae,vtrnsae,wtrnsae,omgxae,omgyae,omgzae,
     .                 xorgae,yorgae,zorgae,thtxae,thtyae,thtzae,
     .                 rfrqtae,rfrqrae,icsi,icsf,jcsi,jcsf,
     .                 kcsi,kcsf,freq,gmass,damp,x0,gf0,nmds,maxaes,
     .                 aesrfdat,perturb,itrans,irotat,slavept,nslave,
     .                 iskip,jskip,kskip,xs,xxn,nsegdfrm,idfrmseg,
     .                 iaesurf,maxsegdg,iwk,nmaster,1)

c
c         collocate deformed grid points on coarser levels
c
          do igrid=1,ngrid
             call lead(nbl,lw,lw2,maxbl)
             ncg = ncgg(igrid)
             if (ncg.gt.0) then
                do m=1,ncg
                nbl = nbl+1
                if (myid.eq.mblk2nd(nbl)) then
                   lxc = lw(10,nbl)
                   lyc = lw(11,nbl)
                   lzc = lw(12,nbl)
                   nou(1) = min(nou(1)+1,ibufdim)
                   write(bou(nou(1),1),110) nbl,ii2,jj2,kk2
                   call collx(w(lx),w(ly),w(lz),w(lxc),w(lyc),w(lzc),
     .                        jdim,kdim,idim,jj2,kk2,ii2)
                   call lead(nbl,lw,lw2,maxbl)
                end if
                end do
             end if
          end do
c
      end if

Change:

            call init_ae(nmds,maxaes,x0,xxn,wk,bmat,stm,stmi,gforcn,
     .                   gforcnm,freq,damp,gmass,aesrfdat)

To:

            call init_ae(nmds,maxaes,x0,xxn,wk,bmat,stm,stmi,gforcn,
     .                   gforcnm,freq,damp,gmass,aesrfdat,xs,gforcs)


Why corrected: Add new capability to read in an updated surface grid (compared
               to the corresponding surface in the volume grid file) and
               deform the current volume grid to that new surface shape; also
               corrected missing arrays xs and gforcs

--------------------
--------------------

Number:           31

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

After:

      common /moov/ movie,nframes,icall1,lhdr

Add:

      common /elastic_ss/ idef_ss

Change:

c***********************************************************************
c
c     determine number of slave points for deforming mesh case
c
c***********************************************************************
c
      if (iunst.gt.1) then

To:

c***********************************************************************
c
c     determine number of slave points for deforming mesh case
c
c***********************************************************************
c
      if (iunst.gt.1 .or. idef_ss.gt.0) then


Why corrected: Add new capability to read in an updated surface grid (compared
               to the corresponding surface in the volume grid file) and
               deform the current volume grid to that new surface shape

--------------------
--------------------

Number:           32

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    updatedg.F

After:

      common /fsum/ sref,cref,bref,xmc,ymc,zmc
Add:

      common /elastic_ss/ idef_ss

Change:

  440       format(1x,17hdeforming block  ,i4,13h to new shape)

To:

  440       format(1x,28hdeforming surface of block  ,i4,
     .             13h to new shape)

Change:

c     update faces and interior of deforming meshes, and finite
c     difference old and new grid positions to get new grid velocities
c     (velocities stored in work array, at position lvel)
c
      if (iunst .gt. 1) then

To:

c     update faces and interior of deforming meshes, and finite
c     difference old and new grid positions to get new grid velocities
c     (velocities stored in work array, at position lvel)
c
      if (iunst.gt.1 .or. idef_ss.gt.0) then

After:

  445          format(37h not enough work space for subroutine,
     .                 7h deform)
c

Add:

               if (isklton.eq.1)then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),'('' deforming block  '',i4,
     .                  '' to new shape'')') nbl
               end if
c

After:

               if (nt .eq. 1) nflag = 1

Add:

               irst = 0
               if (idef_ss .gt. 0) irst = 1

Change: (in call to deform):

     .                     nbci0,nbcidim,nbcj0,nbcjdim,nbck0,nbckdim,
     .                     ibcinfo,jbcinfo,kbcinfo,maxseg,wk,nsurf,0,

To:

     .                     nbci0,nbcidim,nbcj0,nbcjdim,nbck0,nbckdim,
     .                     ibcinfo,jbcinfo,kbcinfo,maxseg,wk,nsurf,irst,


After:

               call deform(...)

Add:

               if (iunst .gt. 1) then

After:

 1820             continue
c
                  call lead(nbl,lw,lw2,maxbl)
               end if

Add:

c
               end if
c

Change:

      if (isklton.eq.1) then
         call writ_buf(nbl,11,nou,bou,nbuf,ibufdim,myhost,myid,
     .                 mycomm,mblk2nd,maxbl)
      end if

 To:

         call writ_buf(nbl,11,nou,bou,nbuf,ibufdim,myhost,myid,
     .                 mycomm,mblk2nd,maxbl)


Why corrected: Add new capability to read in an updated surface grid (compared
               to the corresponding surface in the volume grid file) and
               deform the current volume grid to that new surface shape

--------------------
--------------------

Number:           33

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist and cfl3dv6/source/cfl3d/libs

Subroutine(s):    setup.F,trnsfr_vals.F,global.F,histout_img.F,readkey.F

Change:

      common /complx/ xmach_img,alpha_img,beta_img,reue_img,tinf_img,
     .                geom_img

To:

      common /complx/ xmach_img,alpha_img,beta_img,reue_img,tinf_img,
     .                geom_img,surf_img


Why corrected: Allow a complex perturbation to new surface grid in order
               to obtain derivative of solution wrt the new grid.

--------------------
--------------------

Number:           34

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    histout_img.F

After:

      else if (real(geom_img) .gt. 0.) then
         write(35,'(''                      derivatives with '',
     .              ''respect to geometry'')')
         delh = real(geom_img)

Add:

      else if (real(surf_img) .gt. 0.) then
         write(35,'(''                      derivatives with '',
     .              ''respect to (surface) geometry'')')
         delh = real(surf_img)


Why corrected: Allow a complex perturbation to new surface grid in order
               to obtain derivative of solution wrt the new grid.


--------------------
--------------------

Number:           35

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/build/cfl/libs and cfl3dv6/build/cflcmplx/libs

Subroutine(s):    makefile (not a subroutine!)

Change: 

        cgnstools.f    fmaps.f

To:

        cgnstools.f    fmaps.f        getdelt.f      rsurf.f

Why corrected: Add the two new subroutines to the library

--------------------
--------------------

Number:           36

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Change:

c
c        set default skip values for block
c
         do nbl=1,nblock
c
            iskp0 = min(4,idimg(nbl)-1)
            jskp0 = min(4,jdimg(nbl)-1)
            kskp0 = min(4,kdimg(nbl)-1)
c
            iskp = iskp0*2
 1100       continue
            iskp = iskp/2
            ichk = int((idimg(nbl)-1)/iskp)*iskp-idimg(nbl)+1
            if (ichk.ne.0 .and. iskp.gt.1) goto 1100
c
            jskp = jskp0*2
 1200       continue
            jskp = jskp/2
            ichk = int((jdimg(nbl)-1)/jskp)*jskp-jdimg(nbl)+1
            if (ichk.ne.0 .and. jskp.gt.1) goto 1200
c
            kskp = kskp0*2
 1300       continue
            kskp = kskp /2
            ichk = int((kdimg(nbl)-1)/kskp)*kskp-kdimg(nbl)+1
            if (ichk.ne.0 .and. kskp.gt.1) goto 1300
c
            iskip(nbl) = iskp
            jskip(nbl) = jskp
            kskip(nbl) = kskp
c
         end do

To:

c
c        set default skip values for block
c
         do ig=1,ngrid
            nbl     = nblg(ig) 
            jdim1   = jdimg(nbl)-1
            kdim1   = kdimg(nbl)-1
            idim1   = idimg(nbl)-1
            ntimes  = 10
c
            jrngmin = jdim1
            krngmin = kdim1
            do iseg=1,nbci0(nbl)
               jrange = abs(ibcinfo(nbl,iseg,3,1)-ibcinfo(nbl,iseg,2,1))
               krange = abs(ibcinfo(nbl,iseg,5,1)-ibcinfo(nbl,iseg,4,1))
               if (jrange.lt.jrngmin) jrngmin = jrange
               if (krange.lt.krngmin) krngmin = krange
               do jexp=1,ntimes
                  power2 = 2**(jexp-1)
                  fact   = jrange/power2
                  if (real(int(fact)).eq.real(fact)) jskip_i0 = power2
               end do
               do kexp=1,ntimes
                  power2 = 2**(kexp-1)
                  fact   = krange/power2
                  if (real(int(fact)).eq.real(fact)) kskip_i0 = power2
               end do
            end do
            do iseg=1,nbcidim(nbl)
               jrange = abs(ibcinfo(nbl,iseg,3,2)-ibcinfo(nbl,iseg,2,2))
               krange = abs(ibcinfo(nbl,iseg,5,2)-ibcinfo(nbl,iseg,4,2))
               if (jrange.lt.jrngmin) jrngmin = jrange
               if (krange.lt.krngmin) krngmin = krange
               do jexp=1,ntimes
                  power2 = 2**(jexp-1)
                  fact   = jrange/power2
                  if (real(int(fact)).eq.real(fact)) jskip_id = power2
               end do
               do kexp=1,ntimes
                  power2 = 2**(kexp-1)
                  fact   = krange/power2
                  if (real(int(fact)).eq.real(fact)) kskip_id = power2
               end do
            end do
            if (jdim1/jrngmin*jrngmin .eq. jrngmin) then
               jskip_i = jrngmin
            else
               jskip_i = min(jskip_i0,jskip_id)
            end if
            if (kdim1/krngmin*krngmin .eq. krngmin) then
               kskip_i = krngmin
            else
               kskip_i = min(kskip_i0,kskip_id)
            end if
c
            irngmin = idim1
            krngmin = kdim1
            do jseg=1,nbcj0(nbl)
               irange = abs(jbcinfo(nbl,jseg,3,1)-jbcinfo(nbl,jseg,2,1))
               krange = abs(jbcinfo(nbl,jseg,5,1)-jbcinfo(nbl,jseg,4,1))
               if (irange.lt.irngmin) irngmin = irange
               if (krange.lt.krngmin) krngmin = krange
               do iexp=1,ntimes
                  power2 = 2**(iexp-1)
                  fact   = irange/power2
                  if (real(int(fact)).eq.real(fact)) iskip_j0 = power2
               end do
               do kexp=1,ntimes
                  power2 = 2**(kexp-1)
                  fact   = krange/power2
                  if (real(int(fact)).eq.real(fact)) kskip_j0 = power2
               end do
            end do
            do jseg=1,nbcjdim(nbl)
               irange = abs(jbcinfo(nbl,jseg,3,2)-jbcinfo(nbl,jseg,2,2))
               krange = abs(jbcinfo(nbl,jseg,5,2)-jbcinfo(nbl,jseg,4,2))
               if (irange.lt.irngmin) irngmin = irange
               if (krange.lt.krngmin) krngmin = krange
               do iexp=1,ntimes
                  power2 = 2**(iexp-1)
                  fact   = irange/power2
                  if (real(int(fact)).eq.real(fact)) iskip_jd = power2
               end do
               do kexp=1,ntimes
                  power2 = 2**(kexp-1)
                  fact   = krange/power2
                  if (real(int(fact)).eq.real(fact)) kskip_jd = power2
               end do
            end do
            if (idim1/irngmin*irngmin .eq. irngmin) then
               iskip_j = irngmin
            else
               iskip_j = min(iskip_j0,iskip_jd)
            end if
            if (kdim1/krngmin*krngmin .eq. krngmin) then
               kskip_j = krngmin
            else
               kskip_j = min(kskip_j0,kskip_jd)
            end if
c
            irngmin = idim1
            jrngmin = jdim1
            do kseg=1,nbck0(nbl)
               irange = abs(kbcinfo(nbl,kseg,3,1)-kbcinfo(nbl,kseg,2,1))
               jrange = abs(kbcinfo(nbl,kseg,5,1)-kbcinfo(nbl,kseg,4,1))
               if (irange.lt.irngmin) irngmin = irange
               if (jrange.lt.jrngmin) jrngmin = jrange
               do iexp=1,ntimes
                  power2 = 2**(iexp-1)
                  fact   = irange/power2
                  if (real(int(fact)).eq.real(fact)) iskip_k0 = power2
               end do
               do jexp=1,ntimes
                  power2 = 2**(jexp-1)
                  fact   = jrange/power2
                  if (real(int(fact)).eq.real(fact)) jskip_k0 = power2
               end do
            end do
            do kseg=1,nbckdim(nbl)
               irange = abs(kbcinfo(nbl,kseg,3,2)-kbcinfo(nbl,kseg,2,2))
               jrange = abs(kbcinfo(nbl,kseg,5,2)-kbcinfo(nbl,kseg,4,2))
               if (irange.lt.irngmin) irngmin = irange
               if (jrange.lt.jrngmin) jrngmin = jrange
               do iexp=1,ntimes
                  power2 = 2**(iexp-1)
                  fact   = irange/power2
                  if (real(int(fact)).eq.real(fact)) iskip_kd = power2
               end do
               do jexp=1,ntimes
                  power2 = 2**(jexp-1)
                  fact   = jrange/power2
                  if (real(int(fact)).eq.real(fact)) jskip_kd = power2
               end do
            end do
            if (idim1/irngmin*irngmin .eq. irngmin) then
               iskip_k = irngmin
            else
               iskip_k = min(iskip_k0,iskip_kd)
            end if
            if (jdim1/jrngmin*jrngmin .eq. jrngmin) then
               jskip_k = jrngmin
            else
               jskip_k = min(jskip_k0,jskip_kd)
            end if
c
            iskip(nbl) = min(iskip_j,iskip_k)
            jskip(nbl) = min(jskip_i,jskip_k)
            kskip(nbl) = min(kskip_i,kskip_j)
c
         end do 
c
c        account for 1-1 interfaces
c
         if (abs(nbli).gt.0) then
            do n=1,abs(nbli)
               igr1 = nblk(1,n)
               igr2 = nblk(2,n)
               nbl1 = nblg(igr1)
               nbl2 = nblg(igr2)
c
               if (isva(1,1,n) .eq. 1) then
                  if (isva(2,1,n) .eq. 1) then
                     iskip(nbl1) = min(iskip(nbl1),iskip(nbl2))
                     iskip(nbl2) = iskip(nbl1)
                  else if (isva(2,1,n) .eq. 2) then
                     iskip(nbl1) = min(iskip(nbl1),jskip(nbl2))
                     jskip(nbl2) = iskip(nbl1)
                  else if (isva(2,1,n) .eq. 3) then
                     iskip(nbl1) = min(iskip(nbl1),kskip(nbl2))
                     kskip(nbl2) = iskip(nbl1)
                  end if
               else if (isva(1,1,n) .eq. 2) then
                  if (isva(2,1,n) .eq. 1) then
                     jskip(nbl1) = min(jskip(nbl1),iskip(nbl2))
                     iskip(nbl2) = jskip(nbl1)
                  else if (isva(2,1,n) .eq. 2) then
                     jskip(nbl1) = min(jskip(nbl1),jskip(nbl2))
                     jskip(nbl2) = jskip(nbl1)
                  else if (isva(2,1,n) .eq. 3) then
                     jskip(nbl1) = min(jskip(nbl1),kskip(nbl2))
                     kskip(nbl2) = jskip(nbl1)
                  end if
               else if (isva(1,1,n) .eq. 3) then
                  if (isva(2,1,n) .eq. 1) then
                     kskip(nbl1) = min(kskip(nbl1),iskip(nbl2))
                     iskip(nbl2) = kskip(nbl1)
                  else if (isva(2,1,n) .eq. 2) then
                     kskip(nbl1) = min(kskip(nbl1),jskip(nbl2))
                     jskip(nbl2) = kskip(nbl1)
                  else if (isva(2,1,n) .eq. 3) then
                     kskip(nbl1) = min(kskip(nbl1),kskip(nbl2))
                     kskip(nbl2) = kskip(nbl1)
                  end if
               end if
c
               if (isva(1,2,n) .eq. 1) then
                  if (isva(2,2,n) .eq. 1) then
                     iskip(nbl1) = min(iskip(nbl1),iskip(nbl2))
                     iskip(nbl2) = iskip(nbl1)
                  else if (isva(2,2,n) .eq. 2) then
                     iskip(nbl1) = min(iskip(nbl1),jskip(nbl2))
                     jskip(nbl2) = iskip(nbl1)
                  else if (isva(2,2,n) .eq. 3) then
                     iskip(nbl1) = min(iskip(nbl1),kskip(nbl2))
                     kskip(nbl2) = iskip(nbl1)
                  end if
               else if (isva(1,2,n) .eq. 2) then
                  if (isva(2,2,n) .eq. 1) then
                     jskip(nbl1) = min(jskip(nbl1),iskip(nbl2))
                     iskip(nbl2) = jskip(nbl1)
                  else if (isva(2,2,n) .eq. 2) then
                     jskip(nbl1) = min(jskip(nbl1),jskip(nbl2))
                     jskip(nbl2) = jskip(nbl1)
                  else if (isva(2,2,n) .eq. 3) then
                     jskip(nbl1) = min(jskip(nbl1),kskip(nbl2))
                     kskip(nbl2) = jskip(nbl1)
                  end if
               else if (isva(1,2,n) .eq. 3) then
                  if (isva(2,2,n) .eq. 1) then
                     kskip(nbl1) = min(kskip(nbl1),iskip(nbl2))
                     iskip(nbl2) = kskip(nbl1)
                  else if (isva(2,2,n) .eq. 2) then
                     kskip(nbl1) = min(kskip(nbl1),jskip(nbl2))
                     jskip(nbl2) = kskip(nbl1)
                  else if (isva(2,2,n) .eq. 3) then
                     kskip(nbl1) = min(kskip(nbl1),kskip(nbl2))
                     kskip(nbl2) = kskip(nbl1)
                  end if
               end if
c
            end do 
         end if

Why corrected: Better default values for iskip,jskip,kskip for deforming
               mesh cases

--------------------
--------------------

Number:           37

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    ccomplex.F

Change:

      y      = aimag(z)

To:

      y      = imag(z)

Why corrected: Use "generic" intrinsic for imaginary part of a complex
               variable rather than the specific one. Should have no impact
               on results.

--------------------
--------------------

Number:           38

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F

Change:

c               1 do a smoothing step using the spring analogy and
c                 mesh shape preservation near the k=1 and k=kdim surfaces

To:

c             > 0 do ismooth smoothing steps using the spring analogy
c                 and mesh shape preservation near the k=1 and k=kdim
c                 surfaces

Change:

       if (ismooth.eq.1) then

To:

       if (ismooth.gt.0) then

Change: (in call to gdsa)

      .             iupdat,nbl,nt,idim,jdim,kdim,iaesol,jsta,jend)

To:

      .             iupdat,nbl,nt,idim,jdim,kdim,iaesol,jsta,jend,
      .             ismooth)

Change: (in gdsa argument list)

      .             zzorg,dvol,xok,xoi,xoj,irotat,ndeftp1,
      .             iupdat,nbl,nt,idmt,jdmt,kdmt,iaesol,jsta,jend)

To:

      .                zzorg,dvol,xok,xoi,xoj,irotat,ndeftp1,
      .                iupdat,nbl,nt,idmt,jdmt,kdmt,iaesol,jsta,jend,
      .                ismooth)

Change:

        tol = .5e-9

To:

        tol = .5e-9
        zzero = 10.**(-iexp)
        if (real(tol).lt.real(zzero)) then
           tol = 10.**(-iexp+1)
        end if

Change:

       do 400 iter = 1,600

To:

       do 400 iter = 1,ismooth

Change:

400    continue
401    continue
       write(43,1220) real(time),nbl,iter,real(xdel)/(real(jdm)*
     .            real(kdm)*real(idm)),
     .               real(ydel)/(real(jdm)*real(kdm)*real(idm)),
     .               real(zdel)/(real(jdm)*real(kdm)*real(idm))

To:

400    continue
c      write(43,1220) real(time),nbl,ismooth,real(xdel)/(real(jdm)*
c    .            real(kdm)*real(idm)),
c    .               real(ydel)/(real(jdm)*real(kdm)*real(idm)),
c    .               real(zdel)/(real(jdm)*real(kdm)*real(idm))
       goto 402
401    continue
c      write(43,1220) real(time),nbl,iter,real(xdel)/(real(jdm)*
c    .            real(kdm)*real(idm)),
c    .               real(ydel)/(real(jdm)*real(kdm)*real(idm)),
c    .               real(zdel)/(real(jdm)*real(kdm)*real(idm))
402    continue

Why corrected: Use ismooth to not only trigger the spring analogy routine, 
               but also to govern the number of smoothing (relaxation)
               iterations performed; add a convergence criterion
               that is sensitive to machine zero; comment out write
               statements that are for debugging purposes only, since
               they won't function properly in parallel.

--------------------
--------------------

Number:           39

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgbl.F, sizer.F

Change:

     .   3x,2(2h *),/2(2h *),18x,13hAugust, 1999.,31x,2(2h *))

To:

     .   3x,2(2h *),/2(2h *),18x,33hRelease Date: October 6, 1999.   ,
     .   11x,2(2h *))

Why corrected: Add release date to output banner; the date is to be kept
               commensurate with the release date as part of version 
               control

--------------------
--------------------

Number:           40

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/maggie

Subroutine(s):    maggie.F

Directory(s):     cfl3dv6/source/ronnie

Subroutine(s):    ronnie.F

Directory(s):     cfl3dv6/source/splitter

Subroutine(s):    splitter.F splitter_cmplx.F

Change:

     .3x,2(2h *),/2(2h *),18x,13hAugust, 1999.,31x,2(2h *))

To:

     .3x,2(2h *),/2(2h *),18x,33hRelease Date: October 6, 1999.   ,
     .11x,2(2h *))

Why corrected: Add release date to output banner; the date is to be kept
               commensurate with the release date as part of version
               control

--------------------
--------------------

Number:           41

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist cfl3dv6/source/precfl3d

Subroutine(s):    main.F


Remove:

c                    August, 1999.

Why corrected: Eliminate redundant release date (release date already appears
               in the output banner).

--------------------
--------------------

Number:           42

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    qout.F

Change: (all occurances)

       write(3,*)

To:

       write(3,'(3i5)')


Change: (all occurances)

       write(4,*)

To:

       write(4,'(3i5)')

Why corrected: Replace "*" output format with one readable by C codes

--------------------
--------------------


Number:           42

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Change: (with similar changes in loops 1379,1479,1579,1679,1779)

         do 1279 l=1,5

To:

         do 1279 l=1,7

Why corrected: There are now 7 slots for boundary condition data, so
               initial all of them.

--------------------
--------------------

Number:           43

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    metric.F

Change: 
            nou(1) = min(nou(1)+1,ibufdim)
            write(bou(nou(1),1),'(/,'' The 2 i-planes need to be'',


To:

            nou(1) = min(nou(1)+1,ibufdim)
            write(bou(nou(1),1),*)
            nou(1) = min(nou(1)+1,ibufdim)
            write(bou(nou(1),1),'('' The 2 i-planes need to be'',

Why corrected: The internal write buffer cannot handle the / carriage
               control...get a message to the effect of "An internal 
               WRITE tried to write beyond the end of an internal file"

--------------------
--------------------

Number:           44

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    main.F

After:

      character*80 inpstring

Add:

      character*80 bcfiles(mxbcfil)

Change:

      call sizer(mwork,mworki,nplots,minnode,iitot,intmax,
     .           maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,
     .           maxbl,maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,
     .           mptch,msub1,nmds,maxaes,maxsegdg,nnodes,nslave,
     .           nmaster,myhost,myid,mycomm,nplots0,maxnode0,mxbli0,
     .           lbcprd0,lbcemb0,lbcrad0,maxbl0,maxgr0,maxseg0,
     .           maxcs0,ncycmax0,intmax0,nsub10,intmx0,mxxe0,
     .           mptch0,msub10,ibufdim0,nbuf0,mxbcfil0,nmds0,
     .           maxaes0,maxsegdg0,imode,ntr)

To:

      call sizer(mwork,mworki,nplots,minnode,iitot,intmax,
     .           maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,
     .           maxbl,maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,
     .           mptch,msub1,nmds,maxaes,maxsegdg,nnodes,nslave,
     .           nmaster,myhost,myid,mycomm,nplots0,maxnode0,mxbli0,
     .           lbcprd0,lbcemb0,lbcrad0,maxbl0,maxgr0,maxseg0,
     .           maxcs0,ncycmax0,intmax0,nsub10,intmx0,mxxe0,
     .           mptch0,msub10,ibufdim0,nbuf0,mxbcfil0,nmds0,
     .           maxaes0,maxsegdg0,imode,ntr,bcfiles,bou,nou)

Change:

      call cfl3d(mwork,mworki,nplots,minnode,iitot,intmax,
     .           maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,maxbl,
     .           maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,mptch,
     .           msub1,ibufdim,nbuf,mxbcfil,istat_size,ntr,
     .           nmds,maxaes,nslave,maxsegdg,nmaster)

To:

      call cfl3d(mwork,mworki,nplots,minnode,iitot,intmax,
     .           maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,maxbl,
     .           maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,mptch,
     .           msub1,ibufdim,nbuf,mxbcfil,istat_size,ntr,
     .           nmds,maxaes,nslave,maxsegdg,nmaster,bcfiles,bou,nou)


Why corrected: Pass the bcfiles,bou,nou arrays into routines sizer and 
               cfl3d for ADIFOR compatability

--------------------
--------------------

Number:           45

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    cfl3d.F

Change:

      subroutine cfl3d(mwork,mworki,nplots,minnode,iitot,intmax,
     .                 maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,maxbl,
     .                 maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,mptch,
     .                 msub1,ibufdim,nbuf,mxbcfil,istat_size,ntr,
     .                 nmds,maxaes,nslave,maxsegdg,nmaster)
To:

      subroutine cfl3d(mwork,mworki,nplots,minnode,iitot,intmax,
     .                 maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,maxbl,
     .                 maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,mptch,
     .                 msub1,ibufdim,nbuf,mxbcfil,istat_size,ntr,
     .                 nmds,maxaes,nslave,maxsegdg,nmaster,bcfiles,
     .                 bou,nou)

Why corrected: Pass the bcfiles,bou,nou arrays into routine cfl3d for
               ADIFOR compatability

--------------------
--------------------

Number:           46

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

Change:

      subroutine sizer(mwork,mworki,nplots,minnode,iitot,intmax,
     .                 maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,
     .                 maxbl,maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,
     .                 mptch,msub1,nmds,maxaes,maxsegdg,nnodes,nslave,
     .                 nmaster,myhost,myid,mycomm,nplots0,maxnode0,
     .                 mxbli0,lbcprd0,lbcemb0,lbcrad0,maxbl0,maxgr0,
     .                 maxseg0,maxcs0,ncycmax0,intmax0,nsub10,intmx0,
     .                 mxxe0,mptch0,msub10,ibufdim0,nbuf0,mxbcfil0,
     .                 nmds0,maxaes0,maxsegdg0,imode,ntr)

To:

      subroutine sizer(mwork,mworki,nplots,minnode,iitot,intmax,
     .                 maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,
     .                 maxbl,maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,
     .                 mptch,msub1,nmds,maxaes,maxsegdg,nnodes,nslave,
     .                 nmaster,myhost,myid,mycomm,nplots0,maxnode0,
     .                 mxbli0,lbcprd0,lbcemb0,lbcrad0,maxbl0,maxgr0,
     .                 maxseg0,maxcs0,ncycmax0,intmax0,nsub10,intmx0,
     .                 mxxe0,mptch0,msub10,ibufdim0,nbuf0,mxbcfil0,
     .                 nmds0,maxaes0,maxsegdg0,imode,ntr,bcfiles,
     .                 bou,nou)

Why corrected: Pass the bcfiles,bou,nou arrays into routine sizer for
               ADIFOR compatability

--------------------
--------------------

Number:           47

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/precfl3d

Subroutine(s):    main.F

Change:

      call sizer(mwork,mworki,nplots,minnode,iitot,intmax,
     .           maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,
     .           maxbl,maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,
     .           mptch,msub1,nmds,maxaes,maxsegdg,nnodes,nslave,
     .           nmaster,myhost,myid,mycomm,nplots0,maxnode0,mxbli0,
     .           lbcprd0,lbcemb0,lbcrad0,maxbl0,maxgr0,maxseg0,
     .           maxcs0,ncycmax0,intmax0,nsub10,intmx0,mxxe0,
     .           mptch0,msub10,ibufdim0,nbuf0,mxbcfil0,nmds0,
     .           maxaes0,maxsegdg0,imode,ntr)

To:

      call sizer(mwork,mworki,nplots,minnode,iitot,intmax,
     .           maxxe,mxbli,nsub1,lbcprd,lbcemb,lbcrad,
     .           maxbl,maxgr,maxseg,maxcs,ncycmax,intmx,mxxe,
     .           mptch,msub1,nmds,maxaes,maxsegdg,nnodes,nslave,
     .           nmaster,myhost,myid,mycomm,nplots0,maxnode0,mxbli0,
     .           lbcprd0,lbcemb0,lbcrad0,maxbl0,maxgr0,maxseg0,
     .           maxcs0,ncycmax0,intmax0,nsub10,intmx0,mxxe0,
     .           mptch0,msub10,ibufdim0,nbuf0,mxbcfil0,nmds0,
     .           maxaes0,maxsegdg0,imode,ntr,bcfiles,bou,nou)

Why corrected: Pass the bcfiles,bou,nou arrays into routine sizer for
               ADIFOR compatability

--------------------
--------------------

Number:           48

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgbl.F

Change:

      nvalsi = 55*maxbl + 116       + 6*maxbl*maxaes + 48*maxbl*maxseg
     .       + 19*mxbli + 22*nplots + 4*maxgr        + 9*maxcs

To:

      nvalsi = 53*maxbl + 117       + 8*maxbl*maxsegdg + 48*maxbl*maxseg
     .       + 19*mxbli + 22*nplots + 4*maxgr          + 9*maxcs

Why corrected: Counter for integer work space out of sync with actual
               usage

--------------------
--------------------

Number:           49

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

After: 

 9009 format(6x,4hgrid,5x,5hnbci0,3x,7hnbcidim,5x,5hnbcj0,3x,7hnbcjdim,
     .                 5x,5hnbck0,3x,7hnbckdim,4x,6hiovrlp)
      msegment = 0

Add:

      lig(1) = 1
      lbg(1) = 1

Why corrected: Initialize before use so Purify doesn't flag it as an
               unititialized memory read

--------------------
--------------------

Number:           50

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs and cfl3dv6/source/cfl3d/dist

Subroutine(s):    global.F and setup.F

Change: 

         if (nbl.gt.1 .and. iovrlp(nbl-1).eq.0) then
            lig(nbl) = lig(nbl-1)
            lbg(nbl) = lbg(nbl-1)
         end if

To:

         if (nbl.gt.1) then
            if (iovrlp(nbl-1).eq.0) then
               lig(nbl) = lig(nbl-1)
               lbg(nbl) = lbg(nbl-1)
            end if
         end if

Why corrected: Slight recoding to supress a (spurious) Purify array bounds
               flag - Purify doesn't seem to be able to handle the double if
               that prevents lig/lbg being accessed with index nbl-1 = 0

--------------------
--------------------

Number:           51

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    bc_xmera.F

After:

      if (iovrlp(nbl).eq.1 .and. ntime.gt.0) then
          ldim = 5

Add:

          call avghole(w(lq),w(lblk),jdim,kdim,idim,nbl,ldim,
     .    int_updt)

After:

         if (iviscg(nbl,1).ge.2 .or. iviscg(nbl,2).ge.2 .or.
     .       iviscg(nbl,3).ge.2) then
             ldim = 1

Add:

             call avghole(w(lvis),w(lblk),jdim,kdim,idim,nbl,ldim,
     .       int_updt)


After:

         if (iviscg(nbl,1).ge.4 .or. iviscg(nbl,2).ge.4 .or.
     .       iviscg(nbl,3).ge.4) then
             ldim = 2

Add:

             call avghole(w(lxib),w(lblk),jdim,kdim,idim,nbl,ldim,
     .       int_updt)

Why corrected: Addition of routine to average blanked-out points with
               neighbors allows orphan points to be accomodated in 
               overset application, and allows use of PEGSUS-generated
               overset interpolation stencils (with suitable preprocessing)

--------------------
--------------------

Number:           52

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/precfl3d

Subroutine(s):    main.F

Change:

      common /filenam/ grid,plt3dg,plt3dq,output,residual,turbres,blomx,
     .                 output2,printout,pplunge,ovrlap,patch,restrt,
     .                 subres,subtur,grdmov,alphahist,errfile

To:

      common /filenam/ grid,plt3dg,plt3dq,output,residual,turbres,blomx,
     .                 output2,printout,pplunge,ovrlap,patch,restrt,
     .                 subres,subtur,grdmov,alphahist,errfile,preout,
     .                 aeinp,aeout,sdhist

Change:

      character*80 grid,plt3dg,plt3dq,output,residual,turbres,blomx,
     .             output2,printout,pplunge,ovrlap,patch,restrt,
     .             subres,subtur,grdmov,alphahist,errfile,preout


To:

      character*80 grid,plt3dg,plt3dq,output,residual,turbres,blomx,
     .             output2,printout,pplunge,ovrlap,patch,restrt,
     .             subres,subtur,grdmov,alphahist,errfile,preout,
     .             aeinp,aeout,sdhist


After:

      character*80  inpstring

Add:

      character*80 bcfiles(mxbcfil)

Why corrected: Fix mismatch in common block and add bcfiles array so
               it can be passed to subroutine sizer (see also correction 47)

--------------------
--------------------

Number:           53

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    init_ae.F

Change:

      .                   gforcnm,freq,damp,gmass,aesrfdat,xs,gforcs)

To:

      .                   gforcnm,freq,damp,gmass,aesrfdat)

Why corrected:    Arrays xs,gforcs are dimensioned in init_ae but were 
                  not passed to the routine.

--------------------
--------------------

Number:           54

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/splitter

Subroutine(s):    cfl3d_to_tlns3d.F,main.F,main_cmplx.F,mapin.F,sizer.F,splitter.F,
                  splitter_cmplx.F,termn8.F,tlns3d_to_cfl3d.F

Change:

                  just get the new routines

Remove:

                  readkey.F from the cfl3dv6/source/splitter directory

Why corrected:    Numerous minor changes so that the readkey.F routine in
                  the cfl3dv6/source/splitter directory could be eliminated
                  in favor of the readkey routine in the cfl3dv6/source/cfl3d/libs
                  directory. Use of one version of the routine eliminates the
                  possibility of the two versions growing out of sync. Note also
                  that the makefiles in the build/splitter/seq and 
                  build/splittercmplx/seq directories are modified also.

--------------------
--------------------

Number:           55

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/ronnie

Subroutine(s):    main.F main_pre.F

Change:

      common /filenam/ grid,plt3dg,plt3dq,output,residual,turbres,blomx,
     .                 output2,printout,pplunge,ovrlap,patch,restrt,
     .                 subres,subtur,grdmov,alphahist,errfile

To:

      common /filenam/ grid,plt3dg,plt3dq,output,residual,turbres,blomx,
     .                 output2,printout,pplunge,ovrlap,patch,restrt,
     .                 subres,subtur,grdmov,alphahist,errfile,preout,
     .                 aeinp,aeout,sdhist

Change:

      character*80 grid,plt3dg,plt3dq,output,residual,turbres,blomx,
     .             output2,printout,pplunge,ovrlap,patch,restrt,
     .             subres,subtur,grdmov,alphahist,errfile,preout

To:

      character*80 grid,plt3dg,plt3dq,output,residual,turbres,blomx,
     .             output2,printout,pplunge,ovrlap,patch,restrt,
     .             subres,subtur,grdmov,alphahist,errfile,preout,
     .             aeinp,aeout,sdhist


Why corrected: Fix mismatch in common block.

--------------------
--------------------

Number:           56

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/ronnie

Subroutine(s):    sizer.F

Change:

      common /params/ lmaxgr,lmaxbl,lmxseg,lmaxcs,lnplts,lmxbli,lmaxxe,
     .                lnsub1,lintmx,lmxxe,liitot,isum,lncycm,
     .                isum_n,lminnode,isumi,isumi_n,lmptch,
     .                lmsub1,lintmax,libufdim,lnbuf,llbcprd,
     .                llbcemb,llbcrad,lnmds,lmaxaes,lnslave

To:

      common /params/ lmaxgr,lmaxbl,lmxseg,lmaxcs,lnplts,lmxbli,lmaxxe,
     .                lnsub1,lintmx,lmxxe,liitot,isum,lncycm,
     .                isum_n,lminnode,isumi,isumi_n,lmptch,
     .                lmsub1,lintmax,libufdim,lnbuf,llbcprd,
     .                llbcemb,llbcrad,lnmds,lmaxaes,lnslave,lmxsegdg,
     .                lnmaster

Why corrected: Fix mismatch in common block.

--------------------
--------------------

Number:           57

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    umalloc_r.F umalloc_c.F

Change:

c               2...integer variable

To:

c               1...integer variable

Why corrected: Fix typo in the description of the input data.

--------------------
--------------------

Number:           58

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    umalloc.F umalloc_r.F umalloc_c.F

Change:

c     intflag - flag to set variable type:
c               0...real variable
c               1...integer variable
c               3...character variable

To:

c     intflag - flag to set variable type:
c              -1...real*4 variable
c               0...real variable
c               1...integer variable

Change:

      parameter(len_i=4,len_c=1)

To:

      parameter(len_i=4,len_r4=4)

Change:

      else if (intflag.eq.3) then
        len = len_c
      end if

To:

      else if (intflag.eq.-1) then
        len = len_r4
      end if

Why corrected: Eliminate unused character variable allocation (it proved
               not to be portable across platforms), and add a real*4
               variable allocation (useful for allocating memory for
               data to be written out to plot3d files)

--------------------
--------------------

Number:           59

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    moddfl.F

Change:

      dimension aesrfdat(5,maxaes),perturb(nmds,maxaes,4),xs(2*nmds)

To:

      dimension aesrfdat(5,maxaes),perturb(nmds,maxaes,4),
     .          xs(2*nmds,maxaes)

Why corrected: Wrong dimensions for array xs

--------------------
--------------------

Number:           60

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/splitter

Subroutine(s):    tlns3d_to_cfl3d.F

Change:

            if ((ibctyp.eq.jbcinfo(n,nbcidim(n),1,m)) .and.
     .          (i1tmn .eq.jbcinfo(n,nbcidim(n),2,m)) .and.
     .          (i1tmx .eq.jbcinfo(n,nbcidim(n),3,m)) .and.
     .          (i2tmn .eq.jbcinfo(n,nbcidim(n),4,m)) .and.
     .          (i2tmx .eq.jbcinfo(n,nbcidim(n),5,m))) then
                go to 6004

To:

            if ((ibctyp.eq.jbcinfo(n,nbcjdim(n),1,m)) .and.
     .          (i1tmn .eq.jbcinfo(n,nbcjdim(n),2,m)) .and.
     .          (i1tmx .eq.jbcinfo(n,nbcjdim(n),3,m)) .and.
     .          (i2tmn .eq.jbcinfo(n,nbcjdim(n),4,m)) .and.
     .          (i2tmx .eq.jbcinfo(n,nbcjdim(n),5,m))) then
                go to 6004

Change:

            if ((ibctyp.eq.kbcinfo(n,nbci0(n),1,m)) .and.
     .          (i1tmn .eq.kbcinfo(n,nbci0(n),2,m)) .and.
     .          (i1tmx .eq.kbcinfo(n,nbci0(n),3,m)) .and.
     .          (i2tmn .eq.kbcinfo(n,nbci0(n),4,m)) .and.
     .          (i2tmx .eq.kbcinfo(n,nbci0(n),5,m))) then
                go to 6005

To:

            if ((ibctyp.eq.kbcinfo(n,nbck0(n),1,m)) .and.
     .          (i1tmn .eq.kbcinfo(n,nbck0(n),2,m)) .and.
     .          (i1tmx .eq.kbcinfo(n,nbck0(n),3,m)) .and.
     .          (i2tmn .eq.kbcinfo(n,nbck0(n),4,m)) .and.
     .          (i2tmx .eq.kbcinfo(n,nbck0(n),5,m))) then
                go to 6005

Change:

            if ((ibctyp.eq.kbcinfo(n,nbcidim(n),1,m)) .and.
     .          (i1tmn .eq.kbcinfo(n,nbcidim(n),2,m)) .and.
     .          (i1tmx .eq.kbcinfo(n,nbcidim(n),3,m)) .and.
     .          (i2tmn .eq.kbcinfo(n,nbcidim(n),4,m)) .and.
     .          (i2tmx .eq.kbcinfo(n,nbcidim(n),5,m))) then
                go to 6006

To:

            if ((ibctyp.eq.kbcinfo(n,nbckdim(n),1,m)) .and.
     .          (i1tmn .eq.kbcinfo(n,nbckdim(n),2,m)) .and.
     .          (i1tmx .eq.kbcinfo(n,nbckdim(n),3,m)) .and.
     .          (i2tmn .eq.kbcinfo(n,nbckdim(n),4,m)) .and.
     .          (i2tmx .eq.kbcinfo(n,nbckdim(n),5,m))) then
                go to 6006


Why corrected: Wrong arrays used for boundary condition segment number

--------------------
--------------------

Number:           61

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/splitter

Subroutine(s):    splitter.F and splitter_cmplx.F

Change:

      call umalloc(ip_isva,4*mxbli,1,icall,memuse)
      call umalloc(ip_nblon,mxbli,1,icall,memuse)
      call umalloc(ip_isva,4*mxbli,1,icall,memuse)
      call umalloc(ip_nblon,mxbli,1,icall,memuse)

To:

      call umalloc(ip_isva,4*mxbli,1,icall,memuse)
      call umalloc(ip_nblon,mxbli,1,icall,memuse)

Why corrected: Allocated memory twice for arrays isva,nblon

--------------------
--------------------

Number:           62

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/splitter

Subroutine(s):    splitter.F and splitter_cmplx.F

After:

  740       continue
c
      end if

Add:

c
c     free up memory
c
      call ufree(ip_ifrom)
      call ufree(ip_xif1)
      call ufree(ip_xif2)
      call ufree(ip_etf1)
      call ufree(ip_etf2)
      call ufree(ip_ito)
      call ufree(ip_xit1)
      call ufree(ip_xit2)
      call ufree(ip_ett1)
      call ufree(ip_ett2)
      call ufree(ip_nfb)
      call ufree(ip_iadvance)
      call ufree(ip_iforce)
      call ufree(ip_nblkk)
      call ufree(ip_limblk)
      call ufree(ip_isva)
      call ufree(ip_nblon)
      call ufree(ip_ncgg)
      call ufree(ip_nblg)
      call ufree(ip_iemg)
      call ufree(ip_inewgg)
      call ufree(ip_bcvali)
      call ufree(ip_bcvalj)
      call ufree(ip_bcvalk)
      call ufree(ip_nbci0)
      call ufree(ip_nbcidim)
      call ufree(ip_nbcj0)
      call ufree(ip_nbcjdim)
      call ufree(ip_nbck0)
      call ufree(ip_nbckdim)
      call ufree(ip_ibcinfo)
      call ufree(ip_jbcinfo)
      call ufree(ip_kbcinfo)
      call ufree(ip_llimit)
      call ufree(ip_iitmax)
      call ufree(ip_mmcxie)
      call ufree(ip_mmceta)
      call ufree(ip_iifit)
      call ufree(ip_iic0)
      call ufree(ip_iiorph)
      call ufree(ip_iredundant)
      call ufree(ip_iconcat)
      call ufree(ip_cq)
      call ufree(ip_cporous)
      call ufree(ip_cpchamber)
      call ufree(ip_cradiation)
      call ufree(ip_isblocin)
      call ufree(ip_ndirin)
      call ufree(ip_isin)
      call ufree(ip_ndirin0)
      call ufree(ip_isin0)
      call ufree(ip_nbs)
      call ufree(ip_imin)
      call ufree(ip_jmin)
      call ufree(ip_kmin)
      call ufree(ip_imax)
      call ufree(ip_jmax)
      call ufree(ip_kmax)
      call ufree(ip_iskp)
      call ufree(ip_jskp)
      call ufree(ip_kskp)
      call ufree(ip_ilo)
      call ufree(ip_jlo)
      call ufree(ip_klo)
      call ufree(ip_iln)
      call ufree(ip_jln)
      call ufree(ip_kln)
      call ufree(ip_ibeg)
      call ufree(ip_npts)
      call ufree(ip_x)
      call ufree(ip_y)
      call ufree(ip_z)
      call ufree(ip_ilosd)
      call ufree(ip_jlosd)
      call ufree(ip_klosd)
      call ufree(ip_il)
      call ufree(ip_jl)
      call ufree(ip_kl)
      call ufree(ip_rkap0g)
      call ufree(ip_levelg)
      call ufree(ip_igridg)
      call ufree(ip_iflimg)
      call ufree(ip_ifdsg)
      call ufree(ip_iviscg)
      call ufree(ip_jdimg)
      call ufree(ip_kdimg)
      call ufree(ip_idimg)
      call ufree(ip_idiagg)
      call ufree(ip_nblcg)
      call ufree(ip_idegg)
      call ufree(ip_jsg)
      call ufree(ip_ksg)
      call ufree(ip_isg)
      call ufree(ip_jeg)
      call ufree(ip_keg)
      call ufree(ip_ieg)
      call ufree(ip_mit)
      call ufree(ip_ilamlog)
      call ufree(ip_ilamhig)
      call ufree(ip_jlamlog)
      call ufree(ip_jlamhig)
      call ufree(ip_klamlog)
      call ufree(ip_klamhig)
      call ufree(ip_imap)
      call ufree(ip_idbloc)
      call ufree(ip_ivisb)
      call ufree(ip_itrb)
      call ufree(ip_val)
      call ufree(ip_xdum)
      call ufree(ip_iold)
      call ufree(ip_nxtseg)
      call ufree(ip_intrfc)
      call ufree(ip_ipatch)
      call ufree(ip_ni)
      call ufree(ip_nj)
      call ufree(ip_nk)
      call ufree(ip_xdmold)
      call ufree(ip_idmold)
      call ufree(ip_nseg1)
      call ufree(ip_nsilo)
      call ufree(ip_nsihi)
      call ufree(ip_nsjlo)
      call ufree(ip_nsjhi)
      call ufree(ip_nsklo)
      call ufree(ip_nskhi)
      call ufree(ip_nb1)
      call ufree(ip_ne1)
      call ufree(ip_nb2)
      call ufree(ip_ne2)
      call ufree(ip_ibct)
      call ufree(ip_bcval)
      call ufree(ip_iovrlp)
      call ufree(ip_ifoflg)
      call ufree(ip_ndat)
      call ufree(ip_xmap)
      call ufree(ip_twotref)
      call ufree(ip_itrb1)
      call ufree(ip_itrb2)
      call ufree(ip_jtrb1)
      call ufree(ip_jtrb2)
      call ufree(ip_ktrb1)
      call ufree(ip_ktrb2)
      call ufree(ip_iturbb)
      call ufree(ip_ibif1)
      call ufree(ip_ibif2)
      call ufree(ip_nbi1)
      call ufree(ip_nei1)
      call ufree(ip_nbj1)
      call ufree(ip_nej1)
      call ufree(ip_nbk1)
      call ufree(ip_nek1)
      call ufree(ip_nbi2)
      call ufree(ip_nei2)
      call ufree(ip_nbj2)
      call ufree(ip_nej2)
      call ufree(ip_nbk2)
      call ufree(ip_nek2)
      call ufree(ip_nd11)
      call ufree(ip_nd21)
      call ufree(ip_nd12)
      call ufree(ip_nd22)
      call ufree(ip_ifsor)
      call ufree(ip_nb1s)
      call ufree(ip_ne1s)
      call ufree(ip_nb2s)
      call ufree(ip_ne2s)
      call ufree(ip_nsubbl)
      call ufree(ip_idobl)
      call ufree(ip_nseg)
      call ufree(ip_idno)
      call ufree(ip_ijk)
      call ufree(ip_idseg)
      call ufree(ip_idnext)

Why corrected: Free up memory - just good coding practice

--------------------
--------------------

Number:           63

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

After:

c
c     add space for timesave array in mgblk
c

Add:

      need = need + lmaxbl

Why corrected: the required space was not added for the sequential mode

--------------------
--------------------

Number:           64

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/splitter

Subroutine(s):    tlns3d_to_cfl3d.F

After all occurances of:

         ns = nbci0( ), ns = nbcidim( ), ns = nbcj0( ), ns = nbcjdim( ),
         ns = nbck0( ), ns = nbckdim( ) 

Add: 
         if (ns.gt.maxseg) then
            write(6,*)'stopping...must increase ',
     .      'parameter maxseg to at least ',ns
            call termn8(0,-3,ibufdim,nbuf,bou,nou)
         end if

Why corrected: Very small potential for the parameter maxseg to be
               exceeded. Maxseg is one of the very few hard-wired 
               parameters in sizer.F, where it is currently set to 200.


--------------------
--------------------

Number:           65

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global0.F

Add:

  numerous small changes; just get entire routine - note that the calling
  statements in the main.F routine in BOTH the source/cfl3d/dist and
  source/precfl3d directories must also change

Why corrected: To help better pinpoint input file errors during the "sizing
               read" step, where many input lines are just "scanned" (read
               as character string) and not read for content or data. The
               changes force the line just read in to be immediately echoed
               to the output file

--------------------
--------------------

Number:           66

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist and cfl3dv6/source/precfl3d

Subroutine(s):    main.F

Change:

      call global0(nplots0,maxnode0,mxbli0,lbcprd0,lbcemb0,
     .             lbcrad0,maxbl0,maxgr0,maxseg0,maxcs0,ncycmax0,
     .             intmax0,nsub10,intmx0,mxxe0,mptch0,msub10,
     .             ibufdim0,nbuf0,mxbcfil0,nmds0,maxaes0,
     .             maxsegdg0,ntr,nnodes,nou,bou)

To:

      iunit11 = 99
      call global0(nplots0,maxnode0,mxbli0,lbcprd0,lbcemb0,
     .             lbcrad0,maxbl0,maxgr0,maxseg0,maxcs0,ncycmax0,
     .             intmax0,nsub10,intmx0,mxxe0,mptch0,msub10,
     .             ibufdim0,nbuf0,mxbcfil0,nmds0,maxaes0,
     .             maxsegdg0,ntr,nnodes,nou,bou,iunit11)

Why corrected: For accomodate change number 65.

--------------------
--------------------

Number:           67

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist and cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Change:

            if (iovrlp(nbl-1).eq.0) then
               lig(nbl) = lig(nbl-1)
               lbg(nbl) = lbg(nbl-1)
            end if

To:

            lig(nbl) = lig(nbl-ncgg(igrid))
            lbg(nbl) = lbg(nbl-ncgg(igrid))

Why corrected: Prevent access of previously undefined values.

--------------------
--------------------

Number:           68

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist and cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F global.F setcorner.F

Change:

        common /deformz/ beta1,ismooth

To: 

        common /deformz/ beta1,ismooth,negvol

Why corrected: To pass new keyword negvol


--------------------
--------------------

Number:           69

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist and cfl3dv6/source/cfl3d/libs

Subroutine(s):    cellvol.F

After:

      dimension sj(jdim*kdim,idim-1,5),sk(jdim*kdim,idim-1,5),
     .          si(jdim*kdim,idim,5)

Add:

c
      common /deformz/ beta1,ismooth,negvol

Change:

      do 64 i=1,idim1
      do 64 k=1,kdim
      do 64 j=1,jdim
      if (real(vol(j,k,i)).gt.0.0) go to 64
      nou(1) = min(nou(1)+1,ibufdim)
      write(bou(nou(1),1),82) i,j,k,nbl
      call termn8(myid,-1,ibufdim,nbuf,bou,nou)
   64 continue
   82 format(39h stopping ... negative volume at i,j,k=,3i5,
     .        6h block,i5)

To:

      if (negvol .eq. 0) then
         do 64 i=1,idim1
         do 64 k=1,kdim
         do 64 j=1,jdim
         if (real(vol(j,k,i)).gt.0.0) go to 64
         nou(1) = min(nou(1)+1,ibufdim)
         write(bou(nou(1),1),82) i,j,k,nbl
         call termn8(myid,-1,ibufdim,nbuf,bou,nou)
   64    continue
   82    format(39h stopping ... negative volume at i,j,k=,3i5,
     .           6h block,i5)
      else
         do 65 i=1,idim1
         do 65 k=1,kdim
         do 65 j=1,jdim
         if (real(vol(j,k,i)).gt.0.0) go to 65
         vol(j,k,i) = ccabs(vol(j,k,i))
         nou(1) = min(nou(1)+1,ibufdim)
         write(bou(nou(1),1),83) i,j,k,nbl
   65    continue
   83    format(39h WARNING  ... negative volume at i,j,k=,3i5,
     .             6h block,i5,14h not stopping!)
      end if

Why corrected: To allow user to turn off built in stop for negative
               volumes in order to help debug deforming mesh cases.

--------------------
--------------------

Number:           70

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F

After:

      common /elastic_ss/ idef_ss

Add:

      common /deformz/ beta1,ismooth,negvol

Change:

      if (iflag .gt. 0 .and. myid.eq.myhost) then
        write(11,'('' Fatal error(s) uncovered in grid metrics'')')
        call termn8(myid,-1,ibufdim,nbuf,bou,nou)
      end if

To:

      if (iflag .gt. 0 .and. myid.eq.myhost) then
        write(11,'('' Fatal error(s) uncovered in grid metrics'')')
        if (negvol .eq. 0) then
           call termn8(myid,-1,ibufdim,nbuf,bou,nou)
         end if
      end if


Why corrected: To allow user to turn off built in stop for poor quality
               grids in order to help debug deforming mesh cases.

--------------------
--------------------

Number:           71

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    qface.F

Change:

      subroutine qface(jdim,kdim,idim,dum,dumj0,dumk0,dumi0,bcj,bck,bci,
     .                 ldim)

To:

      subroutine qface(jdim,kdim,idim,dum,dumj0,dumk0,dumi0,bcj,bck,bci,
     .                 blank,ldim)

After:

      dimension dum(jdim,kdim,idim,ldim), dumj0(kdim,idim-1,ldim,4),
     .          dumk0(jdim,idim-1,ldim,4),dumi0(jdim,kdim,ldim,4)

Add:

      dimension blank(jdim,kdim,idim)

Change:

         aa = 1. +  bcj(kk,ii,m)
         bb = 1. -  bcj(kk,ii,m)
         dumj0(kk,ii,l,2) = 0.5*(bb*dum(1,kk,ii,l)+aa*dumj0(kk,ii,l,1))

To:

         aa = 1. +  bcj(kk,ii,m)
         bb = 1. -  bcj(kk,ii,m)
         cc = 0.
         if (blank(1,kk,ii).eq.0) then
            aa = 0.
            bb = 3.
            cc = -1.
         end if
         dumj0(kk,ii,l,2) = 0.5*(aa*dumj0(kk,ii,l,1)
     .                    +      bb*dum(1,kk,ii,l)
     .                    +      cc*dum(2,kk,ii,l))

Change:

         aa = 1. +  bcj(kk,ii,m)
         bb = 1. -  bcj(kk,ii,m)
         dumj0(kk,ii,l,4) = 0.5*(aa*dumj0(kk,ii,l,3)
     .                    +      bb*dum(jdim-1,kk,ii,l))

To:

         aa = 1. +  bcj(kk,ii,m)
         bb = 1. -  bcj(kk,ii,m)
         cc = 0.
         if (blank(jdim-1,kk,ii).eq.0) then
            aa = 0.
            bb = 3.
            cc = -1.
         end if
         dumj0(kk,ii,l,4) = 0.5*(aa*dumj0(kk,ii,l,3)
     .                    +      bb*dum(jdim-1,kk,ii,l)
     .                    +      cc*dum(jdim-2,kk,ii,l))

Change:

         aa = 1. +  bck(jj,ii,m)
         bb = 1. -  bck(jj,ii,m)
         dumk0(jj,ii,l,2) = 0.5*(bb*dum(jj,1,ii,l)
     .                    +      aa*dumk0(jj,ii,l,1))

To:

         aa = 1. +  bck(jj,ii,m)
         bb = 1. -  bck(jj,ii,m)
         cc = 0.
         if (blank(jj,1,ii).eq.0) then
            aa = 0.
            bb = 3.
            cc = -1.
         end if
         dumk0(jj,ii,l,2) = 0.5*(aa*dumk0(jj,ii,l,1)
     .                    +      bb*dum(jj,1,ii,l)
     .                    +      cc*dum(jj,2,ii,l))

Change:

         aa = 1. +  bck(jj,ii,m)
         bb = 1. -  bck(jj,ii,m)
         dumk0(jj,ii,l,4) = 0.5*(aa*dumk0(jj,ii,l,3)
     .                    +      bb*dum(jj,kdim-1,ii,l))

To:

         aa = 1. +  bck(jj,ii,m)
         bb = 1. -  bck(jj,ii,m)
         cc = 0.
         if (blank(jj,kdim-1,ii).eq.0) then
            aa = 0.
            bb = 3.
            cc = -1.
         end if
         dumk0(jj,ii,l,4) = 0.5*(aa*dumk0(jj,ii,l,3)
     .                    +      bb*dum(jj,kdim-1,ii,l)
     .                    +      cc*dum(jj,kdim-2,ii,l))

After:

c
c     i - boundaries
c
      do 8400 m=1,2
      kmin = 1
      kmax = kdim-1
      jmin = 1
      jmax = jdim-1

Add:

      if (i2d.eq.1) i2 = 1
      id2  = idim-2
      if (i2d.eq.1) id2 = idim-1

Change:

         aa = 1. +  bci(jj,kk,m)
         bb = 1. -  bci(jj,kk,m)
         dumi0(jj,kk,l,2) = 0.5*(bb*dum(jj,kk,1,l)
     .                    +      aa*dumi0(jj,kk,l,1))

To:

         aa = 1. +  bci(jj,kk,m)
         bb = 1. -  bci(jj,kk,m)
         cc = 0.
         if (blank(jj,kk,1).eq.0) then
            aa = 0.
            bb = 3.
            cc = -1.
         end if
         dumi0(jj,kk,l,2) = 0.5*(aa*dumi0(jj,kk,l,1)
     .                    +      bb*dum(jj,kk,1,l)
     .                    +      cc*dum(jj,kk,i2,l))

Change:

         aa = 1. +  bci(jj,kk,m)
         bb = 1. -  bci(jj,kk,m)
         dumi0(jj,kk,l,4)  = 0.5*(aa*dumi0(jj,kk,l,3)
     .                     +      bb*dum(jj,kk,idim-1,l))

To:

         aa = 1. +  bci(jj,kk,m)
         bb = 1. -  bci(jj,kk,m)
         cc = 0.
         if (blank(jj,kk,idim-1).eq.0) then
            aa = 0.
            bb = 3.
            cc = -1.
         end if
         dumi0(jj,kk,l,4)  = 0.5*(aa*dumi0(jj,kk,l,3)
     .                     +      bb*dum(jj,kk,idim-1,l)
     .                     +      cc*dum(jj,kk,id2,l))

Why corrected: Should not use ghost-cell values to calculate cell-face
               center data if the neighboring interior cells are blanked 
               out (in which case the ghost cells may not 
               - and need not - be updated). In such cases, extrapolate
               to the face from the interior.


--------------------
--------------------

Number:           72

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    qout.F and yplusout.F

Change:

                     call qface(jdim,kdim,idim,w(lq),w(lqj0),
     .                          w(lqk0),w(lqi0),w(lbcj),w(lbck),
     .                          w(lbci),ldim)

To:
                     call qface(jdim,kdim,idim,w(lq),w(lqj0),
     .                          w(lqk0),w(lqi0),w(lbcj),w(lbck),
     .                          w(lbci),w(lblk),ldim)

Why corrected: Change calling argument list of qface to match
               the one resulting from change 71.

--------------------
--------------------

Number:           73

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

After:

      common /elastic_ss/ idef_ss

Add:

      common /memory/ memadd,memaddi

Before:

c***********************************************************************
c
c     set the auxiliary array sizes and print them out
c
c***********************************************************************

Add:

c
c     add any extra memory input by the user
c     (memadd, memaddi default to zero)
c
      if (nnodes.eq.1) then
         isum    = isum  + memadd
         isumi   = isumi + memaddi
      else
         isum_n  = isum_n  + memadd
         isumi_n = isumi_n + memaddi
      end if

Why corrected: Allow user to "pad" size of real and/or integer work
               arrays in the event that the sizing routine has
               misjudged the memory requirements.


--------------------
--------------------

Number:           74

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    intrbc.F

Change:

  Just get new routine...also calls new routine "augmntq"

Why corrected: To allow "augmented cell center" interpolation stencils from
               PEGSUS


--------------------
--------------------

Number:           75

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    calyplus.F

Change:

            if (real(yplusk(j,i,m)).lt.real(ypmin)) then

To:

            if (real(yplusk(j,i,m)).gt.0. .and.
     .         real(yplusk(j,i,m)).lt.real(ypmin)) then

Note: Similar changes in 2 other locations involving yplusj(k,i,m) and 
      yplusi(j,k,m)

Why corrected: To prevent 0 being selected as the minimum value of y+ in
               situations where the skin friction is identically zero, as
               can now happen on solid walls that have holes cut in them
               for overset grids.
               PEGSUS

--------------------
--------------------

Number:           76

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

Change:

c
c           update the overlapped values if chimera scheme is used
c
            if (iovrlp(nbl).eq.1) then
                ldim = 5
                if (isklton.eq.1) then
                   nou(1) = min(nou(1)+1,ibufdim)
                   write(bou(nou(1),1),2060) nbl
                end if
                call intrbc(w(lq),jdim,kdim,idim,nbl,ldim,maxbl,
     .                      iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                      iiig,jjig,kkig,qb,nou,bou,nbuf,ibufdim)
c               turbulence quantities
                if(iviscg(nbl,1).ge.2 .or. iviscg(nbl,2).ge.2 .or.
     .             iviscg(nbl,3).ge.2) then
                   ldim = 1
                   call intrbc(w(lvis),jdim,kdim,idim,nbl,ldim,maxbl,
     .                         iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                         iiig,jjig,kkig,qb,nou,bou,nbuf,ibufdim)
                end if
                if(iviscg(nbl,1).ge.4 .or. iviscg(nbl,2).ge.4 .or.
     .             iviscg(nbl,3).ge.4) then
                   ldim = 2
                   call intrbc(w(lxib),jdim,kdim,idim,nbl,ldim,maxbl,
     .                         iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                         iiig,jjig,kkig,qb,nou,bou,nbuf,ibufdim)
                end if
            end if

To:

c
c           update the overlapped values if chimera scheme is used
c
            if (iovrlp(nbl).eq.1) then
                ldim = 5
                if (isklton.eq.1) then
                   nou(1) = min(nou(1)+1,ibufdim)
                   write(bou(nou(1),1),2060) nbl
                end if
                need  = (idim+1)*(jdim+1)*(kdim+1)*5
                if (need .gt. nwork) then
                   nou(1) = min(nou(1)+1,ibufdim)
                   write(bou(nou(1),1),'(''stopping...not enough work'',
     .             '' space for subroutine intrbc (q)'')')
                   nou(1) = min(nou(1)+1,ibufdim)
                   write(bou(nou(1),1),'(''need, have '',2i11)')
     .             need,nwork
                   call termn8(myid,-1,ibufdim,nbuf,bou,nou)
                end if
                call intrbc(w(lq),jdim,kdim,idim,nbl,ldim,maxbl,
     .                      iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                      iiig,jjig,kkig,qb,w(lqj0),w(lqk0),
     .                      w(lqi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                      bou,nbuf,ibufdim,0)
c               turbulence quantities
                if(iviscg(nbl,1).ge.2 .or. iviscg(nbl,2).ge.2 .or.
     .             iviscg(nbl,3).ge.2) then
                   ldim = 1
                   call intrbc(w(lvis),jdim,kdim,idim,nbl,ldim,maxbl,
     .                         iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                         iiig,jjig,kkig,qb,w(lvj0),w(lvk0),
     .                         w(lvi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                         bou,nbuf,ibufdim,0)
                end if
                if(iviscg(nbl,1).ge.4 .or. iviscg(nbl,2).ge.4 .or.
     .             iviscg(nbl,3).ge.4) then
                   ldim = 2
                   call intrbc(w(lxib),jdim,kdim,idim,nbl,ldim,maxbl,
     .                         iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                         iiig,jjig,kkig,qb,w(ltj0),w(ltk0),
     .                         w(lti0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                         bou,nbuf,ibufdim,0)
                end if
            end if

Change:

c
c              add corrections to chimera grids
c
               if (iovrlp(nblf).eq.1) then
                  if (isklton.eq.1) then
                     nou(1) = min(nou(1)+1,ibufdim)
                     write(bou(nou(1),1),2060) nblf
                  end if
                  ldim=5
                  call intrbc(w(lq),jdim,kdim,idim,nblf,ldim,maxbl,
     .                        iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                        iiig,jjig,kkig,qb,nou,bou,nbuf,ibufdim)
               end if

To:

c
c              add corrections to chimera grids
c
               if (iovrlp(nblf).eq.1) then
                  if (isklton.eq.1) then
                     nou(1) = min(nou(1)+1,ibufdim)
                     write(bou(nou(1),1),2060) nblf
                  end if
                  ldim=5
                  call intrbc(w(lq),jdim,kdim,idim,nblf,ldim,maxbl,
     .                        iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                        iiig,jjig,kkig,qb,w(lqj0),w(lqk0),
     .                        w(lqi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                        bou,nbuf,ibufdim,1)
               end if


Why corrected: To accomodate "augmented cell-center" interpolation stencils
               from PEGSUS


--------------------
--------------------

Number:           77

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

Change:  (2 places)

                  call wrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
     .            w(lqi0),ncycmax,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .            cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,cfttotw,
     .            rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),w(lxib),
     .            w(lsnk0),w(lsni0),w(lxkb),w(lnbl),w(lcmuv),
c   ***CGNSstart
c    .            thetay,maxbl,myid,myhost,mycomm,mblk2nd)
     .            thetay,maxbl,myid,myhost,mycomm,mblk2nd,igrid,wk,
     .            idima,jdima,kdima,w(lbcj),w(lbck),w(lbci),w(lvj0),
     .            w(lvk0),w(lvi0),w(ltj0),w(ltk0),w(lti0))
c   ***CGNSend

To: (2 places)

                  call wrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
     .            w(lqi0),ncycmax,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .            cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,cfttotw,
     .            rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),w(lxib),
     .            w(lsnk0),w(lsni0),w(lxkb),w(lnbl),w(lcmuv),
c   ***CGNSstart
c    .            thetay,maxbl,myid,myhost,mycomm,mblk2nd)
     .            thetay,maxbl,myid,myhost,mycomm,mblk2nd,igrid,wk,
     .            idima,jdima,kdima,w(lbcj),w(lbck),w(lbci),w(lvj0),
     .            w(lvk0),w(lvi0),w(ltj0),w(ltk0),w(lti0),iovrlp,qb,
     .            iipntsg,lig,iitot)
c   ***CGNSend


Why Changed:   Allow qb array to be written to the restart file in order
               to have clean restarts when using "augmented cell-center"
               stencils from PEGSUS

--------------------
--------------------

Number:           78

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    wrest.F

Change: (in subroutine argument list)

     .                 tj0,tk0,ti0)

To:
     .                 tj0,tk0,ti0,iovrlp,qb,iipntsg,lig,iitot)


After:

      dimension thetay(maxbl),mblk2nd(maxbl)

Add:

      dimension qb(iitot,5,3),iipntsg(maxbl),lig(maxbl),iovrlp(maxbl),
     .          mytag_qb(8)

After:

      common /reyue/ reue,tinf,ivisc(3)

Add:

      common /maxiv/ ivmx

After:

      itag_ti0   = itag_vk0   + ioffset
      itag_tj0   = itag_ti0   + ioffset
      itag_tk0   = itag_tj0   + ioffset
      end if
c   ***CGNSend

Add:

      mytag_qb(1) = 0
      do ll=2,8
        mytag_qb(ll) = mytag_qb(ll-1) + maxbl
      end do

After:

c   ***CGNSstart
      if (icgns .eq. 1 .and. myid .eq. myhost) then
#if defined CGNS
        call writeeqn(iccg,ibase,igrid,ivisc(1),ivisc(2),ivisc(3),ideg)
        call writeturb(iccg,ibase,igrid,nsoluse,idima,jdima,kdima,
     +   idim,jdim,kdim,ivisc,wk,vist3d,tursav,smin,xjb,xkb,
     +   tursav(1,1,1,2),blnum,cmuv,vj0,vk0,vi0,tj0,tk0,ti0,i2d)
#endif
      end if
c   ***CGNSend

Add:

c
c     write qb array for overset grids
c
      if(iovrlp(nbl) .gt. 0) then
c
#if defined DIST_MPI
c        send data from host to node that owns block nbl; note
c        that later (in setup) the nodes share their data with
c        each other so all nodes end up with all the qb data
c
          nvalqb  = iipntsg(nbl)
          nd_srce = mblk2nd(nbl)
          do ll=1,5
             mytag = mytag_qb(ll) + nbl
             if (myid .eq. mblk2nd(nbl)) then
                call MPI_Send(qb(lig(nbl),ll,1),nvalqb,
     .                        MY_MPI_REAL,
     .                        myhost,mytag,mycomm,ierr)
             else if (myid .eq. myhost) then
                call MPI_Recv(qb(lig(nbl),ll,1),nvalqb,
     .                        MY_MPI_REAL,
     .                        nd_srce,mytag,mycomm,istat,ierr)
             end if
          end do
          if (ivmx.ge.2) then
             mytag = mytag_qb(6) + nbl
             if (myid .eq. mblk2nd(nbl)) then
                call MPI_Send(qb(lig(nbl),1,2),nvalqb,
     .                        MY_MPI_REAL,
     .                        myhost,mytag,mycomm,ierr)
             else if (myid .eq. myhost) then
                call MPI_Recv(qb(lig(nbl),1,2),nvalqb,
     .                        MY_MPI_REAL,
     .                        nd_srce,mytag,mycomm,istat,ierr)
             end if
          end if
          if (ivmx.ge.4) then
             do ll=1,2
                mytag = mytag_qb(6+ll) + nbl
                if (myid .eq. mblk2nd(nbl)) then
                   call MPI_Send(qb(lig(nbl),ll,3),nvalqb,
     .                           MY_MPI_REAL,
     .                           myhost,mytag,mycomm,ierr)
                else if (myid .eq. myhost) then
                   call MPI_Recv(qb(lig(nbl),ll,3),nvalqb,
     .                           MY_MPI_REAL,
     .                           nd_srce,mytag,mycomm,istat,ierr)
                end if
             end do
          end if
c
#endif
         lsta = lig(nbl)
         lend = lsta - 1
         if (myid .eq. myhost) then
            if (iipntsg(nbl).gt.0) then
               lend = lsta + iipntsg(nbl) - 1
               do iset=1,3
                  do ll=1,5
                     do ii=lsta,lend
                        write(2) qb(ii,ll,iset)
                     end do
                  end do
               end do
            end if
         end if
      end if
c

Why Changed:   Allow qb array to be written to the restart file in order
               to have clean restarts when using "augmented cell-center"
               stencils from PEGSUS


--------------------
--------------------

Number:           79

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    rrest.F


Change: (in subroutine argument list)

     .                 igrid,wk,idima,jdima,kdima)

To:

     .                 igrid,wk,idima,jdima,kdima,iovrlp,qb,iipntsg,
     .                 lig,iitot)

After:

     .          cmuv(jdim-1,kdim-1,idim-1)

Add:

      dimension qb(iitot,5,3),iipntsg(maxbl),lig(maxbl),iovrlp(maxbl),
     .          mytag_qb(8)


After:

      itag_cmuv    = itag_blnum   + ioffset

Add:

      mytag_qb(1) = 0
      do ll=2,8
        mytag_qb(ll) = mytag_qb(ll-1) + maxbl
      end do

After:

#if defined DIST_MPI
          end if
c
          mytag = itag_cmuv + nbl
          if (myid .eq. myhost) then
             call MPI_Send(cmuv,jkim,MY_MPI_REAL,
     .                    nd_dest,mytag,mycomm,ierr)
          else if (myid .eq. mblk2nd(nbl)) then
             call MPI_Recv(cmuv,jkim,MY_MPI_REAL,
     .                     myhost,mytag,mycomm,istat,ierr)
          end if
#endif
        end if
      end if
      end if

Add:

c
c     read qb array for overset grids
c
      if(iovrlp(nbl) .gt. 0) then
         lsta = lig(nbl)
         lend = lsta - 1
         if (myid .eq. myhost) then
            if (iipntsg(nbl).gt.0) then
               lend = lsta + iipntsg(nbl) - 1
               do iset=1,3
                  do ll=1,5
                     do ii=lsta,lend
                        read(2) qb(ii,ll,iset)
                     end do
                  end do
               end do
            end if
         end if
#if defined DIST_MPI
c
c         send data from host to node that owns block nbl; note
c         that later (in setup) the nodes share their data with
c         each other so all nodes end up with all the qb data
c
          nvalqb  = iipntsg(nbl)
          nd_dest = mblk2nd(nbl)
          do ll=1,5
             mytag = mytag_qb(ll) + nbl
             if (myid .eq. myhost) then
                call MPI_Send(qb(lig(nbl),ll,1),nvalqb,
     .                        MY_MPI_REAL,
     .                        nd_dest,mytag,mycomm,ierr)
             else if (myid .eq. mblk2nd(nbl)) then
                call MPI_Recv(qb(lig(nbl),ll,1),nvalqb,
     .                        MY_MPI_REAL,
     .                        myhost,mytag,mycomm,istat,ierr)
             end if
          end do
          if (ivmx.ge.2) then
             mytag = mytag_qb(6) + nbl
             if (myid .eq. myhost) then
                call MPI_Send(qb(lig(nbl),1,2),nvalqb,
     .                        MY_MPI_REAL,
     .                        nd_dest,mytag,mycomm,ierr)
             else if (myid .eq. mblk2nd(nbl)) then
                call MPI_Recv(qb(lig(nbl),1,2),nvalqb,
     .                        MY_MPI_REAL,
     .                        myhost,mytag,mycomm,istat,ierr)
             end if
          end if
          if (ivmx.ge.4) then
             do ll=1,2
                mytag = mytag_qb(6+ll) + nbl
                if (myid .eq. myhost) then
                   call MPI_Send(qb(lig(nbl),ll,3),nvalqb,
     .                           MY_MPI_REAL,
     .                           nd_dest,mytag,mycomm,ierr)
                else if (myid .eq. mblk2nd(nbl)) then
                   call MPI_Recv(qb(lig(nbl),ll,3),nvalqb,
     .                           MY_MPI_REAL,
     .                           myhost,mytag,mycomm,istat,ierr)
                end if
             end do
          end if
#endif
      end if


Why Changed:   Allow qb array to be read from the restart file in order
               to have clean restarts when using "augmented cell-center"
               stencils from PEGSUS

--------------------
--------------------

Number:           80

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F


Change:

#if defined DIST_MPI
         mytag   = itag_flag + nblout
         nd_scrc = mblk2nd(nblout)
c
         if (mblk2nd(nblout).eq.myid) then
            call MPI_Send (iflag, 1, MPI_INTEGER,
     .                     myhost, mytag, mycomm, ierr)
         else if (myid.eq.myhost) then
            call MPI_Recv (iflag, 1, MPI_INTEGER,
     .                     nd_scrc,mytag,mycomm,istat,ierr)
         end if
c
#endif

To:

#if defined DIST_MPI
         mytag   = itag_flag + nblout
         nd_scrc = mblk2nd(nblout)
c
         if (mblk2nd(nblout).eq.myid) then
            call MPI_Send (iflag, 1, MPI_INTEGER,
     .                     myhost, mytag, mycomm, ierr)
         else if (myid.eq.myhost) then
            call MPI_Recv (iflag1, 1, MPI_INTEGER,
     .                     nd_scrc,mytag,mycomm,istat,ierr)
            iflag = max(iflag, iflag1)
         end if
c
#endif


Why Changed:   To allow correct stopping of the code in MPI mode when
               extremely poor grid quality is detected. Without the
               fix, if some processors had iflag=0 and others had iflag=1,
               then depending on the order in which the host received these
               messages, it would either stop the code (correct) or not
               (incorrect).


--------------------
--------------------

Number:           81

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F

Move:

#if defined DIST_MPI
      call MPI_Bcast (lig, maxbl, MPI_INTEGER, myhost,
     .                mycomm, ierr)
      call MPI_Bcast (iipntsg, maxbl, MPI_INTEGER, myhost,
     .                mycomm, ierr)
      mytag_qb(1) = 0
      do ll=2,8
         mytag_qb(ll) = mytag_qb(ll-1) + maxbl
      end do
      nreq = 1
 
#endif

To Following:

 1600 continue
c

Change:

            call rrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
     .                 ncycmax,ntr,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .                 cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,
     .                 cfttotw,rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),
     .                 w(lxib),w(lsnk0),w(lsni0),w(lxkb),w(lnbl),
     .                 w(lcmuv),maxbl,mblk2nd,myid,myhost,mycomm,
c   ***CGNSstart
c    .                 nou,bou,nbuf,ibufdim)
     .                 nou,bou,nbuf,ibufdim,igrid,
     .                 wk,idima,jdima,kdima)
c   ***CGNSend


To:

            call rrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
     .                 ncycmax,ntr,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .                 cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,
     .                 cfttotw,rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),
     .                 w(lxib),w(lsnk0),w(lsni0),w(lxkb),w(lnbl),
     .                 w(lcmuv),maxbl,mblk2nd,myid,myhost,mycomm,
c   ***CGNSstart
c    .                 nou,bou,nbuf,ibufdim)
     .                 nou,bou,nbuf,ibufdim,igrid,
     .                 wk,idima,jdima,kdima,iovrlp,qb,iipntsg,
     .                 lig,iitot)
c   ***CGNSend


After:

      do 2110 icg=1,ncg+1
      nbl = nbl+1
      if (iovrlp(nbl).eq.1) then
         if (myid.eq.mblk2nd(1)) then
            if (iflg .eq.0) then
               nou(1) = min(nou(1)+1,ibufdim)
               write(bou(nou(1),1),*)
            end if
            iflg = 1
         end if

Add:

         if (irest.eq.0) then

Change:

             call intrbc(w(lq),jdim,kdim,idim,nbl,ldim,maxbl,
     .                   iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                   iiig,jjig,kkig,qb,nou,bou,nbuf,ibufdim)
             if(iviscg(nbl,1).ge.2 .or. iviscg(nbl,2).ge.2 .or.
     .          iviscg(nbl,3).ge.2) then
                ldim = 1
                call intrbc(w(lvis),jdim,kdim,idim,nbl,ldim,maxbl,
     .                      iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                      iiig,jjig,kkig,qb,nou,bou,nbuf,ibufdim)
             end if
             if(iviscg(nbl,1).ge.4 .or. iviscg(nbl,2).ge.4 .or.
     .          iviscg(nbl,3).ge.4) then
                ldim = 2
                call intrbc(w(lxib),jdim,kdim,idim,nbl,ldim,maxbl,
     .                      iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                      iiig,jjig,kkig,qb,nou,bou,nbuf,ibufdim)
             end if
         end if

To:

                need  = (idim+1)*(jdim+1)*(kdim+1)*5
                if (need .gt. nwork) then
                   nou(1) = min(nou(1)+1,ibufdim)
                   write(bou(nou(1),1),'(''stopping...not enough work'',
     .             '' space for subroutine intrbc (q)'')')
                   nou(1) = min(nou(1)+1,ibufdim)
                   write(bou(nou(1),1),'(''need, have '',2i11)')
     .             need,nwork
                   call termn8(myid,-1,ibufdim,nbuf,bou,nou)
                end if
                call intrbc(w(lq),jdim,kdim,idim,nbl,ldim,maxbl,
     .                      iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                      iiig,jjig,kkig,qb,w(lqj0),w(lqk0),
     .                      w(lqi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                      bou,nbuf,ibufdim,0)
c               turbulence quantities
                if(iviscg(nbl,1).ge.2 .or. iviscg(nbl,2).ge.2 .or.
     .             iviscg(nbl,3).ge.2) then
                   ldim = 1
                   call intrbc(w(lvis),jdim,kdim,idim,nbl,ldim,maxbl,
     .                         iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                         iiig,jjig,kkig,qb,w(lvj0),w(lvk0),
     .                         w(lvi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                         bou,nbuf,ibufdim,0)
                end if
                if(iviscg(nbl,1).ge.4 .or. iviscg(nbl,2).ge.4 .or.
     .             iviscg(nbl,3).ge.4) then
                   ldim = 2
                   call intrbc(w(lxib),jdim,kdim,idim,nbl,ldim,maxbl,
     .                         iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                         iiig,jjig,kkig,qb,w(ltj0),w(ltk0),
     .                         w(lti0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                         bou,nbuf,ibufdim,0)
                end if
            end if
         end if


Why Changed:   Allow qb array to be read from the restart file in order
               to have clean restarts when using "augmented cell-center"
               stencils from PEGSUS


--------------------
--------------------

Number:           82

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    qout.F

After:

               write(bou(nou(1),1),'(''stopping...not enough integer '',
     .                        ''work space for subroutine bc_period'')')

Add:

               nou(1) = min(nou(1)+1,ibufdim)
               write(bou(nou(1),1),'(''have, need = '',2i12)')
     .         iwork,iwk6

Note: identical additions in the memory checks invoked before calling
      subroutines bc_embed, bc_blkint, and bc_patch.

Change: (2 places)

            if (myid.eq.myhost) then
               if (ixwk+jdw*kdw*idw*4-1 .gt. nwork) then
                  write(11,*) 'not enough workspace for plot3d'
                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
               end if
            end if
            call plot3d(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,k1,k2,k3,
     .                  w(lq),w(lqi0),w(lqj0),w(lqk0),w(lx),
     .                  w(ly),w(lz),wk,wk(ibwk),
     .                  w(lblk),wk(ixwk),iflag,w(lvis),iovrlp(nbl),
     .                  nbl,nmap,w(lbcj),w(lbck),w(lbci),
     .                  w(lvj0),w(lvk0),w(lvi0),ifunc,n,jdw,kdw,idw,
     .                  nplots,jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                  jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                  maxxe,nblk,nbli,limblk,isva,nblon,mxbli,
     .                  thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                  mblk2nd,inpl3d,nblock,nblkpt)

To:

            nroom = nwork - (ixwk+jdw*kdw*idw*4-1)
            if (nroom .lt. 0.) then
               if (myid.eq.myhost) then
                  write(11,'('' not enough memory for plot3d'')')
                  write(11,'('' have, need = '',2i12)') nwork,
     .            nwork-nroom
                  write(11,'('' not writing out plot3d files'')')
               end if
            else
               call plot3d(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,k1,k2,k3,
     .                     w(lq),w(lqi0),w(lqj0),w(lqk0),w(lx),
     .                     w(ly),w(lz),wk,wk(ibwk),
     .                     w(lblk),wk(ixwk),iflag,w(lvis),iovrlp(nbl),
     .                     nbl,nmap,w(lbcj),w(lbck),w(lbci),
     .                     w(lvj0),w(lvk0),w(lvi0),ifunc,n,jdw,kdw,idw,
     .                     nplots,jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                     jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                     maxxe,nblk,nbli,limblk,isva,nblon,mxbli,
     .                     thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                     mblk2nd,inpl3d,nblock,nblkpt)
            end if

Change: (2 places)

            if (myid.eq.myhost) then
               if (ixwk+jdw*kdw*idw*4-1 .gt. nwork) then
                  write(11,*) 'not enough workspace for plot3c'
                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
               end if
            end if
            call plot3c(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,k1,k2,k3,
     .                  w(lq),w(lqi0),w(lqj0),w(lqk0),w(lx),w(ly),
     .                  w(lz),wk,wk(ibwk),w(lblk),wk(ixwk),
     .                  iflag,w(lvis),w(lvi0),w(lvj0),w(lvk0),
     .                  iovrlp(nbl),nbl,nmap,w(lsnk0),ifunc,n,
     .                  jdw,kdw,idw,
     .                  nplots,jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                  jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                  maxxe,nblk,nbli,limblk,isva,nblon,mxbli,
     .                  thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                  mblk2nd,inpl3d,nblock,nblkpt,ip3dsurf)

To:

            nroom = nwork - (ixwk+jdw*kdw*idw*4-1)
            if (nroom .lt. 0.) then
               if (myid.eq.myhost) then
                  write(11,'('' not enough memory for plot3c'')')
                  write(11,'('' have, need = '',2i12)') nwork,
     .            nwork-nroom
                  write(11,'('' not writing out plot3d files'')')
               end if
            else
               call plot3c(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,k1,k2,k3,
     .                     w(lq),w(lqi0),w(lqj0),w(lqk0),w(lx),w(ly),
     .                     w(lz),wk,wk(ibwk),w(lblk),wk(ixwk),
     .                     iflag,w(lvis),w(lvi0),w(lvj0),w(lvk0),
     .                     iovrlp(nbl),nbl,nmap,w(lsnk0),ifunc,n,
     .                     jdw,kdw,idw,
     .                     nplots,jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                     jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                     maxxe,nblk,nbli,limblk,isva,nblon,mxbli,
     .                     thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                     mblk2nd,inpl3d,nblock,nblkpt,ip3dsurf)
            end if


Change: (2 places)

                     if (myid.eq.myhost) then
                        write(11,'('' not enough memory for plot3t'')')
                        write(11,'('' need='',i12)') nroom
                        write(11,'('' not writing out turb info'')')
                     end if

To:

                     if (myid.eq.myhost) then
                        write(11,'('' not enough memory for plot3t'')')
                        write(11,'('' have, need = '',2i12)') nwork,
     .                  nwork-nroom
                        write(11,'('' not writing out plot3d files'')')
                     end if

After:

      if (nbl.gt.nblock .or. nbl.le. 0) go to 70

Add:

c
      if (iblnkfr .eq. 0) then
c
c        temporarily set blank values at fringe points (not holes)
c        to 1 for plotting purposes (helps reduce gaps in plots)
c
         call lead(nbl,lw,lw2,maxbl)
         call blnkfr(nbl,iibg,kkbg,jjbg,ibpntsg,lbg,iitot,w(lblk),
     .               jdim,kdim,idim,maxbl,1.)
      end if
c

Before:

   70 continue

Add:

c
      if (iblnkfr .eq. 0) then
c
c        reset blank values at fringe points to 0.
c
         call blnkfr(nbl,iibg,kkbg,jjbg,ibpntsg,lbg,iitot,w(lblk),
     .               jdim,kdim,idim,maxbl,0.)
      end if
c


Why Changed:   Change the plain "not enough memory" statements to include
               a measure of the shortage; the calls to the plot3d/c/t 
               routines now all defer writing to the plot3d output files
               if there is not enough memory. Also add the ability to
               not blank out fringe points in overset-grid cases.

--------------------
--------------------

Number:           83

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    resp.F

Change:

               write(11,2060)nbl1,real(resmx(nbl1)),jmx(nbl1),kmx(nbl1),
     .         imx(nbl1)
            else
               write(11,2080)nbl1,real(resmx(nbl1)),jmx(nbl1),kmx(nbl1),
     .         imx(nbl1)

To:

               write(11,2060)nbl1,igrid,real(resmx(nbl1)),jmx(nbl1),
     .         kmx(nbl1),imx(nbl1)
            else
               write(11,2080)nbl1,igrid,real(resmx(nbl1)),jmx(nbl1),
     .         kmx(nbl1),imx(nbl1)

Change:

                  write(11,3000)nbl1,real(vormax(nbl1)),jvmax(nbl1),
     .            kvmax(nbl1),ivmax(nbl1)
               else
                  write(11,3020)nbl1,real(vormax(nbl1)),jvmax(nbl1),
     .            kvmax(nbl1),ivmax(nbl1)

To:

                  write(11,3000)nbl1,igrid,real(vormax(nbl1)),
     .            jvmax(nbl1),kvmax(nbl1),ivmax(nbl1)
               else
                  write(11,3020)nbl1,igrid,real(vormax(nbl1)),
     .            jvmax(nbl1),kvmax(nbl1),ivmax(nbl1)

Change:

 2060 format(/1x,27hmaximum residual on block  ,i3,4h is ,e12.5,
     .       12h at j,k,i = ,i3,1h,,i3,1h,,i3,1h.)
 2080 format(1x,27hmaximum residual on block  ,i3,4h is ,e12.5,
     .       12h at j,k,i = ,i3,1h,,i3,1h,,i3,1h.)
 3000 format(/1x,27hmaximum vorticity on block ,i3,4h is ,e12.5,
     .       12h at j,k,i = ,i3,1h,,i3,1h,,i3,1h.)
 3020 format(1x,27hmaximum vorticity on block ,i3,4h is ,e12.5,
     .       12h at j,k,i = ,i3,1h,,i3,1h,,i3,1h.)

To:

 2060 format(/1x,23hmax residual on block  ,i3,7h (grid ,i3,
     .       5h) is ,e12.5,12h at j,k,i = ,i3,1h,,i3,1h,,i3,1h.)
 2080 format(1x,23hmax residual on block  ,i3,7h (grid ,i3,
     .       5h) is ,e12.5,12h at j,k,i = ,i3,1h,,i3,1h,,i3,1h.)
 3000 format(/1x,23hmax vorticity on block ,i3,7h (grid ,i3,
     .       5h) is ,e12.5,12h at j,k,i = ,i3,1h,,i3,1h,,i3,1h.)
 3020 format(1x,23hmax vorticity on block ,i3,7h (grid ,i3,
     .       5h) is ,e12.5,12h at j,k,i = ,i3,1h,,i3,1h,,i3,1h.)


Why Changed:   Add the corresponding grid number to the block number
               information when writing max residual and vorticity.
               This makes it easier to relate the information to the
               input grid, especially for large numbers of grid zones.

--------------------
--------------------

Number:           84

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    cgnstools.F

In subroutine getntr, add:

      character*32 name2

In subroutine getntr, change:

      call cg_convergence_read_f(ntr,'',ier)   

To:

      call cg_convergence_read_f(ntr,name2,ier)

In subroutine readhist, change:

      character*32 name(numnames)

To:

      character*32 name(numnames),name2

In subroutine readhist, change:

      call cg_convergence_read_f(ntr,'',ier)

To:

      call cg_convergence_read_f(ntr,name2,ier)


In subroutines getntr, ropencgns, and wopencgns, change:

      character*60 cgnsdesired

To:

      character*80 cgnsdesired

(also change the comments in these routines under "INPUT")

Why Changed:   these bugs lead to unpredictable behavior when using the CGNS
               option for some cases.


--------------------
--------------------

Number:           85

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    bcchk.F

Change:

      subroutine bcchk(idim,jdim,kdim,q,qi0,qj0,qk0,blank,ibcflg,nbl,
     .                 nou,bou,nbuf,ibufdim,myid,istop)

To:

      subroutine bcchk(idim,jdim,kdim,q,qi0,qj0,qk0,blank,ibcflg,nbl,
     .                 nou,bou,nbuf,ibufdim,myid,istop,igridg,maxbl)


Change:

      dimension blank(jdim,kdim,idim)

To:

      dimension blank(jdim,kdim,idim),igridg(maxbl)

Change:

         write(bou(nou(1),1),15) nbl,k,i,real(qj0(k,i,1,1)),
     .                           real(qj0(k,i,5,1))

To:

         write(bou(nou(1),1),15) nbl,igridg(nbl),k,i,real(qj0(k,i,1,1)),
     .                           real(qj0(k,i,5,1))

NOTE: there are 5 additional statements similar to the one above that must
      be changed in a similar manner (one statement for each of the
      6 block faces)

Change:

   15 format(6h block,i4,25h  on j=1 boundary at k,i=,2i5,
     .15h qj0(1),qj0(5)=,2e12.5)

To:

   15 format(6h block,i4,7h (grid ,i4,1h),25h  on j=1 boundary at k,i=,
     .2i5,15h qj0(1),qj0(5)=,2e12.5)


NOTE: there are 5 additional statements similar to the one above that must
      be changed in a similar manner (one statement for each of the
      6 block faces)


Why Changed: To provide the grid number in addition to the black number for
             easier interpretation of the error messages from bcchk.

--------------------
--------------------

Number:           86

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    bc.F

Change:

         call bcchk(idim,jdim,kdim,w(lq),w(lqi0),w(lqj0),w(lqk0),
     .              w(lblk),ibcflg,nbl,nou,bou,nbuf,ibufdim,myid,istop)

To:

         call bcchk(idim,jdim,kdim,w(lq),w(lqi0),w(lqj0),w(lqk0),
     .              w(lblk),ibcflg,nbl,nou,bou,nbuf,ibufdim,myid,istop,
     .              igridg,maxbl)

Why Changed: To provide the grid number in addition to the black number for
             easier interpretation of the error messages from bcchk.


--------------------
--------------------

Number:           87

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

Change: (3 places)

            call bcchk(idim,jdim,kdim,w(lq),w(lqi0),w(lqj0),w(lqk0),
     .      w(lblk),ibcflg,nbl,nou,bou,nbuf,ibufdim,myid,istop)

To: (3 places)

            call bcchk(idim,jdim,kdim,w(lq),w(lqi0),w(lqj0),w(lqk0),
     .      w(lblk),ibcflg,nbl,nou,bou,nbuf,ibufdim,myid,istop,
     .      igridg,maxbl)


Why Changed: To provide the grid number in addition to the black number for
             easier interpretation of the error messages from bcchk.


--------------------
--------------------


Number:           88

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    trnsurf.F

Change:

      subroutine trnsurf(jdim,kdim,idim,x,y,z,deltj,deltk,delti,nbl,
     .                   idef,xorg,yorg,zorg,utran,vtran,wtran,
     .                   rfreqt,ici,icf,jci,jcf,kci,kcf,time,nou,bou,
     .                   nbuf,ibufdim,myid,wkj,wkk,wki)

To:

      subroutine trnsurf(jdim,kdim,idim,x,y,z,deltj,deltk,delti,nbl,
     .                   idef,xorg,yorg,zorg,utran,vtran,wtran,
     .                   rfreqt,ici,icf,jci,jcf,kci,kcf,time,nou,bou,
     .                   nbuf,ibufdim,myid,wkj,wkk,wki,xorg0,yorg0,
     .                   zorg0)

Change:

      xnew = utran*ft
      ynew = vtran*ft
      znew = wtran*ft

To:

      xnew = utran*ft + xorg0
      ynew = vtran*ft + yorg0
      znew = wtran*ft + zorg0

Change:

      xorg = xnew
      yorg = ynew
      zorg = znew

To:

      xorg = xorg+dx
      yorg = yorg+dy
      zorg = zorg+dz

Why Changed: Original code only valid for xorg0=yorg0=zorg0=0, which were the
             only values ever used. To add coupling to deforming rotation, need
             to allow nonzero values. The last of the changes above is purely
             cosmetic (i.e. actually changes nothing) but is done to make trnsurf
             (deforming translation) more closely resemble trans (rigid translation)

--------------------
--------------------

Number:           89

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Change: (subroutine argument list)

     .                  idfrmseg,iaesurf,maxsegdg)

To:

     .                  idfrmseg,iaesurf,maxsegdg,xorgae0,yorgae0,
     .                  zorgae0,icouple)

Before:

      dimension icsi(maxbl,maxsegdg),icsf(maxbl,maxsegdg),

Add:

      dimension xorgae0(maxbl,maxsegdg),yorgae0(maxbl,maxsegdg),
     .          zorgae0(maxbl,maxsegdg),icouple(maxbl,maxsegdg)

After:

            xorgae(nbl,iseg)   = 0.
            yorgae(nbl,iseg)   = 0.
            zorgae(nbl,iseg)   = 0.

Add:

            xorgae0(nbl,iseg)  = 0.
            yorgae0(nbl,iseg)  = 0.
            zorgae0(nbl,iseg)  = 0.
            icouple(nbl,iseg)  = 0

After:

                  xorgae(nbl,iseg)   = xorgae(nbl-1,iseg)
                  yorgae(nbl,iseg)   = yorgae(nbl-1,iseg)
                  zorgae(nbl,iseg)   = zorgae(nbl-1,iseg)

Add:

                  xorgae0(nbl,iseg)  = xorgae0(nbl-1,iseg)
                  yorgae0(nbl,iseg)  = yorgae0(nbl-1,iseg)
                  zorgae0(nbl,iseg)  = zorgae0(nbl-1,iseg)
                  icouple(nbl,iseg)  = icouple(nbl-1,iseg)

After:

                  xorgae(nbl,iseg)  = origx
                  yorgae(nbl,iseg)  = origy
                  zorgae(nbl,iseg)  = origz

Add:

                  xorgae0(nbl,iseg) = origx
                  yorgae0(nbl,iseg) = origy
                  zorgae0(nbl,iseg) = origz

After:

                  utrnsae(nbl,iseg) = omgx
                  vtrnsae(nbl,iseg) = omgy
                  wtrnsae(nbl,iseg) = omgz

Add:

                  xorgae(nbl,iseg)  = origx
                  yorgae(nbl,iseg)  = origy
                  zorgae(nbl,iseg)  = origz
                  xorgae0(nbl,iseg) = origx
                  yorgae0(nbl,iseg) = origy
                  zorgae0(nbl,iseg) = origz

After:

                     xorgae(nbl,iseg)   = xorgae(nbl-1,iseg)
                     yorgae(nbl,iseg)   = yorgae(nbl-1,iseg)
                     zorgae(nbl,iseg)   = zorgae(nbl-1,iseg)

Add:

                     xorgae0(nbl,iseg)  = xorgae0(nbl-1,iseg)
                     yorgae0(nbl,iseg)  = yorgae0(nbl-1,iseg)
                     zorgae0(nbl,iseg)  = zorgae0(nbl-1,iseg)

After:

                     xorgae(nbl,iseg)  = origx
                     yorgae(nbl,iseg)  = origy
                     zorgae(nbl,iseg)  = origz

Add:

                     xorgae(nbl,iseg)  = origx
                     yorgae(nbl,iseg)  = origy
                     zorgae(nbl,iseg)  = origz
                     xorgae0(nbl,iseg) = origx
                     yorgae0(nbl,iseg) = origy
                     zorgae0(nbl,iseg) = origz

After:

                        xorgae(nbl,iseg)   = xorgae(nbl-1,iseg)
                        yorgae(nbl,iseg)   = yorgae(nbl-1,iseg)
                        zorgae(nbl,iseg)   = zorgae(nbl-1,iseg)

Add:

                        xorgae0(nbl,iseg)  = xorgae0(nbl-1,iseg)
                        yorgae0(nbl,iseg)  = yorgae0(nbl-1,iseg)
                        zorgae0(nbl,iseg)  = zorgae0(nbl-1,iseg)

After:

c        for all blocks that have not yet been identified as
c        deforming, set idefrm flag to 999...indicating the mesh
c        deforms, but only through interaction with other blocks
c        containing moving solid surfaces. also set index ranges
c        to include entire block
c
         do nbl=1,nblock
            if (idefrm(nbl).eq.0) then
               idefrm(nbl)  = 999
               nsegdfrm(nbl) = 1
               do iseg=1,nsegdfrm(nbl)
                  icsi(nbl,iseg) = 1
                  icsf(nbl,iseg) = idimg(nbl)
                  jcsi(nbl,iseg) = 1
                  jcsf(nbl,iseg) = jdimg(nbl)
                  kcsi(nbl,iseg) = 1
                  kcsf(nbl,iseg) = kdimg(nbl)
               end do
            end if
         end do

Add:

c
c        multi-mode grid movement data - used to couple rigid and
c        deforming grid motions, or deforming translation plus 
c        deforming rotation.
c
         read(iunit5,*)
         read(iunit5,*)
         read(iunit5,*) ncoupl
         write(iunit11,'('' moving grid data - multi-motion '',
     .                   ''coupling'')')
         write(iunit11,'(''  ncoupl'')')
         if (ncoupl.gt.0) then
            write(iunit11,'(i8)') ncoupl
            if (ncoupl.gt.ngrid) then
               write(iunit11,'('' input error: ncoupl > ngrid'')')
               call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)
            end if
            read(iunit5,*)
            write(iunit11,'(''  slave   master   xorig   yorig'',
     .      ''   zorig'')')
            do nn=1,ncoupl
               read(iunit5,*) igslav,igmast,xorg,yorg,zorg
               write(iunit11,'(i8,i9,3f9.4)') igslav,igmast,xorg,
     .         yorg,zorg
               nblslav = nblg(igslav)
               if (igmast.gt.0) then
                  nblmast = nblg(igmast)
                  xorig(nblmast) = xorg
                  yorig(nblmast) = yorg
                  zorig(nblmast) = zorg
                  xorig0(nblmast) = xorg
                  yorig0(nblmast) = yorg
                  zorig0(nblmast) = zorg
               else
                  nblmast = 0
               end if
               ncg = ncgg(igslav)
               do iseg=1,nsegdfrm(nblslav)
                  icouple(nblslav,iseg) = nblmast
               end do
               if (ncg.gt.0) then
                   do n=1,ncg
                      nblslav = nblslav + 1
                      if (nblmast.gt.0) then
                         nblmast = nblmast + 1 
                         xorig(nblmast) = xorig(nblmast-1)
                         yorig(nblmast) = yorig(nblmast-1)
                         zorig(nblmast) = zorig(nblmast-1)
                         xorig0(nblmast) = xorig0(nblmast-1)
                         yorig0(nblmast) = yorig0(nblmast-1)
                         zorig0(nblmast) = zorig0(nblmast-1)
                      end if
                      do iseg=1,nsegdfrm(nblslav)
                         icouple(nblslav,iseg) = nblmast
                      end do
                   end do
               end if
            end do
         else if (ncoupl.lt.0) then
            read(iunit5,*) igslav,igmast,xorg,yorg,zorg
            ncoupl = ngrid
            write(iunit11,'(i8)') ncoupl
            read(iunit5,*)
            write(iunit11,'(''  slave   master   xorig   yorig'',
     .      ''   zorig'')')
            do nn=1,ncoupl
               igslav = nn
               write(iunit11,'(i8,i9,3f9.4)') igslav,igmast,xorg,
     .         yorg,zorg
               nblslav = nblg(igslav)
               if (igmast.gt.0) then
                  nblmast = nblg(igmast)
                  xorig(nblmast) = xorg
                  yorig(nblmast) = yorg
                  zorig(nblmast) = zorg
                  xorig0(nblmast) = xorg
                  yorig0(nblmast) = yorg
                  zorig0(nblmast) = zorg
               else
                  nblmast = 0
               end if
               ncg = ncgg(igslav)
               do iseg=1,nsegdfrm(nblslav)
                  icouple(nblslav,iseg) = nblmast
               end do
               if (ncg.gt.0) then
                   do n=1,ncg
                      nblslav = nblslav + 1
                      if (nblmast.gt.0) then
                         nblmast = nblmast + 1 
                         xorig(nblmast) = xorig(nblmast-1)
                         yorig(nblmast) = yorig(nblmast-1)
                         zorig(nblmast) = zorig(nblmast-1)
                         xorig0(nblmast) = xorig0(nblmast-1)
                         yorig0(nblmast) = yorig0(nblmast-1)
                         zorig0(nblmast) = zorig0(nblmast-1)
                      end if
                      do iseg=1,nsegdfrm(nblslav)
                         icouple(nblslav,iseg) = nblmast
                      end do
                   end do
               end if
            end do
         else
            write(iunit11,'(i8)') ncoupl
            read(iunit5,*)
            write(iunit11,'(''  slave   master   xorig   yorig'',
     .      ''   zorig'')')
         end if

Why Changed: Add xorgae0,yorgae0,zorgae0 to give reference for origin
             at t=0 in deforming mesh case (as is done for rigid motion).
             Add mechanism (via icouple) to couple forced mesh movement
             with deformation to forced rigid mesh movement, and also 
             to allow forced translation with deformation and forced
             rotation with deformation to be done concurrantly.

--------------------
--------------------

Number:           90

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global0.F

After:

c        offbody/multiblock mesh deformation data
         call echoinp(iunit5,iunit11,1)
         call echoinp(iunit5,iunit11,1)
         read(iunit5,*) nskip,realval(1),idum1,idum2
         write(iunit11,'(i8,f9.6,2i9)') nskip,realval(1),idum1,idum2
         call echoinp(iunit5,iunit11,0)
         call echoinp(iunit5,iunit11,1)
         if (abs(nskip).gt.0) then
            do ng = 1,abs(nskip)
               call echoinp(iunit5,iunit11,1)
            end do
         end if

Add:

c
c        multi-motion coupling
         call echoinp(iunit5,iunit11,1)
         call echoinp(iunit5,iunit11,1)
         read(iunit5,*) ncoupl
         write(iunit11,'(i8,f9.6,2i9)') ncoupl
         call echoinp(iunit5,iunit11,0)
         call echoinp(iunit5,iunit11,1)
         if (abs(ncoupl).gt.0) then
            do ng = 1,abs(ncoupl)
               call echoinp(iunit5,iunit11,1)
            end do
         end if


Why Changed: Add read of the new coupling section (see preceeding change)

--------------------
--------------------

Number:           91

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F

Change:

            if (real(time).eq.0. .or. abs(ita).eq.1) then

To:

            if (real(time).le.dt .or. abs(ita).eq.1) then

Why Changed: Can't actually do 3 point backward difference in time until 2 
             previous time steps are available (t=0 and t=dt)

--------------------
--------------------

Number:           92

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F

Change:

c
c              first order backward derivatives
c
               fact = 1./dt
               do i=1,idim
                  do k=1,kdim
                     do j=1,jdim
c                       vel(j,k,i,1) = fact*dx(j,k,i)
c                       vel(j,k,i,2) = fact*dy(j,k,i)
c                       vel(j,k,i,3) = fact*dz(j,k,i)
                        vel(j,k,i,1) = fact*(xxorg(j,k,i)+dx(j,k,i)
     .                               - x(j,k,i))
                        vel(j,k,i,2) = fact*(yyorg(j,k,i)+dy(j,k,i)
     .                               - y(j,k,i))
                        vel(j,k,i,3) = fact*(zzorg(j,k,i)+dz(j,k,i)
     .                               - z(j,k,i))
                     end do
                  end do
               end do

To:

c              first order backward derivatives
c
               fact = 1./dt
               do i=1,idim
                  do k=1,kdim
                     do j=1,jdim
                        vel(j,k,i,1) = fact*((dx(j,k,i)+x(j,k,i))
     .                               - xxorg(j,k,i))
                        vel(j,k,i,2) = fact*((dy(j,k,i)+y(j,k,i))
     .                               - yyorg(j,k,i))
                        vel(j,k,i,3) = fact*((dz(j,k,i)+z(j,k,i))
     .                               - zzorg(j,k,i))
                     end do
                  end do
               end do

Change:

c
c              second order backward derivatives
c
               fact = 1./(2.*dt)
               do i=1,idim
                  do k=1,kdim
                     do j=1,jdim
c                       vel(j,k,i,1) = fact*(3.*dx(j,k,i)
c    .                               - (x(j,k,i)-xold(j,k,i)))
c                       vel(j,k,i,2) = fact*(3.*dy(j,k,i)
c    .                               - (y(j,k,i)-yold(j,k,i)))
c                       vel(j,k,i,3) = fact*(3.*dz(j,k,i)
c    .                               - (z(j,k,i)-zold(j,k,i)))
                        vel(j,k,i,1) = fact*(3.*(dx(j,k,i)+xxorg(j,k,i))
     .                               - 4*x(j,k,i)+xold(j,k,i))
                        vel(j,k,i,2) = fact*(3.*(dy(j,k,i)+yyorg(j,k,i))
     .                               - 4*y(j,k,i)+yold(j,k,i))
                        vel(j,k,i,3) = fact*(3.*(dz(j,k,i)+zzorg(j,k,i))
     .                               - 4*z(j,k,i)+zold(j,k,i))
                     end do
                  end do
               end do

To:

c
c              second order backward derivatives
c
               fact = 1./(2.*dt)
               do i=1,idim
                  do k=1,kdim
                     do j=1,jdim
                        vel(j,k,i,1) = fact*(3.*(dx(j,k,i)+x(j,k,i))
     .                               - 4*xxorg(j,k,i)+xold(j,k,i))
                        vel(j,k,i,2) = fact*(3.*(dy(j,k,i)+y(j,k,i))
     .                               - 4*yyorg(j,k,i)+yold(j,k,i))
                        vel(j,k,i,3) = fact*(3.*(dz(j,k,i)+z(j,k,i))
     .                               - 4*zzorg(j,k,i)+zold(j,k,i))
                     end do
                  end do
               end do

Change:

c
c        for second order case, store current--->old before
c        updating grid
c
         if (abs(ita).gt.1) then
            do i=1,idim
               do k=1,kdim
                  do j=1,jdim
                     xold(j,k,i) = x(j,k,i)
                     yold(j,k,i) = y(j,k,i)
                     zold(j,k,i) = z(j,k,i)
                  end do
               end do
            end do
         end if
c
c        add deltas to the original mesh to get the new one
c
         do i=1,idim
            do k=1,kdim
               do j=1,jdim
                  x(j,k,i) = xxorg(j,k,i) + dx(j,k,i)
                  y(j,k,i) = yyorg(j,k,i) + dy(j,k,i)
                  z(j,k,i) = zzorg(j,k,i) + dz(j,k,i)
               end do
            end do
         end do

To:

c
c        for second order case, store previous--->old before
c        updating grid
c
         if (abs(ita).gt.1) then
            do i=1,idim
               do k=1,kdim
                  do j=1,jdim
                     xold(j,k,i) = xxorg(j,k,i)
                     yold(j,k,i) = yyorg(j,k,i)
                     zold(j,k,i) = zzorg(j,k,i)
                  end do
               end do
            end do
         end if
c
c        add deltas to the current mesh to get the new one
c
         do i=1,idim
            do k=1,kdim
               do j=1,jdim
                  x(j,k,i) = x(j,k,i) + dx(j,k,i)
                  y(j,k,i) = y(j,k,i) + dy(j,k,i)
                  z(j,k,i) = z(j,k,i) + dz(j,k,i)
               end do
            end do
         end do

Why Changed: Older mesh deformation updates were added to the original grid;
             in order to allow a combination of rigid and deforming meshes
             this has been changed to updating the mesh from the previous
             time step. 

--------------------
--------------------

Number:           93

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    rsmooth.F

Change:

         write(bou(nou(1),1),'(''smoothing residuals - eps='',3e12.4)')
     .   smoopi,smoopj,smoopk

To:

         write(bou(nou(1),1),'(''smoothing residuals - eps='',3e12.4)')
     .   real(smoopi),real(smoopj),real(smoopk)

Why Changed: Only the real part should be output; otherwise, code may bomb if 
             residual smoothing is used in the complex case.


--------------------
--------------------

Number:           94

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    pointers.F

Change:

c
c........intermediate grid velocity for blocks undergoing BOTH
c        rigid motion and deforming motion
c
         lw(54,nbl) = lw(53,nbl) + ns
         ns = 0
         iuns2 = max(itrans(nbl),irotat(nbl))
         if (iuns2.gt.0 .and. idefrm(nbl).gt.0) ns = jmkmim*3

To:

c
c........intermediate grid velocity for blocks undergoing BOTH
c        rigid motion and deforming motion
c        Note: this data no longer stored
c
         lw(54,nbl) = lw(53,nbl) + ns
         ns = 0


Why Changed:   It turned out not to be practical to use analytic velocities
               for the rigid part of the motion and finite-difference velocities
               for the deforming part of the motion when rigid and deforming 
               motions where combined. The current approach is to simply 
               use finite differences for combination motions. 


--------------------
--------------------

Number:           95

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Remove:

          < 0  will trigger a switch to a mode in which Cl is
c               specified and alpha is varied to meet the
c               target Cl (sref will be reset to abs(sref))
c          >=0  standard mode; specify alpha and determine Cl

After:

      write(iunit11,22) real(sref),real(cref),real(bref),real(xmc),
     .                  real(ymc),real(zmc)

Add:

      if (real(sref).lt.0.) then
         write (iunit11,'(''WARNING: input sref<0, taking abs(sref)'')')
         write (iunit11,'(''  Note: fixed Cl option is no longer '',
     .                    ''triggered with sref<0...use keyword '',
     .                    ''input'')')
      end if

Why Changed:   To prevent erroneous results if sref<0 is used...in older
               versions (or version 6), sref<0 was used to trigger the
               fixed Cl option...now that is triggered via keyword input.


--------------------
--------------------

Number:           96

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    cfl3d.F

After:

      dimension utrnsae(maxbl,maxsegdg),vtrnsae(maxbl,maxsegdg),
     .          wtrnsae(maxbl,maxsegdg),omgxae(maxbl,maxsegdg),
     .          omgyae(maxbl,maxsegdg),omgzae(maxbl,maxsegdg),
     .          xorgae(maxbl,maxsegdg),yorgae(maxbl,maxsegdg),
     .          zorgae(maxbl,maxsegdg),thtxae(maxbl,maxsegdg),
     .          thtyae(maxbl,maxsegdg),thtzae(maxbl,maxsegdg),
     .          rfrqtae(maxbl,maxsegdg),rfrqrae(maxbl,maxsegdg)

Add:

      dimension xorgae0(maxbl,maxsegdg),yorgae0(maxbl,maxsegdg),
     .          zorgae0(maxbl,maxsegdg),icouple(maxbl,maxsegdg)

After:

      pointer (ip_aesrfdat,aesrfdat),(ip_utrnsae,utrnsae),
     .        (ip_vtrnsae,vtrnsae),(ip_wtrnsae,wtrnsae),
     .        (ip_omgxae,omgxae),(ip_omgyae,omgyae),(ip_omgzae,omgzae),
     .        (ip_xorgae,xorgae),(ip_yorgae,yorgae),(ip_zorgae,zorgae),

Add:

     .        (ip_xorgae0,xorgae0),(ip_yorgae0,yorgae0),
     .        (ip_zorgae0,zorgae0),(ip_icouple,icouple),

After:

      call umalloc(ip_xorgae,maxbl*maxsegdg,0,icall,memuse)
      call umalloc(ip_yorgae,maxbl*maxsegdg,0,icall,memuse)
      call umalloc(ip_zorgae,maxbl*maxsegdg,0,icall,memuse)

Add:

      call umalloc(ip_xorgae0,maxbl*maxsegdg,0,icall,memuse)
      call umalloc(ip_yorgae0,maxbl*maxsegdg,0,icall,memuse)
      call umalloc(ip_zorgae0,maxbl*maxsegdg,0,icall,memuse)
      call umalloc(ip_icouple,maxbl*maxsegdg,1,icall,memuse)

Change: (in argument list of call to mgbl)

     .          nmaster,aehist,timekeep)

To:

     .          nmaster,aehist,timekeep,xorgae0,yorgae0,zorgae0,
     .          icouple)

After:

         call ufree(ip_xorgae)
         call ufree(ip_yorgae)
         call ufree(ip_zorgae)

Add:

         call ufree(ip_xorgae0)
         call ufree(ip_yorgae0)
         call ufree(ip_zorgae0)
         call ufree(ip_icouple)

Why Changed:   To accomodate new arrays for xorgae0,yorgae0,zorgae0, 
               and icouple (see change numbers 88-90)

--------------------
--------------------

Number:           97

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgbl.F

Change: (in argument list of soubroutine mgbl)

     .                maxsegdg,nmaster,aehist,timekeep)

To:

     .                maxsegdg,nmaster,aehist,timekeep,xorgae0,yorgae0,
     .                zorgae0,icouple)

After:

      dimension utrnsae(maxbl,maxsegdg),vtrnsae(maxbl,maxsegdg),
     .          wtrnsae(maxbl,maxsegdg),omgxae(maxbl,maxsegdg),
     .          omgyae(maxbl,maxsegdg),omgzae(maxbl,maxsegdg),
     .          xorgae(maxbl,maxsegdg),yorgae(maxbl,maxsegdg),
     .          zorgae(maxbl,maxsegdg),thtxae(maxbl,maxsegdg),
     .          thtyae(maxbl,maxsegdg),thtzae(maxbl,maxsegdg),
     .          rfrqtae(maxbl,maxsegdg),rfrqrae(maxbl,maxsegdg)

Add:

      dimension xorgae0(maxbl,maxsegdg),yorgae0(maxbl,maxsegdg),
     .          zorgae0(maxbl,maxsegdg),icouple(maxbl,maxsegdg)

Change: (in call to subroutine global)

     .               idfrmseg,iaesurf,maxsegdg)

To:

     .               idfrmseg,iaesurf,maxsegdg,xorgae0,yorgae0,zorgae0,
     .               icouple)

Change: (in call to subroutine trnsfr_vals)

     .                 iaesurf,maxsegdg)

To:

     .                 iaesurf,maxsegdg,xorgae0,yorgae0,zorgae0,
     .                 icouple)

Change: (in call to subroutine setup)

     .           nplot3d,levelg,iadvance,xs,gforcs)

To:

     .           nplot3d,levelg,iadvance,xs,gforcs,xorgae0,yorgae0,
     .           zorgae0,icouple)

Change: (in call to subroutine mgblk)

     .              iaesurf,maxsegdg,nmaster,aehist,timekeep)

To:

     .              iaesurf,maxsegdg,nmaster,aehist,timekeep,xorgae0,
     .              yorgae0,zorgae0,icouple)

Why Changed:   To accomodate new arrays for xorgae0,yorgae0,zorgae0,
               and icouple (see change numbers 88-90)

--------------------
--------------------

Number:           98

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

Change: (in argument list of soubroutine mgblk)

     .                 timekeep)

To:

     .                 timekeep,xorgae0,yorgae0,zorgae0,icouple)

After:

      dimension utrnsae(maxbl,maxsegdg),vtrnsae(maxbl,maxsegdg),
     .          wtrnsae(maxbl,maxsegdg),omgxae(maxbl,maxsegdg),
     .          omgyae(maxbl,maxsegdg),omgzae(maxbl,maxsegdg),
     .          xorgae(maxbl,maxsegdg),yorgae(maxbl,maxsegdg),
     .          zorgae(maxbl,maxsegdg),thtxae(maxbl,maxsegdg),
     .          thtyae(maxbl,maxsegdg),thtzae(maxbl,maxsegdg),
     .          rfrqtae(maxbl,maxsegdg),rfrqrae(maxbl,maxsegdg)

Add:

      dimension xorgae0(maxbl,maxsegdg),yorgae0(maxbl,maxsegdg),
     .          zorgae0(maxbl,maxsegdg),icouple(maxbl,maxsegdg)


Remove:

c     currently possible to output initial solution for either
c     stationary grids (iunst=0) or  rigid-grid motion (iunst=1),
c     but not deforming-grid motion (iunst>1)

Change:

      if (movie.lt.0 .and. iunst.le.1) then

To:

      if (movie.lt.0) then

After:

c
c     update grid position, speed, and dynamic patch interpolation
c     coefficients, if needed
c
      if (iunst .gt. 0) then

Add:

c
c        store off old grid position for 2nd order (in time) update
c        of deforming grid speeds
c
         do nbl = 1,nblock
            if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0 .and.
     .         (levelg(nbl).ge.lglobal .and.
     .         levelg(nbl).le.levelt(iseq))) then
               if (idefrm(nbl) .ne. 0) then
                  call lead(nbl,lw,lw2,maxbl)
                  mdim=jdim*kdim*idim
                  do lll=1,mdim
                     w(lxorg+lll-1) = w(lx+lll-1)
                     w(lyorg+lll-1) = w(ly+lll-1)
                     w(lzorg+lll-1) = w(lz+lll-1)
                  end do
               end if
            end if
         end do

Change:

         if (iunst .gt. 1) then
            iwk1 = maxbl

To:

         if (iunst .gt. 1) then
            iwk1 = 2*maxbl

Change: (in call to subroutine updatedg)

     .                    iaesurf,maxsegdg,iwk,nmaster,nt)

To:

     .                    iaesurf,maxsegdg,iwk,nmaster,nt,xorig,
     .                    yorig,zorig,xorgae0,yorgae0,zorgae0,icouple,
     .                    iwk(maxbl+1),nnodes)


Why Changed:   To accomodate new arrays for xorgae0,yorgae0,zorgae0,
               and icouple (see change numbers 88-90)

--------------------
--------------------

Number:           99

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    rrestg.F

After:

               xorig(nbl)    = xorig1
               yorig(nbl)    = yorig1
               zorig(nbl)    = zorig1
               thetax(nbl)   = thetax1

Add:

               thetay(nbl)   = thetay1

Why Changed:   Original coding did not update thetay upon restart (thetax
               and thetaz were done correctly however). Error lead to
               glitch at restart if rotation about y axis was used.


--------------------
--------------------

Number:          100

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    rrestg.F

Change:

c
c              the restart file is written out at time step n; we need
c              to reconstruct the grid at time step n, and for second
c              order time accurate solutions, we also need the grid
c              at time n-1 (first order does not require the grid at
c              n-1). to minimize the amount of grid data written to
c              the restart file, the following approach is used:
c
c            - for first order time solutions, the restart file
c              contains the grid at n (all that is needed). the
c              boundary displacements at time n are also output,
c              though they are not needed.
c
c            - for second order time solutions, the restart file
c              contains the full grid at n-1, plus the boundary
c              displacements at time n. The mesh deformation scheme
c              then uses the grid at time n-1 and the displacements
c              at time n to reconstruct the grid at time n, just like
c              a standard update. this approach saves roughly the
c              size of one grid in the restart file (as opposed to
c              storing the full grids at both n and n-1 in the
c              restart file).
c
c              with this approach the restart file always contains
c              the same amount of data regardless of whether first
c              or second order time is used - only the interpretation
c              of whether the full grid xyz data is at t(n) or t(n-1)
c              changes

To:

c
c              the restart file is written out at time step n; we need
c              to reconstruct the grid at time step n, and for second
c              order time accurate solutions, we also need the grid
c              at time n-1 (first order does not require the grid at
c              n-1). However, for the first order case the grid
c              at n is written out twice, so that the restart file
c              always contains the same amount of data.
c

After:

                     read(2) idfrmsdum,utrnsae(nbl,is),
     .                       vtrnsae(nbl,is),wtrnsae(nbl,is),
     .                       omgxae(nbl,is),omgyae(nbl,is),
     .                       omgzae(nbl,is),xorgae(nbl,is),
     .                       yorgae(nbl,is),zorgae(nbl,is),
     .                       thtxae(nbl,is),thtyae(nbl,is),
     .                       thtzae(nbl,is),rfrqtae(nbl,is),
     .                       rfrqrae(nbl,is),icsi(nbl,is),
     .                       icsf(nbl,is),jcsi(nbl,is),jcsf(nbl,is),
     .                       kcsi(nbl,is),kcsf(nbl,is)

Add:

                  if (ita .gt. 1) then
                     read(2) 
     .                    (((xold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                    (((yold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                    (((zold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim)
                  else
                     read(2)
     .                    (((xdum,j=1,jdim),k=1,kdim),i=1,idim),
     .                    (((ydum,j=1,jdim),k=1,kdim),i=1,idim),
     .                    (((zdum,j=1,jdim),k=1,kdim),i=1,idim)
                  end if


After:

                  read(2) (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                    (((y(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                    (((z(j,k,i),j=1,jdim),k=1,kdim),i=1,idim)
c   ***CGNSstart
               else
               write(11,'('' CGNS not implemented for deforming'',
     .          '' grid'')')
               call termn8(myid,-1,ibufdim,nbuf,bou,nou)
               end if
c   ***CGNSend
               end if
#if defined DIST_MPI

Add:

               if (ita .gt. 1) then
                  jki = jdim*kdim*idim
                  if (myid.eq.myhost) then
                     mytag = itag_xold + nbl
                     call MPI_Send (xold, jki, MY_MPI_REAL,
     .                              nd_dest, mytag, mycomm, ierr)
                     mytag = itag_yold + nbl
                     call MPI_Send (yold, jki, MY_MPI_REAL,
     .                              nd_dest, mytag, mycomm, ierr)
                     mytag = itag_zold + nbl
                     call MPI_Send (zold, jki, MY_MPI_REAL,
     .                              nd_dest, mytag, mycomm, ierr)
                  else if (myid.eq.mblk2nd(nbl)) then
                     mytag = itag_xold + nbl
                     call MPI_Recv (xold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, istat, ierr)
                     mytag = itag_yold + nbl
                     call MPI_Recv (yold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, istat, ierr)
                     mytag = itag_zold + nbl
                     call MPI_Recv (zold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, istat, ierr)
                  end if
               end if

Remove:

               if (myid.eq.myhost) then
c   ***CGNSstart
                  if (icgns .ne. 1) then
c   ***CGNSend
                  read(2) ((((deltj(k,i,ll,mm),k=1,kdim),i=1,idim),
     .                        ll=1,3),mm=1,2)
                  read(2) ((((deltk(j,i,ll,mm),j=1,jdim),i=1,idim),
     .                        ll=1,3),mm=1,2)
                  read(2) ((((delti(j,k,ll,mm),j=1,jdim),k=1,kdim),
     .                        ll=1,3),mm=1,2)
c   ***CGNSstart
                  else
                  write(11,'('' CGNS not implemented for deforming'',
     .             '' grid'')')
                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
                  end if
c   ***CGNSend
               end if
#if defined DIST_MPI
               if (myid.eq.myhost) then
                  mytag = itag_deltj + nbl
                  num = 6*kdim*idim
                  call MPI_Send (deltj, num, MY_MPI_REAL,
     .                           nd_dest, mytag, mycomm, ierr)
                  mytag = itag_deltk + nbl
                  num = 6*jdim*idim
                  call MPI_Send (deltk, num, MY_MPI_REAL,
     .                           nd_dest, mytag, mycomm, ierr)
                  mytag = itag_delti + nbl
                  num = 6*jdim*kdim
                  call MPI_Send (delti, num, MY_MPI_REAL,
     .                           nd_dest, mytag, mycomm, ierr)
               else if (myid.eq.mblk2nd(nbl)) then
                  mytag = itag_deltj + nbl
                  num = 6*kdim*idim
                  call MPI_Recv (deltj, num, MY_MPI_REAL,
     .                           myhost, mytag, mycomm, istat, ierr)
                  mytag = itag_deltk + nbl
                  num = 6*jdim*idim
                  call MPI_Recv (deltk, num, MY_MPI_REAL,
     .                           myhost, mytag, mycomm, istat, ierr)
                  mytag = itag_delti + nbl
                  num = 6*jdim*kdim
                  call MPI_Recv (delti, num, MY_MPI_REAL,
     .                           myhost, mytag, mycomm, istat, ierr)
               end if
#endif

Why Changed:   Change of data to restart needed because of change in the
               way deforming mesh deltas are defined: previously, changes
               were measured from the undeformed mesh; they are now 
               measured from the mesh at the previous time step. This is
               done to accomodate rigid and deforming meshes simultaneously.

--------------------
--------------------

Number:          101

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    wrestg.F

Change:

c
c              the restart file is written out at time step n; we need
c              to reconstruct the grid at time step n, and for second
c              order time accurate solutions, we also need the grid
c              at time n-1 (first order does not require the grid at
c              n-1). to minimize the amount of grid data written to
c              the restart file, the following approach is used:
c
c            - for first order time solutions, the restart file
c              contains the grid at n (all that is needed). the
c              boundary displacements at time n are also output,
c              though they are not needed.
c
c            - for second order time solutions, the restart file
c              contains the full grid at n-1, plus the boundary
c              displacements at time n. The mesh deformation scheme
c              then uses the grid at time n-1 and the displacements
c              at time n to reconstruct the grid at time n, just like
c              a standard update. this approach saves roughly the
c              size of one grid in the restart file (as opposed to
c              storing the full grids at both n and n-1 in the
c              restart file).
c
c              with this approach the restart file always contains
c              the same amount of data regardless of whether first
c              or second order time is used - only the interpretation
c              of whether the full grid xyz data is at t(n) or t(n-1)
c              changes

To:

c
c              the restart file is written out at time step n; we need
c              to reconstruct the grid at time step n, and for second
c              order time accurate solutions, we also need the grid
c              at time n-1 (first order does not require the grid at
c              n-1). However, for the first order case the grid
c              at n is written out twice, so that the restart file
c              always contains the same amount of data.
c

Change:

               if (abs(ita).gt.1) then
                  jki = jdim*kdim*idim
                  if (myid.eq.mblk2nd(nbl)) then
                     mytag = itag_xold + nbl
                     call MPI_Send (xold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, ierr)
                     mytag = itag_yold + nbl
                     call MPI_Send (yold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, ierr)
                     mytag = itag_zold + nbl
                     call MPI_Send (zold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, ierr)
                  else if (myid.eq.myhost) then
                     mytag = itag_xold + nbl
                     call MPI_Recv (xold, jki, MY_MPI_REAL,
     .                        nd_srce, mytag, mycomm, istat, ierr)
                     mytag = itag_yold + nbl
                     call MPI_Recv (yold, jki, MY_MPI_REAL,
     .                        nd_srce, mytag, mycomm, istat, ierr)
                     mytag = itag_zold + nbl
                     call MPI_Recv (zold, jki, MY_MPI_REAL,
     .                        nd_srce, mytag, mycomm, istat, ierr)
                  end if
               else

To:

               if (abs(ita).gt.1) then
                  jki = jdim*kdim*idim
                  if (myid.eq.mblk2nd(nbl)) then
                     mytag = itag_xold + nbl
                     call MPI_Send (xold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, ierr)
                     mytag = itag_yold + nbl
                     call MPI_Send (yold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, ierr)
                     mytag = itag_zold + nbl
                     call MPI_Send (zold, jki, MY_MPI_REAL,
     .                              myhost, mytag, mycomm, ierr)
                  else if (myid.eq.myhost) then
                     mytag = itag_xold + nbl
                     call MPI_Recv (xold, jki, MY_MPI_REAL,
     .                        nd_srce, mytag, mycomm, istat, ierr)
                     mytag = itag_yold + nbl
                     call MPI_Recv (yold, jki, MY_MPI_REAL,
     .                        nd_srce, mytag, mycomm, istat, ierr)
                     mytag = itag_zold + nbl
                     call MPI_Recv (zold, jki, MY_MPI_REAL,
     .                        nd_srce, mytag, mycomm, istat, ierr)
                  end if
               end if

Change:

                     call MPI_Recv (z, jki, MY_MPI_REAL,
     .                        nd_srce, mytag, mycomm, istat, ierr)
                  end if

To:

                     call MPI_Recv (z, jki, MY_MPI_REAL,
     .                        nd_srce, mytag, mycomm, istat, ierr)

Change:

                  if (abs(ita).gt.1) then
                  write(2) (((xold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((yold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((zold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim)
                  else
                  write(2) (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((y(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((z(j,k,i),j=1,jdim),k=1,kdim),i=1,idim)
                  end if

To:

c
c                 xold, etc. only needed (and stored) for 2nd order, so
c                 write out x,y,z twice in 1st order case in order to 
c                 simplify restart logic
c
                  if (abs(ita).gt.1) then
                     write(2) 
     .                     (((xold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((yold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((zold(j,k,i),j=1,jdim),k=1,kdim),i=1,idim)
                  else
                     write(2) 
     .                     (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((y(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((z(j,k,i),j=1,jdim),k=1,kdim),i=1,idim)
                  end if
                  write(2) (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((y(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
     .                     (((z(j,k,i),j=1,jdim),k=1,kdim),i=1,idim)

Remove:

#if defined DIST_MPI
               if (myid.eq.mblk2nd(nbl)) then
                  mytag = itag_deltj + nbl
                  num = 6*kdim*idim
                  call MPI_Send (deltj, num, MY_MPI_REAL,
     .                           myhost, mytag, mycomm, ierr)
                  mytag = itag_deltk + nbl
                  num = 6*jdim*idim
                  call MPI_Send (deltk, num, MY_MPI_REAL,
     .                           myhost, mytag, mycomm, ierr)
                  mytag = itag_delti + nbl
                  num = 6*jdim*kdim
                  call MPI_Send (delti, num, MY_MPI_REAL,
     .                           myhost, mytag, mycomm, ierr)
               else if (myid.eq.myhost) then
                  mytag = itag_deltj + nbl
                  num = 6*kdim*idim
                  call MPI_Recv (deltj, num, MY_MPI_REAL,
     .                     nd_srce, mytag, mycomm, istat, ierr)
                  mytag = itag_deltk + nbl
                  num = 6*jdim*idim
                  call MPI_Recv (deltk, num, MY_MPI_REAL,
     .                     nd_srce, mytag, mycomm, istat, ierr)
                  mytag = itag_delti + nbl
                  num = 6*jdim*kdim
                  call MPI_Recv (delti, num, MY_MPI_REAL,
     .                     nd_srce, mytag, mycomm, istat, ierr)
               end if
#endif
               if (myid.eq.myhost) then
    ***CGNSstart
               if (icgns .ne. 1) then
    ***CGNSend
                  write(2) ((((deltj(k,i,ll,mm),k=1,kdim),i=1,idim),
     .                         ll=1,3),mm=1,2)
                  write(2) ((((deltk(j,i,ll,mm),j=1,jdim),i=1,idim),
     .                         ll=1,3),mm=1,2)
                  write(2) ((((delti(j,k,ll,mm),j=1,jdim),k=1,kdim),
     .                         ll=1,3),mm=1,2)
    ***CGNSstart
               else
                  write(11,'('' CGNS not implemented for idef > 0'')')
                  write(11,'('' Deforming info NOT written!'')')
               end if
    ***CGNSend
               end if


Why Changed:   Change of data to restart needed because of change in the
               way deforming mesh deltas are defined: previously, changes
               were measured from the undeformed mesh; they are now 
               measured from the mesh at the previous time step. This is
               done to accomodate rigid and deforming meshes simultaneously.

--------------------
--------------------

Number:          102

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F

Change: (in subroutine argument list)

     .                 iadvance,xs,gforcs)

To:

     .                 iadvance,xs,gforcs,xorgae0,yorgae0,zorgae0,
     .                 icouple)

After:

      dimension utrnsae(maxbl,maxsegdg),vtrnsae(maxbl,maxsegdg),
     .          wtrnsae(maxbl,maxsegdg),omgxae(maxbl,maxsegdg),
     .          omgyae(maxbl,maxsegdg),omgzae(maxbl,maxsegdg),
     .          xorgae(maxbl,maxsegdg),yorgae(maxbl,maxsegdg),
     .          zorgae(maxbl,maxsegdg),thtxae(maxbl,maxsegdg),
     .          thtyae(maxbl,maxsegdg),thtzae(maxbl,maxsegdg),
     .          rfrqtae(maxbl,maxsegdg),rfrqrae(maxbl,maxsegdg)

Add:

      dimension xorgae0(maxbl,maxsegdg),yorgae0(maxbl,maxsegdg),
     .          zorgae0(maxbl,maxsegdg),icouple(maxbl,maxsegdg)

Change:

c
c        deform volume grid to fit new surface
c
         iwk1 = maxbl

To:

c
c        deform volume grid to fit new surface
c
         iwk1 = 2*maxbl

Change: (in argument list of call to subroutine updatedg)

     .                 iaesurf,maxsegdg,iwk,nmaster,1)

To:

     .                 iaesurf,maxsegdg,iwk,nmaster,1,xorig,yorig,
     .                 zorig,xorgae0,yorgae0,zorgae0,icouple,
     .                 iwk(maxbl),nnodes)

After:

 1801          continue
c
               call writ_buf(nbl,11,nou,bou,nbuf,ibufdim,myhost,myid,
     .                       mycomm,mblk2nd,maxbl)

Add:

c
c              reconstruct last grid position for purely rigid grid case
c

Remove:

                  for grids with deforming surfaces, collect list of
                  surface points that undergo deformation
 
                  nsurf = 0
                  do igrid=1,ngrid
                     nbl = nblg(igrid)
                     nbl = nbl+(mseq-1)
                     iwk(nbl) = 0
                     call lead(nbl,lw,lw2,maxbl)
                     if (idefrm(nbl).gt.0 .and. idefrm(nbl).lt.999) then
                        if (mblk2nd(nbl).eq.myid) then
                           call getsurf(w(lx),w(ly),w(lz),w(ldeltj),
     .                                  w(ldeltk),w(ldelti),w(lxorg),
     .                                  w(lyorg),w(lzorg),icsi,icsf,
     .                                  jcsi,jcsf,kcsi,kcsf,wk,nwork,
     .                                  nbl,idim,jdim,kdim,nsurf,
     .                                  iwk(nbl),nsegdfrm,maxbl,
     .                                  idfrmseg,maxsegdg)
                        end if
#if defined DIST_MPI
                        mytag = itag_ns + nbl
                        nd_srce = mblk2nd(nbl)
                        if (myid.eq.mblk2nd(nbl)) then
                           call MPI_Send(iwk(nbl),1,MPI_INTEGER,
     .                                   myhost,mytag,mycomm,ierr)
                        else if (myid.eq.myhost) then
                           call MPI_Recv(iwk(nbl),1,MPI_INTEGER,
     .                                   nd_srce,mytag,mycomm,
     .                                   istat,ierr)
                        end if
                        if (iwk(nbl).gt.0) then
                           mytag   = itag_wk + nbl
                           nd_srce = mblk2nd(nbl)
                           numdat  = 9*iwk(nbl)
                           if (myid.eq.mblk2nd(nbl)) then
                              call MPI_Send(wk,numdat,
     .                                      MY_MPI_REAL,
     .                                      myhost,mytag,mycomm,
     .                                      ierr)
                           else if (myid.eq.myhost) then
                              ns = 9*nsurf+1
                              call MPI_Recv(wk(ns),numdat,
     .                                      MY_MPI_REAL,
     .                                      nd_srce,mytag,mycomm,
     .                                      istat,ierr)
                           end if
                        end if
#endif
                        if (myid.eq.myhost) then
                           nsurf = nsurf + iwk(nbl)
                        end if
 
                     end if
                  end do
 
#if defined DIST_MPI
                  if (iunst.gt.1) then
                     call MPI_Bcast (nsurf,1,MPI_INTEGER,
     .                               myhost,mycomm,ierr)
                     call MPI_Bcast (wk,nsurf*9,MY_MPI_REAL,
     .                               myhost,mycomm,ierr)
                  end if
 
#endif
                  ivert = 0
                  nflag = 1
                  lvel  = nsurf*9 + 1
 
                  reconstruct last grid state, before restart
                  (only for non-deforming zones; for deforming
                  zones, restart file contains last grid state)
 
Remove:

                        else if (idefrm(nbl).gt.0) then
 
                           deforming grid:
                           (reconstruction not needed first  order)
 
                           if (abs(ita).gt.1) then
                           nou(1) = min(nou(1)+1,ibufdim)
                           write(bou(nou(1),1),810) nbl
                           call deform(nbl,idim,jdim,kdim,w(lx),w(ly),
     .                                w(lz),w(lxold),w(lyold),w(lzold),
     .                                w(lxorg),w(lyorg),w(lzorg),
     .                                w(ldeltj),w(ldeltk),w(ldelti),
     .                                wk(lvel),icsi,icsf,jcsi,jcsf,
     .                                kcsi,kcsf,maxbl,time,dt,ita,
     .                                nou,bou,nbuf,ibufdim,myid,idefrm,
     .                                nbci0,nbcidim,nbcj0,nbcjdim,
     .                                nbck0,nbckdim,ibcinfo,jbcinfo,
     .                                kbcinfo,maxseg,wk,nsurf,1,
     .                                nflag,ivert,slavept,nslave,iskip,
     .                                jskip,kskip,nsegdfrm,idfrmseg,
     .                                iaesurf,maxsegdg,nmaster)
                           end if
 

Why Changed:   To accomodate new arrays for xorgae0,yorgae0,zorgae0,
               and icouple (see change numbers 88-90), and to accomodate
               the new restart file data for deforming meshes (see change
               numbers 100-101)

--------------------
--------------------

Number:          103

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

After:

      dimension utrnsae(maxbl0,maxsegdg0),vtrnsae(maxbl0,maxsegdg0),
     .          wtrnsae(maxbl0,maxsegdg0),omgxae(maxbl0,maxsegdg0),
     .          omgyae(maxbl0,maxsegdg0),omgzae(maxbl0,maxsegdg0),
     .          xorgae(maxbl0,maxsegdg0),yorgae(maxbl0,maxsegdg0),
     .          zorgae(maxbl0,maxsegdg0),thtxae(maxbl0,maxsegdg0),
     .          thtyae(maxbl0,maxsegdg0),thtzae(maxbl0,maxsegdg0),
     .          rfrqtae(maxbl0,maxsegdg0),rfrqrae(maxbl0,maxsegdg0)

Add:

      dimension xorgae0(maxbl0,maxsegdg0),yorgae0(maxbl0,maxsegdg0),
     .          zorgae0(maxbl0,maxsegdg0),icouple(maxbl0,maxsegdg0)

After:

      pointer (ip_aesrfdat,aesrfdat),(ip_utrnsae,utrnsae),
     .        (ip_vtrnsae,vtrnsae),(ip_wtrnsae,wtrnsae),
     .        (ip_omgxae,omgxae),(ip_omgyae,omgyae),(ip_omgzae,omgzae),
     .        (ip_xorgae,xorgae),(ip_yorgae,yorgae),(ip_zorgae,zorgae),

Add:

     .        (ip_xorgae0,xorgae0),(ip_yorgae0,yorgae0),
     .        (ip_zorgae0,zorgae0),(ip_icouple,icouple),

After:

      call umalloc(ip_omgzae,maxbl0*maxsegdg0,0,icall,memuse)
      call umalloc(ip_xorgae,maxbl0*maxsegdg0,0,icall,memuse)
      call umalloc(ip_yorgae,maxbl0*maxsegdg0,0,icall,memuse)
      call umalloc(ip_zorgae,maxbl0*maxsegdg0,0,icall,memuse)

Add:

      call umalloc(ip_xorgae0,maxbl0*maxsegdg0,0,icall,memuse)
      call umalloc(ip_yorgae0,maxbl0*maxsegdg0,0,icall,memuse)
      call umalloc(ip_zorgae0,maxbl0*maxsegdg0,0,icall,memuse)
      call umalloc(ip_icouple,maxbl0*maxsegdg0,1,icall,memuse)

Change: (in argument list to call of subroutine global)

     .            idfrmseg,iaesurf,maxsegdg0)

To:

     .            idfrmseg,iaesurf,maxsegdg0,xorgae0,yorgae0,zorgae0,
     .            icouple)

Change:

      needi_trn = 53*lmaxbl        + 117      + 8*lmaxbl*lmxsegdg
     .          + 48*lmaxbl*lmxseg + 19*lmxbli + 22*lnplts
     .          + 4*lmaxgr         + 9*lmaxcs

To:

      needi_trn = 53*lmaxbl        + 117      + 9*lmaxbl*lmxsegdg
     .          + 48*lmaxbl*lmxseg + 19*lmxbli + 22*lnplts
     .          + 4*lmaxgr         + 9*lmaxcs

After:

         call ufree(ip_omgzae)
         call ufree(ip_xorgae)
         call ufree(ip_yorgae)
         call ufree(ip_zorgae)

Add:

         call ufree(ip_xorgae0)
         call ufree(ip_yorgae0)
         call ufree(ip_zorgae0)
         call ufree(ip_icouple)

Why Changed:   To accomodate new arrays for xorgae0,yorgae0,zorgae0,
               and icouple (see change numbers 88-90).

--------------------
--------------------

Number:          104

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    trnsfr_vals.F

Change: (in argument list of subroutine trnsfr_vals)

     .                       idfrmseg,iaesurf,maxsegdg)

To:

     .                       idfrmseg,iaesurf,maxsegdg,xorgae0,yorgae0,
     .                       zorgae0,icouple)

After:

      dimension utrnsae(maxbl,maxsegdg),vtrnsae(maxbl,maxsegdg),
     .          wtrnsae(maxbl,maxsegdg),omgxae(maxbl,maxsegdg),
     .          omgyae(maxbl,maxsegdg),omgzae(maxbl,maxsegdg),
     .          xorgae(maxbl,maxsegdg),yorgae(maxbl,maxsegdg),
     .          zorgae(maxbl,maxsegdg),thtxae(maxbl,maxsegdg),
     .          thtyae(maxbl,maxsegdg),thtzae(maxbl,maxsegdg),
     .          rfrqtae(maxbl,maxsegdg),rfrqrae(maxbl,maxsegdg)

Add:

      dimension xorgae0(maxbl,maxsegdg),yorgae0(maxbl,maxsegdg),
     .          zorgae0(maxbl,maxsegdg),icouple(maxbl,maxsegdg)

After:

               work(iii+11*maxbl*maxsegdg) = thtzae(jj,kk)
               work(iii+12*maxbl*maxsegdg) = rfrqtae(jj,kk)
               work(iii+13*maxbl*maxsegdg) = rfrqrae(jj,kk)

Add:

               work(iii+14*maxbl*maxsegdg) = xorgae0(jj,kk)
               work(iii+15*maxbl*maxsegdg) = yorgae0(jj,kk)
               work(iii+16*maxbl*maxsegdg) = zorgae0(jj,kk)

Change:

         nlast = nlast + 14*maxbl*maxsegdg

To:

         nlast = nlast + 17*maxbl*maxsegdg

Change:

      nvals = 30*maxbl + 42*maxbl*maxseg   + 51   + 11*nmds*maxaes
     .      + 5*maxaes + 14*maxbl*maxsegdg + nkey

To:

      nvals = 30*maxbl + 42*maxbl*maxseg   + 51   + 11*nmds*maxaes
     .      + 5*maxaes + 17*maxbl*maxsegdg + nkey

After:

               thtzae(jj,kk)  = work(iii+11*maxbl*maxsegdg)
               rfrqtae(jj,kk) = work(iii+12*maxbl*maxsegdg)
               rfrqrae(jj,kk) = work(iii+13*maxbl*maxsegdg)

Add:

               xorgae0(jj,kk) = work(iii+14*maxbl*maxsegdg)
               yorgae0(jj,kk) = work(iii+15*maxbl*maxsegdg)
               zorgae0(jj,kk) = work(iii+16*maxbl*maxsegdg)

Change:

         nlast = nlast + 14*maxbl*maxsegdg

To:

         nlast = nlast + 17*maxbl*maxsegdg

After:

               iwork(iii+6*maxbl*maxsegdg) = idfrmseg(jj,kk)
               iwork(iii+7*maxbl*maxsegdg) = iaesurf(jj,kk)

Add:

               iwork(iii+8*maxbl*maxsegdg) = icouple(jj,kk)

Change:

         nlast = nlast + 8*maxbl*maxsegdg

To:

         nlast = nlast + 9*maxbl*maxsegdg

Change:

      nvals = 53*maxbl + 117       + 8*maxbl*maxsegdg + 48*maxbl*maxseg
     .      + 19*mxbli + 22*nplots + 4*maxgr          + 9*maxcs

To:

      nvals = 53*maxbl + 117       + 9*maxbl*maxsegdg + 48*maxbl*maxseg
     .      + 19*mxbli + 22*nplots + 4*maxgr          + 9*maxcs

After:

               idfrmseg(jj,kk) = iwork(iii+6*maxbl*maxsegdg)
               iaesurf(jj,kk)  = iwork(iii+7*maxbl*maxsegdg)

Add:

               icouple(jj,kk)  = iwork(iii+8*maxbl*maxsegdg)

Change:

         nlast = nlast + 8*maxbl*maxsegdg

To:

         nlast = nlast + 9*maxbl*maxsegdg


Why Changed:   To accomodate new arrays for xorgae0,yorgae0,zorgae0,
               and icouple (see change numbers 88-90).


--------------------
--------------------

Number:          105

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    updateg.F

Remove:

c
c           save current origin for case with simultaneous
c           rotation and translation - rotation needs to be
c           done about current origin, not the updated one that
c           will be output from trans
c
            xorgold = xorig(nbl)
            yorgold = yorig(nbl)
            zorgold = zorig(nbl)

Remove:

               xorgnew      = xorig(nbl)
               yorgnew      = yorig(nbl)
               zorgnew      = zorig(nbl)
               xorig(nbl)   = xorgold
               yorig(nbl)   = yorgold
               zorig(nbl)   = zorgold

Remove:

c
c              now replace origin with latest one
c
               xorig(nbl) = xorgnew
               yorig(nbl) = yorgnew
               zorig(nbl) = zorgnew

Change:

c
c           calculate face-average values of velocity and acceleration
c           on block boundaries and place in permanent storage for use
c           in boundary condition routines
c
            call xtbatb(jdim,kdim,idim,w(lxtbj),w(lxtbk),w(lxtbi),
     .                  w(latbj),w(latbk),w(latbi),wk(lvel),
     .                  wk(lacci),wk(laccj),wk(lacck))
c
c           store grid velocities from rigid-grid motion in a permanent
c           location if this block also undergoes deformation. this is
c           required because velocities due to mesh deformation cannot
c           be obtained (for the general multiblock case) until ALL of
c           the deforming meshes have be updated (since a deformation
c           in one block may cause deformation in another). Thus, the
c           computation of the time metrics (and regular grid metrics,
c           for that matter) cannot be completed for this block just
c           yet...this is defered until all mesh deformations are
c           complete (subroutine updatdg). note that block boundary
c           velocities stored off above can simply be added to once
c           the deforming mesh contibutions are determined, since
c           only the solid surface boundaries velocities actually
c           get used, and solid surfaces are not influenced by other
c           deforming blocks (just the current one)
c
            if (idefrm(nbl) .gt. 0) then
c
c              defer metric updates pending deformation data
c
               mdim=jdim*kdim*idim*3
               do lll=1,mdim
                  w(lvelg) = wk(lvel+lll-1)
               end do
c
            else
c
c              have enough information to complete metric updates
c

To:

c           if the current block will also undergo deformation, defer
c           updating metrics (temporal and spatial) until the changes
c           due to deformation are added.

            if (idefrm(nbl) .eq. 0) then
c
c              calculate face-average values of velocity and acceleration
c              on block boundaries and place in permanent storage for use
c              in boundary condition routines
c
               call xtbatb(jdim,kdim,idim,w(lxtbj),w(lxtbk),w(lxtbi),
     .                     w(latbj),w(latbk),w(latbi),wk(lvel),
     .                     wk(lacci),wk(laccj),wk(lacck))
c

Why Changed:   Corrected error of using previous value of grid origin for
               rotation center. Also eliminated the step of storing of the
               rigid grid (analytic) velocities. The current approach for
               the combination-motion case is to use finite diffences
               only, rather than trying to combine analytic velocities
               for the rigid component with finite differences for the
               deforming component.

--------------------
--------------------

Number:          106

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    updatedg.F

Change: (in argument list of subroutine updatedg)

     .                    iaesurf,maxsegdg,iwk,nmaster,nt)

To:

     .                    iaesurf,maxsegdg,iwk,nmaster,nt,xorig,
     .                    yorig,zorig,xorgae0,yorgae0,zorgae0,icouple,
     .                    ireq,nnodes)

After:

      dimension iskip(maxbl),jskip(maxbl),kskip(maxbl)

Add:

      dimension xorgae0(maxbl,maxsegdg),yorgae0(maxbl,maxsegdg),
     .          zorgae0(maxbl,maxsegdg),icouple(maxbl,maxsegdg)
      dimension xorig(maxbl),yorig(maxbl),zorig(maxbl)
      dimension ireq(maxbl)

After:

      itag_wk  = itag_ns + ioffset

Add:

      itag_org = itag_wk + ioffset
      itag     = 0
      nreq     = 1
c
c     make sure all current block origins are available on this
c     processor
c
      if (myid .ne. myhost) then
         ist = 1
         do nbl=1,nblock
            itag = itag + 1
            if (nbl.gt.1) ist  = ist + 1
            if (myid .ne. mblk2nd(nbl)) then

c              recieve the data on non-local nodes
c
               nd_srce = mblk2nd(nbl)
               mytag   = itag_org + itag
               call MPI_Irecv (wk(ist),3,MY_MPI_REAL,
     .                         nd_srce,mytag,mycomm,ireq(nreq),ierr)
               nreq = nreq + 1
            else
c
c              send the data to non-local nodes
c
               do inode = 1,nnodes
                  if (inode .ne. myid) then
                     nd_dest = inode
                     mytag   = itag_org + itag
                     wk(ist)   = xorig(nbl)
                     wk(ist+1) = yorig(nbl)
                     wk(ist+2) = zorig(nbl)
                     call MPI_Send (wk(ist),3,MY_MPI_REAL,
     .                              nd_dest,mytag,mycomm,ierr)
                  end if
               end do
            end if
            if (nreq-1 .gt. 0) then
               call MPI_Wait(ireq(nreq-1),istat,ierr)
            end if
            xorig(nbl) = wk(ist)
            yorig(nbl) = wk(ist+1)
            zorig(nbl) = wk(ist+2)
         end do
      end if

After:

      do 100 nbl = 1,nblock
c
      if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0 .and.
     .   (levelg(nbl).ge.lglobal .and.
     .    levelg(nbl).le.levelt(iseqr))) then
c
         call lead(nbl,lw,lw2,maxbl)

Add:

c
c        zero out deltj, deltk, delti from previous step
c        (except if this is a static deformation case)
c
         if (idefrm(nbl).gt.0 .and. idef_ss .eq. 0) then
            do lll=1,kdim*idim*3*2
               w(ldeltj+lll-1) = 0.
            end do
            do lll=1,jdim*idim*3*2
               w(ldeltk+lll-1) = 0.
            end do
            do lll=1,kdim*jdim*3*2
               w(ldelti+lll-1) = 0.
            end do
         end if

After:

c           wk(lwk1-lwk4) contain a flag that prevents points common
c           to multiple segments from being updated more than once
c           per motion type (e.g. translation and rotation). this
c           array must be set to 1 before each call to a specific
c           surface motion type
c
            do lll=lwk1,lwk4
               wk(lll) = 1.
            end do

Add:

c
c           update segment origin in case forced deformation is
c           coupled to either forced motion of block origin or
c           if deforming rotation is coupled to deforming translation
c
            do is = 1,nsegdfrm(nbl)
               if (icouple(nbl,is) .ne. 0) then
                  if (idfrmseg(nbl,is).gt.0 .and.
     .               idfrmseg(nbl,is).lt.99) then
                     if (icouple(nbl,is) .ne. 0) then
                        nblmast = icouple(nbl,is)
                        xorgae(nbl,is) = xorig(nblmast)
                        yorgae(nbl,is) = yorig(nblmast)
                        zorgae(nbl,is) = zorig(nblmast)
                     end if
                   end if
               end if
            end do

Change: (in argument list of call to subroutine trnsurf)

     .                         wk(lwk2),wk(lwk3))

To:

     .                         wk(lwk2),wk(lwk3),xorgae0(nbl,is),
     .                         yorgae0(nbl,is),zorgae0(nbl,is))

After:

  100 continue

Add:

c
#if defined DIST_MPI
      itag     = 0
      nreq     = 1
c
c     make sure all current segment origins are available on this
c     processor
c
      if (myid .ne. myhost) then
         ist = 1
         do nbl=1,nblock
            itag = itag + 1
            if (nbl .gt. 1) ist  = ist + 3*nsegdfrm(nbl-1)
            if (myid .ne. mblk2nd(nbl)) then

c              recieve the data on non-local nodes
c
               nd_srce = mblk2nd(nbl)
               mytag   = itag_org + itag
               call MPI_Irecv (wk(ist),3,MY_MPI_REAL,
     .                         nd_srce,mytag,mycomm,ireq(nreq),ierr)
               nreq = nreq + 1
            else
c
c              send the data to non-local nodes
c
               do inode = 1,nnodes
                  if (inode .ne. myid) then
                     nd_dest   = inode
                     mytag     = itag_org + itag
                     nval      = 3*nsegdfrm(nbl)
                     do is=1,nsegdfrm(nbl)
                        ist2 = 3*(is-1)
                        wk(ist+ist2)   = xorgae(nbl,is)
                        wk(ist+ist2+1) = yorgae(nbl,is)
                        wk(ist+ist2+2) = zorgae(nbl,is)
                     end do
                     call MPI_Send (wk(ist),nval,MY_MPI_REAL,
     .                              nd_dest,mytag,mycomm,ierr)
                  end if
               end do
            end if
            if (nreq-1 .gt. 0) then
               call MPI_Wait(ireq(nreq-1),istat,ierr)
            end if
            do is=1,nsegdfrm(nbl)
               ist2 = 3*(is-1)
               xorgae(nbl,is) = wk(ist+ist2)
               yorgae(nbl,is) = wk(ist+ist2+1)
               zorgae(nbl,is) = wk(ist+ist2+2)
            end do
         end do
      end if
#endif
c
c     update block origin in case motion of block origin is
c     coupled to forced deformation. note: only translational
c     motion updates block origin - rotational motion leaves
c     origin unchanged (i.e origin is center of roation)
c
      do nbl=1,nblock
         if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0 .and.
     .      (levelg(nbl).ge.lglobal .and.
     .       levelg(nbl).le.levelt(iseqr))) then
             do is = 1,nsegdfrm(nbl)
                if (icouple(nbl,is) .ne. 0) then
                   nblmast = icouple(nbl,is)
                   if (idfrmseg(nblmast,is) .eq. 1) then
                      xorig(nbl) = xorgae(nblmast,is)
                      yorig(nbl) = yorgae(nblmast,is)
                      zorig(nbl) = zorgae(nblmast,is)
                   end if
                end if
             end do
         end if
      end do

Remove:

c              add velocities from mesh deformation to those from
c              rigid-grid motion
c
               if (irotat(nbl).gt.0 .or. itrans(nbl).gt.0) then
                  do ll=lvelg,lvelg+jdim*kdim*idim*3-1
                     lll = lvel + (ll-lvelg)
                     wk(lll) = wk(lll) + w(ll)
                  end do
               end if

Why Changed:   1) to accomodate new arrays for xorgae0,yorgae0,zorgae0,
               and icouple (see change numbers 88-90); 2) to change from
               deltas measured relative to the undeformed mesh to those
               of the mesh at the previous time step (see change number 92);
               3) to eliminate the combination of analytic grid velocities
               for the rigid-grid component with finite difference grid
               velocities for the deforming-mesh component in the case
               of combination grid motion in favor of a pure finite-difference
               approach; 4) allow for coupling of deforming translating and
               deforming rotating mesh segments, in addition to coupling
               of rigid and deforming mesh motion.

--------------------
--------------------

Number:          107

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    pointers.F

Change: 

c      55  xold
c      56  yold
c      57  zold
c      58  deltj
c      59  deltk
c      60  delti
c      61  xorig
c      62  yorig
c      63  zorig


To:

c      55  xnm2
c      56  ynm2
c      57  znm2
c      58  deltj
c      59  deltk
c      60  delti
c      61  xnm1
c      62  ynm1
c      63  znm1

Change: (with similar changes for corresponding y and z)

c........x-coordinate at time step n-1 (only for deforming

To:

c........x-coordinate at time step n-2 (only for deforming

Change: (with similar changes for corresponding y and z)

c........x-coordinate of unperturbed grid

To:

c........x-coordinate at time step n-1

Why Changed: Reflects variable name changes to go along with new definitions
             of deltas in the deforming mesh case: in the old way, changes 
             where measured relative to the unperturbed mesh (xxorg, etc.)
             while now changes are measured relative to the last grid shape.
             Now, valiable xnm1, etc. refer to the grid at time step n-1
             xnm2, etc. refer to the grid at time step n-2, with the current
             grid as x,y,z


--------------------
--------------------

Number:          108

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist and cfl3dv6/source/cfl3d/libs

Subroutine(s):    ae_corr.F, bc_blkint.F, bc_embed.F, bc_period.F, 
                  findmin_new.F, mgblk, pointers.F, qinter.F, qout.F,
                  resetg.F, setup.F, sizer.F, updatedg.F, 
                  yplusout.F

                  bc.F, bc_info.F, bc_xmera.F, cgnstools.F, deform.F,
                  lead.F, pre_embed.F

Change: (some subroutines have multiple occurrances)

        lxold, lyold, lzold

To:

        lxnm2, lynm2, lznm2

Change: (some subroutines have multiple occurrances)

        lxorg, lyorg, lzorg

To:

        lxnm1, lynm1, lznm1


Why Changed: Reflects variable name changes to go along with new definitions
             of deltas in the deforming mesh case: in the old way, changes
             where measured relative to the unperturbed mesh (xxorg, etc.)
             while now changes are measured relative to the last grid shape.
             Now, valiable xnm1, etc. refer to the grid at time step n-1
             xnm2, etc. refer to the grid at time step n-2, with the current
             grid as x,y,z
 

--------------------
--------------------

Number:          109

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist and cfl3dv6/source/cfl3d/libs

Subroutine(s):    rrestg.F, wrestg.F, updatedg.F, deform.F, setcorner.F

Change: (multiple occurances)

        xold, yold, zold

To:

        xnm2, ynm2, znm2

Change: (multiple occurances)

        xxorg, yyorg, zzorg

To:

        xnm1, ynm1, znm1


Why Changed: Reflects variable name changes to go along with new definitions
             of deltas in the deforming mesh case: in the old way, changes
             where measured relative to the unperturbed mesh (xxorg, etc.)
             while now changes are measured relative to the last grid shape.
             Now, valiable xnm1, etc. refer to the grid at time step n-1
             xnm2, etc. refer to the grid at time step n-2, with the current
             grid as x,y,z

--------------------
--------------------

Number:          110

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    lead.F


Change:

      lxold  = lw(55,nbl)
      lyold  = lw(56,nbl)
      lzold  = lw(57,nbl)

To:

      lxnm2  = lw(55,nbl)
      lynm2  = lw(56,nbl)
      lznm2  = lw(57,nbl)

Change:

      lxorg  = lw(61,nbl)
      lyorg  = lw(62,nbl)
      lzorg  = lw(63,nbl)

To:

      lxnm1  = lw(61,nbl)
      lynm1  = lw(62,nbl)
      lznm1  = lw(63,nbl)

Why Changed: Reflects variable name changes to go along with new definitions
             of deltas in the deforming mesh case: in the old way, changes
             where measured relative to the unperturbed mesh (xxorg, etc.)
             while now changes are measured relative to the last grid shape.
             Now, valiable xnm1, etc. refer to the grid at time step n-1
             xnm2, etc. refer to the grid at time step n-2, with the current
             grid as x,y,z


--------------------
--------------------

Number:          111

Version:          6.0 (and 5.0)

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    initvist.F

Change:

      if (ivisc(1).eq.13 .or. ivisc(2).eq.13 .or. ivisc(3).eq.13) then

To:

      if (ivisc(1).eq.9  .or. ivisc(2).eq.9  .or. ivisc(3).eq.9  .or.
     .    ivisc(1).eq.13 .or. ivisc(2).eq.13 .or. ivisc(3).eq.13) then


Why corrected:  The situation where ivisc .eq. 9 was inadvertently left out.

--------------------
--------------------

Number:          112

Version:          6.0 (and 5.0)

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Global routine:   cbsem.f

Subroutine(s):    plot3t

After:

            else if(ivmx .eq. 8 .or. ivmx .eq. 12) then
c            Find nonlinear tauij values:
                alpa1=(2.-c4)/2.*gg
                alpa2=(2.-c3)*gg

Add:

                if (ivmx .eq. 8) then
                  alpa1=0.
                  alpa2=0.
                end if

After:

            else if(ivmx .eq. 9 .or. ivmx .eq. 13) then
               al10 = 0.25*c1 -1.
               al1 = 3.8
               al2 = 0.5*c2 -2./3.
               al3 = 0.5*c3 -1.
               al4 = 0.5*c4 -1.
              eta1=xis*turre(j,k,i,2)**2/(turre(j,k,i,1)*re)**2
              alpa1 = -al4/(al10-eta1*al1*cmuv(j,k,i))
              alpa2 = -2.*al3/(al10-eta1*cmuv(j,k,i)*al1)

Add:

               if (ivmx .eq. 9) then
                 alpa1=0.
                 alpa2=0.
               end if


Why corrected:  If the LINEAR versions of the EASM turb models are
                used (#8 or #9), then there are no nonlinear contributions
                to the stresses!  The code itself did this correctly, but 
                in plot3t (which gives turbulent data output at the end
                of the run), the nonlinear contributions were added in 
                regardless.


--------------------
--------------------

Number:          113

Version:          6.0 (and 5.0)

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    metric.F

After:

      common /singular/ atol

Add:

      common /zero/iexp

After:

      icntmax = 10

Add:

      atol2   = 10.**(-iexp+1)

Change:

      asum = asum + sqrt(si(izz,i,4))
c
 1020 continue

To:

      asum = asum + sqrt(si(izz,i,4))
      if (si(izz,i,4) .eq. 0.) si(izz,i,4) = atol2
c
 1020 continue

Change:

      asum = asum + sqrt(sj(izz,i,4))
c
 2020 continue

To:

      asum = asum + sqrt(sj(izz,i,4))
      if (sj(izz,i,4) .eq. 0.) sj(izz,i,4) = atol2
c
 2020 continue

Change:

      asum = asum + sqrt(sk(izz,i,4))
c
 3020 continue

To:

      asum = asum + sqrt(sk(izz,i,4))
      if (sk(izz,i,4) .eq. 0.) sk(izz,i,4) = atol2
c
 3020 continue


Why corrected:  If you had a grid for which an edge had part 
                singular line and part not, the computation could
                give an error in metric.  This fix removes the 
                possible division by zero.

--------------------
--------------------

Number:          114

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    twoeqn.F

Change:  (all occurrances)

            vist3d(j,k,i)=ccmincr(vist3d(j,k,i),100000.)

To:

            vist3d(j,k,i)=ccmin(vist3d(j,k,i),edvislim)

Change:  (all occurrances)

            v3dtmp(j,k,i)=ccmincr(v3dtmp(j,k,i),100000.)

To:

            v3dtmp(j,k,i)=ccmin(v3dtmp(j,k,i),edvislim)


Why corrected:  For the 2-eqn models, a hardwired limiter currently keeps the eddy
                viscosity from being greater than 100000 times the laminar viscosity.
                This limit can possibly be exceeded for high Re separated flows;
                the new keyword, edvislim, allows the user to change the default
                limit if desired. Note the function call has changed along with
                the argument.


--------------------
--------------------

Number:          115

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs and cfl3dv6/source/cfl3d/dist

Subroutine(s):    barth3d.F,blomax.F,global.F,readkey.F,spalart.F, twoeqn.F,
                  trnsfr_vals.F

Change:

      common /turbconv/ nsubturb,cflturb,nfreeze

To:

      common /turbconv/ nsubturb,cflturb,nfreeze,edvislim,iturbprod

Why corrected:  See change number 114

--------------------
--------------------

Number:          116

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    readkey.F

After:

c
c     flag to turn off stops when negative volumes/bad metrics
c     are encountered - use only to debug mesh deformation!
c     default is to stop when negative volumes/bad metrics are
c     found
c
      negvol    = 0
      nkey      = nkey + 1

Add:

c
c     eddy viscosity limiter for two eqn. turbulence models: limit
c     eddy viscosity to edvislim times the laminar viscosity
c
      edvislim  = 100000.
      nkey      = nkey + 1
c
c     flag to set whether approximate production term (0) or full
c     production term (1) is used in EASM models 8,9,13,14
c
      iturbprod = 0
      nkey      = nkey + 1

After:

c
      else if (inpstr(lc1:lc2).eq.'negvol') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) negvol

Add:

c
      else if (inpstr(lc1:lc2).eq.'edvislim') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) realval(1)
         edvislim = realval(1)
c
      else if (inpstr(lc1:lc2).eq.'iturbprod') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) iturbprod


Why corrected:  See change number 114

--------------------
--------------------

Number:          117

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    trnsfr_vals.F

After:

         work(nlast+30) = iblnkfr

Add:

         work(nlast+31) = edvislim

After:

         iblnkfr   = int(work(nlast+30))

Add:

         edvislim  = work(nlast+31)

Why corrected:  See change number 114

--------------------
--------------------

Number:          118

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    ccomplex.F

Change:

c***********************************************************************
c     Purpose: complex/real hyperbolic tangent
c***********************************************************************
#ifdef CMPLX
      complex function cctanh(a)
      implicit complex(a-h,o-z)
c     real r1,r2
c     r1 = tanh(real(a))
c     r2 = tanh(aimag(a))
c     cctanh = cmplx(r1,r2)
c mod by vatsa on argument (4-20-99)
      if (real(a).gt.50) then
cvn   if (abs(real(a)).gt.50) then
         cctanh = 1.
      else
         eplus = exp(a)
         eminus = exp(-a)
         cctanh = (eplus - eminus)/(eplus + eminus)
      end if
#else
      function cctanh(a)
      cctanh = tanh(a)
#endif
      return
      end
c

To:

c***********************************************************************
c     Purpose: complex/real hyperbolic tangent
c***********************************************************************
#ifdef CMPLX
      complex function cctanh(a)
      implicit complex(a-h,o-z)
      if (real(a).gt.50) then
         cctanh = 1.
      else if (real(a).lt.-50) then
         cctanh = -1.
      else
         eplus = exp(a)
         eminus = exp(-a)
         cctanh = (eplus - eminus)/(eplus + eminus)
      end if
#else
      function cctanh(a)
      cctanh = tanh(a)
#endif
      return
      end
c

Why Changed: The branch for real(a)---> -infinity (=-50) was neglected and
             could lead to incorrect results for some cases. Also, some 
             unused statements were removed.

--------------------
--------------------

Number:          119

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    updatedg.F

Change:

c
c           aeroelastic surface
c
            do is = 1,nsegdfrm(nbl)
               if (idfrmseg(nbl,is) .eq. 99) then
                  call aesurf(nbl,jdim,kdim,idim,w(ldeltj),w(ldeltk),
     .                        w(ldelti),w(lxmdj),w(lxmdk),w(lxmdi),
     .                        maxbl,maxseg,nmds,maxaes,aesrfdat,
     .                        xs,xxn,icsi,icsf,jcsi,jcsf,kcsi,kcsf,
     .                        nsegdfrm,idfrmseg,iaesurf,maxsegdg)
               end if
            end do

To:

c
c           aeroelastic surface
c
            call aesurf(nbl,jdim,kdim,idim,w(ldeltj),w(ldeltk),
     .                  w(ldelti),w(lxmdj),w(lxmdk),w(lxmdi),
     .                  maxbl,maxseg,nmds,maxaes,aesrfdat,
     .                  xs,xxn,icsi,icsf,jcsi,jcsf,kcsi,kcsf,
     .                  nsegdfrm,idfrmseg,iaesurf,maxsegdg)

Why Changed: There is also a loop over is = 1,nsegdfrm(nbl) inside
             subroutine aesurf, making this outer one unneccessary.
             Only affects cases with multiple aeroelastic segments
             on a given block face, in which case the error lead to
             the segments being updated twice.


--------------------
--------------------

Number:          120

Version:          6.0

Type:                Error     Problem     Modification/enhancement   X Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    aesurf.F

Change:

         do is=1,nsegdfrm(nbl)
c
         if (iaesurf(nbl,is).eq.iaes) then

To

         do is=1,nsegdfrm(nbl)
c
         if (iaesurf(nbl,is).eq.iaes .and. idfrmseg(nbl,is).eq.99) then

Why Changed: A consequence of Change 119; the check for whether the segment
             is of the deforming type or not is now done inside aesurf,
             not outside.

--------------------
--------------------

Number:          121

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist and cfl3dv6/source/cfl3d/libs

Subroutine(s):    plot3t.F,   pointers.F, rrest.F,  wrest.F
                  bc2004.F,   gfluxv.F,   init.F,   cgnstools.F, global.F,
                  initvist.F, ffluxv.F,   hfluxv.F, twoeqn.F


Change: Just get the new routines.


Why Changed: Numerous minor changes for implement a new 2-Eq. turbulence
             model (nonlinear EASM k-omega with variable g, number 14),
             as well as enhancements to some existing models.

--------------------
--------------------

Number:          122

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

Change:

         nbl = inpl3d(n,1)

To:

         nbl = inpr(n,1)

Why Changed: Block number for print out was being obtained from the plot3d
             data, not print data; depending on the case, this could lead
             to erroneous sizing for print data.

--------------------
--------------------

Number:          123

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    trnsfr_vals.F

After:

         work(nlast+32) = iturbprod

Add:

         work(nlast+33) = ip3dgrad

After:

         iturbprod = int(work(nlast+32))

Add:

         ip3dgrad  = work(nlast+33)


Why corrected:  Tranfer the keyword ip3dgrad (see change 10) to toggle between
                solution and derivative output in the plot3d files (only active
                in complex version)

--------------------
--------------------

Number:          124

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    plot3d.F, plot3c.F, plot3t.F

Change: Numerous changes; just get the new routines

Why corrected: Allow switching between solution output and derivative output to
               the plot3d files (complex version only)

--------------------
--------------------

Number:          125

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    cctogp.F

Change: 

#if defined P3D_SINGLE
      real*4    dumgp(jdw,kdw,idw,ldim)
#else
      dimension dumgp(jdw,kdw,idw,ldim)
#endif

To:

      dimension dumgp(jdw,kdw,idw,ldim)


Why corrected: For compatability with changes to plot3d routines cited in
               Change Number 124.

--------------------
--------------------

Number:          126

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    qout.F

Change: (2 places)

c
c           check storage availability
c
            ibwk = 1    + jdw*kdw*idw*5
            ixgk = ibwk + jdim*kdim*idim*2
            nroom = nwork - (ixgk+jdw*kdw*idw*4-1)
            if (nroom .lt. 0.) then
               if (myid.eq.myhost) then
                  write(11,'('' not enough memory for plot3d'')')
                  write(11,'('' have, need = '',2i12)') nwork,
     .            nwork-nroom
                  write(11,'('' not writing out plot3d files'')')
               end if
            else
               call plot3d(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,k1,k2,k3,
     .                     w(lq),w(lqi0),w(lqj0),w(lqk0),w(lx),
     .                     w(ly),w(lz),wk,wk(ibwk),
     .                     w(lblk),wk(ixgk),iflag,w(lvis),iovrlp(nbl),
     .                     nbl,nmap,w(lbcj),w(lbck),w(lbci),
     .                     w(lvj0),w(lvk0),w(lvi0),ifunc,n,jdw,kdw,idw,
     .                     nplots,jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                     jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                     maxxe,nblk,nbli,limblk,isva,nblon,mxbli,
     .                     thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                     mblk2nd,inpl3d,nblock,nblkpt)
            end if

To: (2 places)

c
c           check storage availability
c
            ixwk = 1
            ibwk = ixwk + jdw*kdw*idw*5
            ixgk = ibwk + jdim*kdim*idim*2
            ixvk = ixgk + jdw*kdw*idw*4
            nroom = nwork - (ixvk+jdw*kdw*idw*5-1)
            if (nroom .lt. 0.) then
               if (myid.eq.myhost) then
                  write(11,'('' not enough memory for plot3d'')')
                  write(11,'('' have, need = '',2i12)') nwork,
     .            nwork-nroom
                  write(11,'('' not writing out plot3d files'')')
               end if
            else
               call plot3d(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,k1,k2,k3,
     .                     w(lq),w(lqi0),w(lqj0),w(lqk0),w(lx),
     .                     w(ly),w(lz),wk(ixwk),wk(ibwk),
     .                     w(lblk),wk(ixgk),iflag,w(lvis),iovrlp(nbl),
     .                     nbl,nmap,w(lbcj),w(lbck),w(lbci),
     .                     w(lvj0),w(lvk0),w(lvi0),ifunc,n,jdw,kdw,idw,
     .                     nplots,jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                     jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                     maxxe,nblk,nbli,limblk,isva,nblon,mxbli,
     .                     thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                     mblk2nd,inpl3d,nblock,nblkpt,wk(ixvk))
            end if

Change: (2 places)

c
c           check storage availability
c
            ibwk = 1    + jdw*kdw*idw*5
            ixgk = ibwk + jdim*kdim*idim
            nroom = nwork - (ixgk+jdw*kdw*idw*4-1)
            if (nroom .lt. 0.) then
               if (myid.eq.myhost) then
                  write(11,'('' not enough memory for plot3c'')')
                  write(11,'('' have, need = '',2i12)') nwork,
     .            nwork-nroom
                  write(11,'('' not writing out plot3d files'')')
               end if
            else
               call plot3c(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,k1,k2,k3,
     .                     w(lq),w(lqi0),w(lqj0),w(lqk0),w(lx),w(ly),
     .                     w(lz),wk,wk(ibwk),w(lblk),wk(ixgk),
     .                     iflag,w(lvis),w(lvi0),w(lvj0),w(lvk0),
     .                     iovrlp(nbl),nbl,nmap,w(lsnk0),ifunc,n,
     .                     jdw,kdw,idw,
     .                     nplots,jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                     jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                     maxxe,nblk,nbli,limblk,isva,nblon,mxbli,
     .                     thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                     mblk2nd,inpl3d,nblock,nblkpt,ip3dsurf)
            end if

To: (2 places)

c           check storage availability
c
            ixwk = 1
            ibwk = ixwk + jdw*kdw*idw*5
            ixgk = ibwk + jdim*kdim*idim
            nroom = nwork - (ixgk+jdw*kdw*idw*4-1)
            if (nroom .lt. 0.) then
               if (myid.eq.myhost) then
                  write(11,'('' not enough memory for plot3c'')')
                  write(11,'('' have, need = '',2i12)') nwork,
     .            nwork-nroom
                  write(11,'('' not writing out plot3d files'')')
               end if
            else
               call plot3c(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,k1,k2,k3,
     .                     w(lq),w(lqi0),w(lqj0),w(lqk0),w(lx),w(ly),
     .                     w(lz),wk(ixwk),wk(ibwk),w(lblk),wk(ixgk),
     .                     iflag,w(lvis),w(lvi0),w(lvj0),w(lvk0),
     .                     iovrlp(nbl),nbl,nmap,w(lsnk0),ifunc,n,
     .                     jdw,kdw,idw,
     .                     nplots,jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                     jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                     maxxe,nblk,nbli,limblk,isva,nblon,mxbli,
     .                     thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                     mblk2nd,inpl3d,nblock,nblkpt,ip3dsurf)
            end if



c
c              check storage availability
c
               if (ivmx.eq.8 .or. ivmx.eq.9 .or. ivmx.ge.11) then
c                 have permanent storage for ux, starting at lux
                  ibwk  = 1    + jdw*kdw*idw*5
                  ixgk  = ibwk + jdim*kdim*idim
                  ibwk3 = ixgk + jdw*kdw*idw*4
                  nroom=nwork-(ibwk3+jdim*kdim*9)
                  if (nroom .lt. 0.) then
                     if (myid.eq.myhost) then
                        write(11,'('' not enough memory for plot3t'')')
                        write(11,'('' have, need = '',2i12)') nwork,
     .                  nwork-nroom
                        write(11,'('' not writing out plot3d files'')')
                     end if
                  else
                     call plot3t(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,
     .                           k1,k2,k3,w(lq),w(lx),w(ly),w(lz),
     .                           wk,wk(ibwk),w(lblk),wk(ixgk),w(lvis),
     .                           iovrlp(nbl),nbl,nmap,w(lsj),w(lsk),
     .                           w(lsi),w(lsnk0),w(lux),w(lxib),
     .                           w(lvol),w(lqj0),w(lqk0),w(lqi0),
     .                           w(lbcj),w(lbck),w(lbci),wk(ibwk3),
     .                           w(lcmuv),jdw,kdw,idw,nplots,jdimg,
     .                           kdimg,idimg,nblcg,jsg,ksg,isg,jeg,keg,
     .                           ieg,ninter,iindex,intmax,nsub1,maxxe,
     .                           nblk,nbli,limblk,isva,nblon,mxbli,
     .                           thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                           mblk2nd,inpl3d,nblock,nblkpt,w(lvolj0),
     .                           w(lvolk0),w(lvoli0),vormax,ivmax,jvmax,
     .                           kvmax)
                  end if
               else
c                 need to grab ux storage from temporary work array,
c                 starting at location ibwk2
                  ibwk  = 1    + jdw*kdw*idw*5
                  ixgk  = ibwk + jdim*kdim*idim
                  ibwk2 = ixgk + jdw*kdw*idw*4
                  ibwk3 = ibwk2 +(jdim-1)*(kdim-1)*(idim-1)*9
                  nroom=nwork-(ibwk3+jdim*kdim*9)
                  if (nroom .lt. 0.) then
                     if (myid.eq.myhost) then
                        write(11,'('' not enough memory for plot3t'')')
                        write(11,'('' have, need = '',2i12)') nwork,
     .                  nwork-nroom
                        write(11,'('' not writing out plot3d files'')')
                     end if
                  else
                     call plot3t(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,
     .                           k1,k2,k3,w(lq),w(lx),w(ly),w(lz),
     .                           wk,wk(ibwk),w(lblk),wk(ixgk),w(lvis),
     .                           iovrlp(nbl),nbl,nmap,w(lsj),w(lsk),
     .                           w(lsi),w(lsnk0),wk(ibwk2),w(lxib),
     .                           w(lvol),w(lqj0),w(lqk0),w(lqi0),
     .                           w(lbcj),w(lbck),w(lbci),wk(ibwk3),
     .                           w(lcmuv),jdw,kdw,idw,nplots,jdimg,
     .                           kdimg,idimg,nblcg,jsg,ksg,isg,jeg,keg,
     .                           ieg,ninter,iindex,intmax,nsub1,maxxe,
     .                           nblk,nbli,limblk,isva,nblon,mxbli,
     .                           thetay,maxbl,maxgr,myid,myhost,mycomm,
     .                           mblk2nd,inpl3d,nblock,nblkpt,w(lvolj0),
     .                           w(lvolk0),w(lvoli0),vormax,ivmax,jvmax,
     .                           kvmax)
                  end if
               end if

To:

c
c              check storage availability
c
               if (ivmx.eq.8 .or. ivmx.eq.9 .or. ivmx.ge.11) then
c                 have permanent storage for ux, starting at lux
                  ixwk  = 1
                  ibwk  = ixwk + jdw*kdw*idw*5
                  ixgk  = ibwk + jdim*kdim*idim
                  ibwk3 = ixgk + jdw*kdw*idw*4
                  nroom=nwork-(ibwk3+jdim*kdim*9)
                  if (nroom .lt. 0.) then
                     if (myid.eq.myhost) then
                        write(11,'('' not enough memory for plot3t'')')
                        write(11,'('' have, need = '',2i12)') nwork,
     .                  nwork-nroom
                        write(11,'('' not writing out plot3d files'')')
                     end if
                  else
                     call plot3t(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,
     .                           k1,k2,k3,w(lq),w(lx),w(ly),w(lz),
     .                           wk(ixwk),wk(ibwk),w(lblk),wk(ixgk),
     .                           w(lvis),iovrlp(nbl),nbl,nmap,w(lsj),
     .                           w(lsk),w(lsi),w(lsnk0),w(lux),
     .                           w(lxib),w(lvol),w(lqj0),w(lqk0),
     .                           w(lqi0),w(lbcj),w(lbck),w(lbci),
     .                           wk(ibwk3),w(lcmuv),jdw,kdw,idw,nplots,
     .                           jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                           ieg,jeg,keg,ninter,iindex,intmax,nsub1,
     .                           maxxe,nblk,nbli,limblk,isva,nblon,
     .                           mxbli,thetay,maxbl,maxgr,myid,myhost,
     .                           mycomm,mblk2nd,inpl3d,nblock,nblkpt,
     .                           w(lvolj0),w(lvolk0),w(lvoli0),vormax,
     .                           ivmax,jvmax,kvmax)
                  end if
               else
c                 need to grab ux storage from temporary work array,
c                 starting at location ibwk2
                  ixwk  = 1
                  ibwk  = ixwk + jdw*kdw*idw*5
                  ixgk  = ibwk + jdim*kdim*idim
                  ibwk2 = ixgk + jdw*kdw*idw*4
                  ibwk3 = ibwk2 +(jdim-1)*(kdim-1)*(idim-1)*9
                  nroom=nwork-(ibwk3+jdim*kdim*9)
                  if (nroom .lt. 0.) then
                     if (myid.eq.myhost) then
                        write(11,'('' not enough memory for plot3t'')')
                        write(11,'('' have, need = '',2i12)') nwork,
     .                  nwork-nroom
                        write(11,'('' not writing out plot3d files'')')
                     end if
                  else
                     call plot3t(jdim,kdim,idim,i1,i2,i3,j1,j2,j3,
     .                           k1,k2,k3,w(lq),w(lx),w(ly),w(lz),
     .                           wk(ixwk),wk(ibwk),w(lblk),wk(ixgk),
     .                           w(lvis),iovrlp(nbl),nbl,nmap,w(lsj),
     .                           w(lsk),w(lsi),w(lsnk0),wk(ibwk2),
     .                           w(lxib),w(lvol),w(lqj0),w(lqk0),
     .                           w(lqi0),w(lbcj),w(lbck),w(lbci),
     .                           wk(ibwk3),w(lcmuv),jdw,kdw,idw,nplots,
     .                           jdimg,kdimg,idimg,nblcg,jsg,ksg,isg,
     .                           jeg,keg,ieg,ninter,iindex,intmax,nsub1,
     .                           maxxe,nblk,nbli,limblk,isva,nblon,
     .                           mxbli,thetay,maxbl,maxgr,myid,myhost,
     .                           mycomm,mblk2nd,inpl3d,nblock,nblkpt,
     .                           w(lvolj0),w(lvolk0),w(lvoli0),vormax,
     .                           ivmax,jvmax,kvmax)
                  end if
               end if


Why corrected: For compatability with changes to plot3d routines cited in
               Change Number 124. Also includes a small nomenclature cleanup
               for points in qout and the corresponding arrays in plot3d,
               plot3c, and plot3t.


--------------------
--------------------

Number:          127

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

After:

      dimension factjlo(intmx,msub1),factjhi(intmx,msub1),
     .          factklo(intmx,msub1),factkhi(intmx,msub1)
c

Add:

      common /cfl/ dt0

After:

      do 8000 nbl=1,nblock
c
      if (iadvance(nbl).lt.0) go to 8000
      if (level.ne.levelg(nbl)) go to 8000
c
      call lead(nbl,lw,lw2,maxbl)
c

Add:

#if defined DIST_MPI
c
c     ramp time step/cfl number on host processor
c
      if (myid.eq.myhost) then
         if (kode.eq.-1 .or. ntime.gt.1) go to 130
c
c        local time step: ramp initial CFL number to a value fmax times larger.
c        The time step distribution is recalculated for each cycle.
c
         dttol = 1.e-6
         if (iflagts.gt.0 .and. real(dt).lt.0 .and. icyc.gt.1) then
           if (nt.eq.1 .and. abs(real(dt)) .lt.
     .         real(fmax)*abs(real(dt0))-real(dttol)) then
c             ramp CFL on first block on top level
              if (level.eq.levt .and. nbl.eq.nblstat) then
                 t2   = 1.e0/float(iflagts)
                 fact = fmax**t2
                 dt   = fact*dt
c                nou(1) = min(nou(1)+1,ibufdim)
c                write(bou(nou(1),1),*)'cycle, cfl = ',icyc,real(dt)
              end if
           end if
         end if
c
c        global time step:ramp initial time step to a value fmax times larger.
c        The CFL number distribution is recalculated for each time step.
c
         dttol = 1.e-6
         if (iflagts.gt.0 .and. real(dt).gt.0 .and. nt.gt.1) then
            if (icyc.eq.1 .and. abs(real(dt)) .lt.
     .         real(fmax)*abs(real(dt0))-real(dttol)) then
c              ramp time step on first block on top level
               if (level.eq.levt .and. nbl.eq.nblstat) then
                 t2   = 1.e0/float(iflagts)
                 fact = fmax**t2
                 dt   = fact*dt
c                nou(1) = min(nou(1)+1,ibufdim)
c                write(bou(nou(1),1),*)'time step, dt = ',nt,real(dt)
              end if
           end if
         end if
 130     continue
      end if
#endif
c

Why Changed:   Time step was not ramped on the host, and as a result,
               the time written to the output file was incorrect. Only
               observed when ramping the time step in time accurate
               mode on parallel platforms. 

--------------------
--------------------

Number:          128

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Change: (2 places)

            if (idim1/irngmin*irngmin .eq. irngmin) then

To: (2 places)

            if (idim1/irngmin*irngmin .eq. idim1) then

Change: (2 places)

            if (jdim1/jrngmin*jrngmin .eq. jrngmin) then

To: (2 places)

            if (jdim1/jrngmin*jrngmin .eq. jdim1) then

Change: (2 places)

            if (kdim1/krngmin*krngmin .eq. krngmin) then

To: (2 places)

            if (kdim1/krngmin*krngmin .eq. kdim1) then

Why Changed:   Test for even divisibilty was done with the
               wrong value, potentially resulting in incorrect
               default skip ranges.


--------------------
--------------------

Number:          129

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    metric.F

After:

            write(bou(nou(1),1),'('' The 2 i-planes need to be'',
     .       '' identical (in their planar values) for 2-D (i2d=1)'')')

Add:

            nou(1) = min(nou(1)+1,ibufdim)
            write(bou(nou(1),1),'(''   ... or else the problem may'',
     .       '' be that IALPH is set incorrectly for your grid'')')

Why corrected:  Additional error diagnostic.


--------------------
--------------------

Number:          130

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

Change:

c           plot3d requirements
            call lead(nbl,lw,lw2,maxbl0)
            jdw = (j2-j1)/j3 + 1
            kdw = (k2-k1)/k3 + 1
            idw = (i2-i1)/i3 + 1
            itemp = jdw*kdw*idw*9 + jdim*kdim*idim*2

To:

c           plot3d requirements
            call lead(nbl,lw,lw2,maxbl0)
            jdw = (j2-j1)/j3 + 1
            kdw = (k2-k1)/k3 + 1
            idw = (i2-i1)/i3 + 1
            itemp = jdw*kdw*idw*14 + jdim*kdim*idim*2

Why corrected: Increase in memeory for plot3d routine needed to allow derivative
               output.


--------------------
--------------------

Number:          131

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global0.F

Change:

c     dynamic patch data
c
      intmx0 = 1
      msub10 = 1
c
      if (iunst.gt.0) then
         read(iunit5,'(a80)',end=888) string
         write(iunit11,'(a80)') string
         call echoinp(iunit5,iunit11,0)
         read(iunit5,'(a80)',end=888) string
         write(iunit11,'(a80)') string
         call echoinp(iunit5,iunit11,0)
         read(iunit5,*,end=888) nint0
         write(iunit11,'(i10)') nint0
         call echoinp(iunit5,iunit11,0)
  888    continue
c
         if (nint0.gt.0) then
c
             intmx0 = nint0*(ncgmax+1)
c
             call echoinp(iunit5,iunit11,1)
             do n=1,nint0
                call echoinp(iunit5,iunit11,1)
             end do
             do n=1,nint0

To:

c     dynamic patch data
c
      intmx0 = 1
      msub10 = 1
c
      if (iunst.gt.0) then
         read(iunit5,'(a80)',end=888) string
         write(iunit11,'(a80)') string
         call echoinp(iunit5,iunit11,0)
         read(iunit5,'(a80)',end=888) string
         write(iunit11,'(a80)') string
         call echoinp(iunit5,iunit11,0)
         read(iunit5,*,end=888) nint1
         write(iunit11,'(i10)') nint1
         call echoinp(iunit5,iunit11,0)
  888    continue
c
         if (nint1.gt.0) then
c
             intmx0 = nint1*(ncgmax+1)
c
             call echoinp(iunit5,iunit11,1)
             do n=1,nint1
                call echoinp(iunit5,iunit11,1)
             end do
             do n=1,nint1


Why corrected: Routine tried to dynamic patch data even if
               there were none, under the conditions if iunst > 0 
               and ninter < 0 (i.e. static patching active)

--------------------
--------------------

Number:          132

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global0.F

Change:

       if (i2d.gt.0) nplots0 = maxgr0

To:

       if (abs(i2d).gt.0) nplots0 = maxgr0

Why corrected: Incorrectly computes the parameter nplots if nplot3d < 0 
               and i2d = -1 (i.e. 2D with point vortex)


--------------------
--------------------

Number:          133

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global0.F

Change:

      if (i2d.ne.1) then
      if (ifdsg(nbl,1).eq.0.or.idiag(1).eq.0) then

To:

      if (abs(i2d).ne.1) then
      if (ifdsg(nbl,1).eq.0.or.idiag(1).eq.0) then

Why corrected: Oversized some arrays if i2d = -1 (i.e. 2D with point vortex)

--------------------
--------------------

Number:          134

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Change:

         iflag = 0
         ip3dsurf = 0
         if (nplot3d.lt.0) then
            iflag   = 1
            ip3dsurf = 1


To:

         iflag = 0
         ip3dsurf = 0
         if (nplot3d.lt.0) then
            iflag   = 1
            if (i2d.eq.0) ip3dsurf = 1


Why corrected: ip3dsurf is not really needed for 2D, and prevented smin
               from being output correctly.


Change Date: June 19, 2000


--------------------
--------------------

Number:          135

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    readkey.F

After:

      common /deformz/ beta1,ismooth,negvol

Add:

      common /ghost/ irghost,iwghost

After:

c
c     flag to set whether approximate production term (0) or full
c     production term (1) is used in EASM models 8,9,13,14
c
      iturbprod = 0
      nkey      = nkey + 1

Add:

c
c     flag to read ghost-cell data from restart file (1) or not (0)
c     newer version 6 restart files will have ghost-cell data;
c     restart files from beta version 6 do not, nor do version 5
c     restart files. default is to read ghost-cell data
c
      irghost   = 1
      nkey      = nkey + 1
c
c     flag to write ghost-cell data to restart file (1) or not (0)
c     newer version 6 restart files will have ghost-cell data;
c     restart files from beta version 6 do not, nor do version 5
c     restart files. default is to write ghost-cell data
c
      iwghost   = 1
      nkey      = nkey + 1

After:

      else if (inpstr(lc1:lc2).eq.'iturbprod') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) iturbprod
c

Add:

      else if (inpstr(lc1:lc2).eq.'irghost') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) irghost
c
      else if (inpstr(lc1:lc2).eq.'iwghost') then
         lc2 = lc2 +1
         read(inpstr(lc2:lcl),*) iwghost
c


Why corrected: Add provision for new kewords 


Change Date: June 19, 2000

--------------------
--------------------

Number:          136

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F

Change:

             do j=js,je-jskp,jskp
                do k=ks,ke-kskp,kskp
                   call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                          dx2,dy2,dz2,arci,arcj,arck,1,1,
     .                          j,j+jskp,k,k+kskp,nou,bou,nbuf,
     .                          ibufdim,myid)
                end do
             end do

To:

             jskp2 = je-js
             kskp2 = ke-ks
             do j=js,je-jskp2,jskp2
                do k=ks,ke-kskp2,kskp2
                   call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                          dx2,dy2,dz2,arci,arcj,arck,1,1,
     .                          j,j+jskp2,k,k+kskp2,nou,bou,nbuf,
     .                          ibufdim,myid)
                end do
             end do

Change:

             do j=js,je-jskp,jskp
                do k=ks,ke-kskp,kskp
                   call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                          dx2,dy2,dz2,arci,arcj,arck,idim,idim,
     .                          j,j+jskp,k,k+kskp,nou,bou,nbuf,
     .                          ibufdim,myid)
                end do
             end do

To:

             jskp2 = je-js
             kskp2 = ke-ks
             do j=js,je-jskp2,jskp2
                do k=ks,ke-kskp2,kskp2
                   call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                          dx2,dy2,dz2,arci,arcj,arck,idim,idim,
     .                          j,j+jskp2,k,k+kskp2,nou,bou,nbuf,
     .                          ibufdim,myid)
                end do
             end do

Change:

                do i=is,ie-iskp,iskp
                   do k=ks,ke-kskp,kskp
                      call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                             dx2,dy2,dz2,arci,arcj,arck,i,i+iskp,
     .                             1,1,k,k+kskp,nou,bou,nbuf,
     .                             ibufdim,myid)
                   end do
                end do

To:

                iskp2 = ie-is
                kskp2 = ke-ks
                do i=is,ie-iskp2,iskp2
                   do k=ks,ke-kskp2,kskp2
                      call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                             dx2,dy2,dz2,arci,arcj,arck,i,i+iskp2,
     .                             1,1,k,k+kskp2,nou,bou,nbuf,
     .                             ibufdim,myid)
                   end do
                end do

Change:

                do i=is,ie-iskp,iskp
                   do k=ks,ke-kskp,kskp
                      call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                             dx2,dy2,dz2,arci,arcj,arck,i,i+iskp,
     .                             jdim,jdim,k,k+kskp,nou,bou,nbuf,
     .                             ibufdim,myid)
                   end do
                end do

To:

                iskp2 = ie-is
                kskp2 = ke-ks
                do i=is,ie-iskp2,iskp2
                   do k=ks,ke-kskp2,kskp2
                      call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                             dx2,dy2,dz2,arci,arcj,arck,i,i+iskp2,
     .                             jdim,jdim,k,k+kskp2,nou,bou,nbuf,
     .                             ibufdim,myid)
                   end do
                end do

Change:

                do i=is,ie-iskp,iskp
                   do j=js,je-jskp,jskp
                      call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                             dx2,dy2,dz2,arci,arcj,arck,i,i+iskp,
     .                             j,j+jskp,1,1,nou,bou,nbuf,
     .                             ibufdim,myid)
                   end do
                end do

To:

                iskp2 = ie-is
                jskp2 = je-js
                do i=is,ie-iskp2,iskp2
                   do j=js,je-jskp2,jskp2
                      call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                             dx2,dy2,dz2,arci,arcj,arck,i,i+iskp2,
     .                             j,j+jskp2,1,1,nou,bou,nbuf,
     .                             ibufdim,myid)
                   end do
                end do

Change:

                do i=is,ie-iskp,iskp
                   do j=js,je-jskp,jskp
                      call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                             dx2,dy2,dz2,arci,arcj,arck,i,i+iskp,
     .                             j,j+jskp,kdim,kdim,nou,bou,nbuf,
     .                             ibufdim,myid)
                   end do
                end do

To:

                iskp2 = ie-is
                jskp2 = je-js
                do i=is,ie-iskp2,iskp2
                   do j=js,je-jskp2,jskp2
                      call tfiface(idim,jdim,kdim,dx,dy,dz,dx1,dy1,dz1,
     .                             dx2,dy2,dz2,arci,arcj,arck,i,i+iskp2,
     .                             j,j+jskp2,kdim,kdim,nou,bou,nbuf,
     .                             ibufdim,myid)
                   end do
                end do


Why corrected: Change the range of TFI from the sub-mesh range to the
               segment range, which is typically larger; should result
               in slightly smoother grids and slightly faster execution.


Change Date: June 19, 2000

--------------------
--------------------

Number:          137

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    ffluxv.F, hfluxv.F, gfluxv.F

Change: (in subroutine argument list)

                        nou,bou,nbuf,ibufdim)

To:

                        nou,bou,nbuf,ibufdim,iadv)

Change (in ffluxv):

      if (isklton.gt.0 .and. k.eq.1) then

To:

      if (isklton.gt.0 .and. k.eq.1 .and. iadv.ge.0) then

Change (in gfluxv and hfluxv):

      if (isklton.gt.0 .and. i.eq.1) then

To:

      if (isklton.gt.0 .and. i.eq.1 .and. iadv.ge.0) then

After:

 1922 continue
 1923 continue

Add:

c
      if (iadv .lt. 0) return


Why corrected: When a block is not being advanced, still need to call
               the viscous flux routines to store off vmui/j/k so that
               forces are computed correctly on non advancing blocks;
               but that is all that is needed, so exit when that has
               been done.


Change Date: June 19, 2000


--------------------
--------------------

Number:          138

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    update.F

Change: (in subroutine argument list)

     .                  ibufdim,myid,mblk2nd,maxbl,volk0)

To:

     .                  ibufdim,myid,mblk2nd,maxbl,volk0,iadvance)

After:

      dimension mblk2nd(maxbl),volk0(jdim,idim-1,4)

Add:

      dimension iadvance(maxbl)


Change:

      call af3f(nbl,jdim,kdim,idim,q,vol,qj0,qk0,qi0,dtj,sj,sk,si,
     .          res,vist3d,x,y,z,blank,vmuk,resd,wk,nwork,wk0,1,iover,
     .          vk0,bcj,bck,bci,nou,bou,nbuf,ibufdim,myid,mblk2nd,maxbl,
     .          volk0)

To:

      call af3f(nbl,jdim,kdim,idim,q,vol,qj0,qk0,qi0,dtj,sj,sk,si,
     .          res,vist3d,x,y,z,blank,vmuk,resd,wk,nwork,wk0,1,iover,
     .          vk0,bcj,bck,bci,nou,bou,nbuf,ibufdim,myid,mblk2nd,maxbl,
     .          volk0,iadvance)

Why corrected: Need to pass iadvance down to hfluxv routine, called by 
               af3f (see change 137)

Change Date: June 19, 2000

--------------------
--------------------

Number:          139

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    af3f.F

Change: (in subroutine argument list)

     .                myid,mblk2nd,maxbl,volk0)

To:

     .                myid,mblk2nd,maxbl,volk0,iadvance)

After:

      dimension mblk2nd(maxbl),volk0(jdim,idim-1,4)

Add:

      dimension iadvance(nbl)

Change:

         call hfluxv(i,npl,jdim,kdim,idim,1,wk(iwka),wk(iwkb),wk(iwkc),
     .               res,q,qk0,sk,vol,wk(iwkd),nvtq,wk0,vist3d,vmuk,
     .               vk0,bck,wk(iwke),wk(iwke),wk(iwke),
     .               volk0,nou,bou,nbuf,ibufdim)


To:

         call hfluxv(i,npl,jdim,kdim,idim,1,wk(iwka),wk(iwkb),wk(iwkc),
     .               res,q,qk0,sk,vol,wk(iwkd),nvtq,wk0,vist3d,vmuk,
     .               vk0,bck,wk(iwke),wk(iwke),wk(iwke),
     .               volk0,nou,bou,nbuf,ibufdim,iadvance(nbl))


Why corrected: Need to pass iadvance down to hfluxv routine (see change 137)


Change Date: June 19, 2000

--------------------
--------------------

Number:          140

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    resid.F

Change: (in subroutine argument list)

     .           idefrm)

To:

     .           idefrm,iadvance)

After:

c     Purpose: Compute the residual contributions to the right-hand-side.

Add:

c     Note: viscous flux routines called even if block is not advanced
c     in order to compute and store the vmui/j/k arrays (though these
c     routines are then exited as soon as those arrays are computed)

Change:

      dimension mblk2nd(maxbl),idefrm(maxbl)

To:

      dimension mblk2nd(maxbl),idefrm(maxbl),iadvance(maxbl)

After:

c
c      turbulent viscosity - finest grids only
c

Add:

      if (iadvance(nbl) .ge. 0) then
c

After:

    7 format(1x,29hcomputing residuals for block,i4)

Add:

c
      end if  ! iadvance .ge. 0

After:

c
c     residuals   J direction
c

Add:

      if (iadvance(nbl) .ge. 0) then

After:

  200 continue

Add:

      end if

Change:

         call gfluxv(i,npl,jdim,kdim,idim,res,q,qj0,sj,vol,wk,
     .               nvtq,wj0,vist3d,vmuj,vj0,bcj,xib,tj0,cmuv,
     .               volj0,nou,bou,nbuf,ibufdim)

To:

         call gfluxv(i,npl,jdim,kdim,idim,res,q,qj0,sj,vol,wk,
     .               nvtq,wj0,vist3d,vmuj,vj0,bcj,xib,tj0,cmuv,
     .               volj0,nou,bou,nbuf,ibufdim,iadvance(nbl))

Change:

      if (icyc.eq.1)call l2norm(nbl,0,resd,+1,jdim,kdim,idim,res,vol)

To:

      if (icyc.eq.1 .and. iadvance(nbl).ge.0)
     .   call l2norm(nbl,0,resd,+1,jdim,kdim,idim,res,vol)

After:

c
c     residuals   K direction
c

Add:

      if (iadvance(nbl) .ge. 0) then

After:

  210 continue

Add:

      end if

Change:

         call hfluxv(i,npl,jdim,kdim,idim,0,wk(iwk4),wk(iwk5),wk(iwk6),
     .               res,q,qk0,sk,vol,wk,nvtq,wk0,vist3d,vmuk,vk0,bck,
     .               xib,tk0,cmuv,volk0,nou,bou,nbuf,ibufdim)

To:

         call hfluxv(i,npl,jdim,kdim,idim,0,wk(iwk4),wk(iwk5),wk(iwk6),
     .               res,q,qk0,sk,vol,wk,nvtq,wk0,vist3d,vmuk,vk0,bck,
     .               xib,tk0,cmuv,volk0,nou,bou,nbuf,ibufdim,
     .               iadvance(nbl))

Change:

      if (icyc.eq.1)call l2norm(nbl,0,resd,+1,jdim,kdim,idim,res,vol)

To:

      if (icyc.eq.1 .and. iadvance(nbl).ge.0)
     .   call l2norm(nbl,0,resd,+1,jdim,kdim,idim,res,vol)

After:

c
c     residuals in  I direction
c
      if (i2d.eq.0) then
c

Add:

         if (iadvance(nbl) .ge. 0) then

After:

  300    continue

Add:

         end if

Change:

            call ffluxv(k,npl,jdim,kdim,idim,res,q,qi0,si,vol,wk,
     .                  nvtq,wi0,vist3d,vmui,vi0,bci,xib,ti0,cmuv,
     .                  voli0,nou,bou,nbuf,ibufdim)

To:

            call ffluxv(k,npl,jdim,kdim,idim,res,q,qi0,si,vol,wk,
     .                  nvtq,wi0,vist3d,vmui,vi0,bci,xib,ti0,cmuv,
     .                  voli0,nou,bou,nbuf,ibufdim,iadvance(nbl))

Change:

         if (icyc.eq.1)call l2norm(nbl,0,resd,+1,jdim,kdim,idim,res,vol)
c
      end if


To:

         if (icyc.eq.1 .and. iadvance(nbl).ge.0)
     .      call l2norm(nbl,0,resd,+1,jdim,kdim,idim,res,vol)
c
      end if
c
      if (iadvance(nbl) .ge. 0) then

After:

  219       continue
         end if

Add:

      end if


Why corrected: Part of general iadvance fixup.

Change Date: June 19, 2000

--------------------
--------------------

Number:          141

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

Delete:

         if (iadvance(nbl).lt.0) go to 5000

Delete:

         if (iadvance(nbl).lt.0) go to 5010

Delete:

         if (iadvance(nbl).lt.0) go to 5020

Delete:

      if (iadvance(nbl).lt.0) go to 5025

Delete:

         if (iadvance(nbl).lt.0) go to 5030

Change:

            if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0 .and.
     .         (levelg(nbl).ge.lglobal .and.

To:
            if (myid.eq.mblk2nd(nbl) .and. (levelg(nbl).ge.lglobal .and.


Delete:

      if (iadvance(nbl).lt.0) go to 5090

Delete:

      if (iadvance(nbl).lt.0) go to 6988

Delete:

      if (iadvance(nbl).lt.0) go to 8000

Change:

         iprerot = 1
c
         if (real(dt).gt.0.0) then

To:

         iprerot = 1
c
         if (real(dt).gt.0.0 .and. iadvance(nbl).ge.0) then

Change:

         if (ifluxa.gt.0) then

To:

         if (ifluxa.gt.0 .and. iadvance(nbl).ge.0) then

Change:

         call resid(nbl,ntime,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
     .              w(lqi0),w(lsj),w(lsk),w(lsi),w(lvol),w(ldtj),w(lx),
     .              w(ly),w(lz),w(lvis),w(lsni0),w(lsnk0),w(lsni0),
     .              wk(lres),wk(lwj0),wk(lwk0),wk(lwi0),wk(lvmuk),
     .              wk(lvmuj),wk(lvmui),wk(ltot),lsafe,
     .              isf,iw,wk,deltat(level),w(lblk),iovrlp(nbl),
     .              nblendg,nblstat,nblstag,w(lxib),w(lsig),
     .              w(lsqtq),w(lg),w(ltj0),w(ltk0),w(lti0),
     .              w(lxkb),w(lnbl),w(lvj0),w(lvk0),w(lvi0),w(lbcj),
     .              w(lbck),w(lbci),nt,sumn1,sumn2,negn1,negn2,w(lux),
     .              w(lxib2),w(lcmuv),w(lvolj0),w(lvolk0),w(lvoli0),
     .              nou,bou,nbuf,ibufdim,myid,mblk2nd,maxbl,maxseg,
     .              nbci0,nbcj0,nbck0,nbcidim,nbcjdim,nbckdim,ibcinfo,
     .              jbcinfo,kbcinfo,vormax,ivmax,jvmax,kvmax,idefrm)

To:

         call resid(nbl,ntime,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
     .              w(lqi0),w(lsj),w(lsk),w(lsi),w(lvol),w(ldtj),w(lx),
     .              w(ly),w(lz),w(lvis),w(lsni0),w(lsnk0),w(lsni0),
     .              wk(lres),wk(lwj0),wk(lwk0),wk(lwi0),wk(lvmuk),
     .              wk(lvmuj),wk(lvmui),wk(ltot),lsafe,
     .              isf,iw,wk,deltat(level),w(lblk),iovrlp(nbl),
     .              nblendg,nblstat,nblstag,w(lxib),w(lsig),
     .              w(lsqtq),w(lg),w(ltj0),w(ltk0),w(lti0),
     .              w(lxkb),w(lnbl),w(lvj0),w(lvk0),w(lvi0),w(lbcj),
     .              w(lbck),w(lbci),nt,sumn1,sumn2,negn1,negn2,w(lux),
     .              w(lxib2),w(lcmuv),w(lvolj0),w(lvolk0),w(lvoli0),
     .              nou,bou,nbuf,ibufdim,myid,mblk2nd,maxbl,maxseg,
     .              nbci0,nbcj0,nbck0,nbcidim,nbcjdim,nbckdim,ibcinfo,
     .              jbcinfo,kbcinfo,vormax,ivmax,jvmax,kvmax,idefrm,
     .              iadvance)

Change:

c
c        add 2nd order time terms and subiteration terms
c
         if (real(dt).gt.0.e0) then
            call resadd(jdim,kdim,idim,w(lq),w(lqc0),w(ldqc0),

To:

c
c        add 2nd order time terms and subiteration terms
c
         if (real(dt).gt.0.e0 .and. iadvance(nbl).ge.0) then
            call resadd(jdim,kdim,idim,w(lq),w(lqc0),w(ldqc0),

Change:

               call tau(mgflag,nbl,jdim,kdim,idim,w(lq),wk(lres),
     .                  w(lq1),w(lqr),lw,w,nou,bou,nbuf,ibufdim,maxbl,
     .                  maxgr,nblock,igridg,nblcg,jsg,ksg,isg,
     .                  jeg,keg,ieg,iemg)

To:

               if (iadvance(nbl).ge.0) then
               call tau(mgflag,nbl,jdim,kdim,idim,w(lq),wk(lres),
     .                  w(lq1),w(lqr),lw,w,nou,bou,nbuf,ibufdim,maxbl,
     .                  maxgr,nblock,igridg,nblcg,jsg,ksg,isg,
     .                  jeg,keg,ieg,iemg)
               end if

After:

         if(nbl.eq.nblendg) iaccnt = 0
c
      end if

Add:

c
      if (iadvance(nbl).lt.0) go to 7999

Change:

            call update(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
     .                  w(lsj),w(lsk),w(lsi),w(lvol),w(ldtj),w(lvis),
     .                  w(lblk),w(lx),w(ly),w(lz), wk(lres),wk(lwk0),
     .                  wk(lvmuk),wk(lvmuj),wk(lvmui),wk(ltot),lsafe,
     .                  nbl,iovrlp(nbl),w(lvk0),w(lbcj),w(lbck),w(lbci),
     .                  nou,bou,nbuf,ibufdim,myid,mblk2nd,maxbl,
     .                  w(lvolk0))

To:

            call update(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
     .                  w(lsj),w(lsk),w(lsi),w(lvol),w(ldtj),w(lvis),
     .                  w(lblk),w(lx),w(ly),w(lz), wk(lres),wk(lwk0),
     .                  wk(lvmuk),wk(lvmuj),wk(lvmui),wk(ltot),lsafe,
     .                  nbl,iovrlp(nbl),w(lvk0),w(lbcj),w(lbck),w(lbci),
     .                  nou,bou,nbuf,ibufdim,myid,mblk2nd,maxbl,
     .                  w(lvolk0),iadvance)


Before:

c
      if (isklton.gt.0) then
         call writ_buf(nbl,11,nou,bou,nbuf,ibufdim,myhost,myid,
     .                 mycomm,mblk2nd,maxbl)
      end if
c
 8000 continue

Add:

 7999 continue

Change:

c              add corrections to chimera grids
c
               if (iovrlp(nblf).eq.1) then
                  if (isklton.eq.1) then
                     nou(1) = min(nou(1)+1,ibufdim)
                     write(bou(nou(1),1),2060) nblf
                  end if
                  ldim=5
                  call intrbc(w(lq),jdim,kdim,idim,nblf,ldim,maxbl,
     .                        iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                        iiig,jjig,kkig,qb,w(lqj0),w(lqk0),
     .                        w(lqi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                        bou,nbuf,ibufdim,0)

To:

c              add corrections to chimera grids
c
               if (iovrlp(nblf).eq.1) then
                  if (isklton.eq.1) then
                     nou(1) = min(nou(1)+1,ibufdim)
                     write(bou(nou(1),1),2060) nblf
                  end if
                  ldim=5
                  call intrbc(w(lq),jdim,kdim,idim,nblf,ldim,maxbl,
     .                        iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                        iiig,jjig,kkig,qb,w(lqj0),w(lqk0),
     .                        w(lqi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                        bou,nbuf,ibufdim,1)
c                 turbulence quantities
                  if(iviscg(nblf,1).ge.2 .or. iviscg(nblf,2).ge.2 .or.
     .               iviscg(nblf,3).ge.2) then
                     ldim = 1
                     call intrbc(w(lvis),jdim,kdim,idim,nblf,ldim,maxbl,
     .                           iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                           iiig,jjig,kkig,qb,w(lvj0),w(lvk0),
     .                           w(lvi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                           bou,nbuf,ibufdim,1)
                  end if
                  if(iviscg(nblf,1).ge.4 .or. iviscg(nblf,2).ge.4 .or.
     .               iviscg(nblf,3).ge.4) then
                     ldim = 2
                     call intrbc(w(lxib),jdim,kdim,idim,nblf,ldim,maxbl,
     .                           iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                           iiig,jjig,kkig,qb,w(ltj0),w(ltk0),
     .                           w(lti0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                           bou,nbuf,ibufdim,1)
                  end if

Change:

                  call wrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
     .            w(lqi0),ncycmax,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .            cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,cfttotw,
     .            rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),w(lxib),
     .            w(lsnk0),w(lsni0),w(lxkb),w(lnbl),w(lcmuv),
c   ***CGNSstart
c    .            thetay,maxbl,myid,myhost,mycomm,mblk2nd)
     .            thetay,maxbl,myid,myhost,mycomm,mblk2nd,igrid,wk,
     .            idima,jdima,kdima,w(lbcj),w(lbck),w(lbci),w(lvj0),
     .            w(lvk0),w(lvi0),w(ltj0),w(ltk0),w(lti0),iovrlp,qb,
     .            iipntsg,lig,iitot)
c   ***CGNSend

To:

                  call wrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
     .            w(lqi0),ncycmax,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .            cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,cfttotw,
     .            rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),w(lxib),
     .            w(lsnk0),w(lsni0),w(lxkb),w(lnbl),w(lcmuv),
c   ***CGNSstart
c    .            thetay,maxbl,myid,myhost,mycomm,mblk2nd)
     .            thetay,maxbl,myid,myhost,mycomm,mblk2nd,igrid,wk,
     .            idima,jdima,kdima,w(lbcj),w(lbck),w(lbci),w(lvj0),
     .            w(lvk0),w(lvi0),w(ltj0),w(ltk0),w(lti0))
c   ***CGNSend

Change:

                  call wrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
     .            w(lqi0),ncycmax,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .            cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,cfttotw,
     .            rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),w(lxib),
     .            w(lsnk0),w(lsni0),w(lxkb),w(lnbl),w(lcmuv),
c   ***CGNSstart
c    .            thetay,maxbl,myid,myhost,mycomm,mblk2nd)
     .            thetay,maxbl,myid,myhost,mycomm,mblk2nd,igrid,wk,
     .            idima,jdima,kdima,w(lbcj),w(lbck),w(lbci),w(lvj0),
     .            w(lvk0),w(lvi0),w(ltj0),w(ltk0),w(lti0),iovrlp,qb,
     .            iipntsg,lig,iitot)
     .            w(lvk0),w(lvi0),w(ltj0),w(ltk0),w(lti0))

To:

                  call wrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
     .            w(lqi0),ncycmax,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .            cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,cfttotw,
     .            rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),w(lxib),
     .            w(lsnk0),w(lsni0),w(lxkb),w(lnbl),w(lcmuv),
c   ***CGNSstart
c    .            thetay,maxbl,myid,myhost,mycomm,mblk2nd)
     .            thetay,maxbl,myid,myhost,mycomm,mblk2nd,igrid,wk,
     .            idima,jdima,kdima,w(lbcj),w(lbck),w(lbci),w(lvj0),
     .            w(lvk0),w(lvi0),w(ltj0),w(ltk0),w(lti0))


Why corrected: Part of general iadvance fixup.

Change Date: June 19, 2000


--------------------
--------------------

Number:          142

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    pre_bc.F

Delete:

            if (iadvance(nbl).lt.0) go to 6909

Why corrected: Part of general iadvance fixup.

Change Date: June 19, 2000

--------------------
--------------------

Number:          143

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    qout.F

Change:

               if (iadvance(nbl).ge.0) then
c
                  if (level.eq.levelg(nbl)) then
                     if (mblk2nd(nbl).eq.myid) then
                        call lead(nbl,lw,lw2,maxbl)
                        call bc(1,nbl,lw,lw2,w,mgwk,wk,nwork,
     .                          clwuse,nou,bou,nbuf,ibufdim,maxbl,
     .                          maxgr,maxseg,itrans,irotat,idefrm,
     .                          igridg,nblg,nbci0,nbcj0,nbck0,nbcidim,
     .                          nbcjdim,nbckdim,ibcinfo,jbcinfo,
     .                          kbcinfo,bcfilei,bcfilej,bcfilek,
     .                          lwdat,myid,idimg,jdimg,kdimg,bcfiles,
     .                          mxbcfil)
                     end if
                  end if
               end if

To:

c              need to call even for blocks not advanced
               if (level.eq.levelg(nbl)) then
                  if (mblk2nd(nbl).eq.myid) then
                     call lead(nbl,lw,lw2,maxbl)
                     call bc(1,nbl,lw,lw2,w,mgwk,wk,nwork,
     .                       clwuse,nou,bou,nbuf,ibufdim,maxbl,
     .                       maxgr,maxseg,itrans,irotat,idefrm,
     .                       igridg,nblg,nbci0,nbcj0,nbck0,nbcidim,
     .                       nbcjdim,nbckdim,ibcinfo,jbcinfo,
     .                       kbcinfo,bcfilei,bcfilej,bcfilek,
     .                       lwdat,myid,idimg,jdimg,kdimg,bcfiles,
     .                       mxbcfil)
                  end if
               end if

Change:

c
c           call qface to install face-center values in
c           the qi0/qj0/qk0 arrays
c
            do nbl=1,nblock
               if (iadvance(nbl).ge.0) then
                  if (level.eq.levelg(nbl)) then
                     if (mblk2nd(nbl).eq.myid) then
                        call lead(nbl,lw,lw2,maxbl)
                        ldim = 5
                        call qface(jdim,kdim,idim,w(lq),w(lqj0),
     .                             w(lqk0),w(lqi0),w(lbcj),w(lbck),
     .                             w(lbci),w(lblk),ldim)
                        if (ivmx.ge.2) then
                           ldim = 1
                           call qface(jdim,kdim,idim,w(lvis),w(lvj0),
     .                                w(lvk0),w(lvi0),w(lbcj),w(lbck),
     .                                w(lbci),w(lblk),ldim)
                        end if
                     end if
                  end if
               end if

To:

c
c           call qface to install face-center values in
c           the qi0/qj0/qk0 arrays
c
            do nbl=1,nblock
               if (level.eq.levelg(nbl)) then
                  if (mblk2nd(nbl).eq.myid) then
                     call lead(nbl,lw,lw2,maxbl)
                     ldim = 5
                     call qface(jdim,kdim,idim,w(lq),w(lqj0),
     .                          w(lqk0),w(lqi0),w(lbcj),w(lbck),
     .                          w(lbci),w(lblk),ldim)
                     if (ivmx.ge.2) then
                        ldim = 1
                        call qface(jdim,kdim,idim,w(lvis),w(lvj0),
     .                             w(lvk0),w(lvi0),w(lbcj),w(lbck),
     .                             w(lbci),w(lblk),ldim)
                     end if
                  end if
               end if


Why corrected: Part of general iadvance fixup.

Change Date: June 19, 2000


--------------------
--------------------

Number:          144

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    resp.F

Delete:

            if (iadvance(nbl1).lt.0) go to 8000

Delete:

            if (iadvance(nbl1).lt.0) go to 8050

Why corrected: Part of general iadvance fixup.

Change Date: June 19, 2000

--------------------
--------------------

Number:          145

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):   rrest.F

Change (in subroutine argument list):

     .                 igrid,wk,idima,jdima,kdima,iovrlp,qb,iipntsg,
     .                 lig,iitot)

To:

     .                 igrid,wk,idima,jdima,kdima,vj0,vk0,vi0,
     .                 tj0,tk0,ti0)

Change:

      dimension q(jdim,kdim,idim,5),qi0(jdim,kdim,5),
     .          qj0(kdim,idim-1,5), qk0(jdim,idim-1,5)

To:

      dimension q(jdim,kdim,idim,5),qi0(jdim,kdim,5,4),
     .          qj0(kdim,idim-1,5,4), qk0(jdim,idim-1,5,4),
     .          vj0(kdim,idim-1,1,4),vk0(jdim,idim-1,1,4),
     .          vi0(jdim,kdim,1,4),tj0(kdim,idim-1,2,4),
     .          tk0(jdim,idim-1,2,4),ti0(jdim,kdim,2,4)

Delete:

      dimension qb(iitot,5,3),iipntsg(maxbl),lig(maxbl),iovrlp(maxbl),
     .          mytag_qb(8)

After:

      common /conversion/ radtodeg

Add:

      common /ghost/ irghost,iwghost

Change:

      mytag_qb(1) = 0
      do ll=2,8
        mytag_qb(ll) = mytag_qb(ll-1) + maxbl
      end do


To:

      itag_qj0     = itag_cmuv    + ioffset
      itag_qk0     = itag_qj0     + ioffset
      itag_qi0     = itag_qk0     + ioffset
      itag_vj0     = itag_qi0     + ioffset
      itag_vk0     = itag_vj0     + ioffset
      itag_vi0     = itag_vk0     + ioffset
      itag_tj0     = itag_vi0     + ioffset
      itag_tk0     = itag_tj0     + ioffset
      itag_ti0     = itag_tk0     + ioffset

After:

      jki2  = 2*jki

Add:

      jk20  = jdim*kdim*20
      ki20  = kdim*idim1*20
      ji20  = jdim*idim1*20
      jk4   = jdim*kdim*4
      ki4   = kdim*idim1*4
      ji4   = jdim*idim1*4
      jk8   = jdim*kdim*8
      ki8   = kdim*idim1*8
      ji8   = jdim*idim1*8

After:

         read(2) ((((q(j,k,i,l),j=1,jdim1),k=1,kdim1),i=1,idim1),l=1,5)

Add:

        if (irghost .ne. 0)
     .   read(2) ((((qi0(j,k,l,m),j=1,jdim),k=1,kdim),l=1,5),m=1,4),
     .           ((((qj0(k,i,l,m),k=1,kdim),i=1,idim1),l=1,5),m=1,4),
     .           ((((qk0(j,i,l,m),j=1,jdim),i=1,idim1),l=1,5),m=1,4)

After:

      mytag = itag_q + nbl
      if (myid .eq. myhost) then
         call MPI_Send(q,jki5,MY_MPI_REAL,
     .                 nd_dest,mytag,mycomm,ierr)
      else if (myid .eq. mblk2nd(nbl)) then
         call MPI_Recv(q,jki5,MY_MPI_REAL,
     .                 myhost,mytag,mycomm,istat,ierr)
      end if

Add:

c
      if (irghost .ne.0) then
         mytag = itag_qj0 + nbl
         if (myid .eq. myhost) then
            call MPI_Send(qj0,ki20,MY_MPI_REAL,
     .                    nd_dest,mytag,mycomm,ierr)
         else if (myid .eq. mblk2nd(nbl)) then
            call MPI_Recv(qj0,ki20,MY_MPI_REAL,
     .                    myhost,mytag,mycomm,istat,ierr)
         end if
c
         mytag = itag_qk0 + nbl
         if (myid .eq. myhost) then
            call MPI_Send(qk0,ji20,MY_MPI_REAL,
     .                    nd_dest,mytag,mycomm,ierr)
         else if (myid .eq. mblk2nd(nbl)) then
            call MPI_Recv(qk0,ji20,MY_MPI_REAL,
     .                    myhost,mytag,mycomm,istat,ierr)
         end if
c
         mytag = itag_qi0 + nbl
         if (myid .eq. myhost) then
            call MPI_Send(qi0,jk20,MY_MPI_REAL,
     .                    nd_dest,mytag,mycomm,ierr)
         else if (myid .eq. mblk2nd(nbl)) then
            call MPI_Recv(qi0,jk20,MY_MPI_REAL,
     .                    myhost,mytag,mycomm,istat,ierr)
         end if
      end if

After:

      if (iv1.ge.2 .or. iv2.ge.2 .or. iv3.ge.2) then
#if defined DIST_MPI
         if (myid.eq.myhost) then
#endif
c   ***CGNSstart
         if (icgns .ne. 1) then
c   ***CGNSend
         read(2) (((dum,j=1,jdim1),k=1,kdim1),i=1,idim1)

Add:

         if (irghost .ne. 0)
     .   read(2) ((((dum,j=1,jdim),k=1,kdim),l=1,1),m=1,4),
     .           ((((dum,k=1,kdim),i=1,idim1),l=1,1),m=1,4),
     .           ((((dum,j=1,jdim),i=1,idim1),l=1,1),m=1,4)

After:

      if (iv1.ge.4 .or. iv2.ge.4 .or. iv3.ge.4) then
#if defined DIST_MPI
         if (myid.eq.myhost) then
#endif
c   ***CGNSstart
         if (icgns .ne. 1) then
c   ***CGNSend
         read(2) ((((dum,j=1,jdim1),k=1,kdim1),i=1,idim1),
     .           m=1,2)

Add:

         if (irghost .ne. 0)
     .   read(2) ((((dum,j=1,jdim),k=1,kdim),l=1,2),m=1,4),
     .           ((((dum,k=1,kdim),i=1,idim1),l=1,2),m=1,4),
     .           ((((dum,j=1,jdim),i=1,idim1),l=1,2),m=1,4)

After:

         read(2) (((vist3d(j,k,i),j=1,jdim1),k=1,kdim1),i=1,idim1)

Add:

         if (irghost .ne. 0)
     .   read(2) ((((vi0(j,k,l,m),j=1,jdim),k=1,kdim),l=1,1),m=1,4),
     .           ((((vj0(k,i,l,m),k=1,kdim),i=1,idim1),l=1,1),m=1,4),
     .           ((((vk0(j,i,l,m),j=1,jdim),i=1,idim1),l=1,1),m=1,4)

After:

         mytag = itag_qv + nbl
         if (myid .eq. myhost) then
            call MPI_Send(vist3d,jki,MY_MPI_REAL,
     .                    nd_dest,mytag,mycomm,ierr)
         else if (myid .eq. mblk2nd(nbl)) then
            call MPI_Recv(vist3d,jki,MY_MPI_REAL,
     .                    myhost,mytag,mycomm,istat,ierr)
         end if

Add:

         if (irghost .ne.0) then
            mytag = itag_vj0 + nbl
            if (myid .eq. myhost) then
               call MPI_Send(vj0,ki4,MY_MPI_REAL,
     .                       nd_dest,mytag,mycomm,ierr)
            else if (myid .eq. mblk2nd(nbl)) then
               call MPI_Recv(vj0,ki4,MY_MPI_REAL,
     .                       myhost,mytag,mycomm,istat,ierr)
            end if
c
            mytag = itag_vk0 + nbl
            if (myid .eq. myhost) then
               call MPI_Send(vk0,ji4,MY_MPI_REAL,
     .                       nd_dest,mytag,mycomm,ierr)
            else if (myid .eq. mblk2nd(nbl)) then
               call MPI_Recv(vk0,ji4,MY_MPI_REAL,
     .                       myhost,mytag,mycomm,istat,ierr)
            end if
c
            mytag = itag_vi0 + nbl
            if (myid .eq. myhost) then
               call MPI_Send(vi0,jk4,MY_MPI_REAL,
     .                       nd_dest,mytag,mycomm,ierr)
            else if (myid .eq. mblk2nd(nbl)) then
               call MPI_Recv(vi0,jk4,MY_MPI_REAL,
     .                       myhost,mytag,mycomm,istat,ierr)
            end if
         end if

After:

        read(2) ((((tursav(j,k,i,m),j=1,jdim1),k=1,kdim1),i=1,idim1),
     .          m=1,2)

Add:

         if (irghost .ne. 0)
     .   read(2) ((((ti0(j,k,l,m),j=1,jdim),k=1,kdim),l=1,2),m=1,4),
     .           ((((tj0(k,i,l,m),k=1,kdim),i=1,idim1),l=1,2),m=1,4),
     .           ((((tk0(j,i,l,m),j=1,jdim),i=1,idim1),l=1,2),m=1,4)

After:

        mytag = itag_qt + nbl
        if (myid .eq. myhost) then
            call MPI_Send(tursav,jki2,MY_MPI_REAL,
     .                    nd_dest,mytag,mycomm,ierr)
        else if (myid .eq. mblk2nd(nbl)) then
            call MPI_Recv(tursav,jki2,MY_MPI_REAL,
     .                    myhost,mytag,mycomm,istat,ierr)
        end if

Add:

         if (irghost .ne.0) then
            mytag = itag_tj0 + nbl
            if (myid .eq. myhost) then
               call MPI_Send(tj0,ki8,MY_MPI_REAL,
     .                       nd_dest,mytag,mycomm,ierr)
            else if (myid .eq. mblk2nd(nbl)) then
               call MPI_Recv(tj0,ki8,MY_MPI_REAL,
     .                       myhost,mytag,mycomm,istat,ierr)
            end if
c
            mytag = itag_tk0 + nbl
            if (myid .eq. myhost) then
               call MPI_Send(tk0,ji8,MY_MPI_REAL,
     .                       nd_dest,mytag,mycomm,ierr)
            else if (myid .eq. mblk2nd(nbl)) then
               call MPI_Recv(tk0,ji8,MY_MPI_REAL,
     .                       myhost,mytag,mycomm,istat,ierr)
            end if
c
            mytag = itag_ti0 + nbl
            if (myid .eq. myhost) then
               call MPI_Send(ti0,jk8,MY_MPI_REAL,
     .                       nd_dest,mytag,mycomm,ierr)
            else if (myid .eq. mblk2nd(nbl)) then
               call MPI_Recv(ti0,jk8,MY_MPI_REAL,
     .                       myhost,mytag,mycomm,istat,ierr)
            end if
         end if

Delete:

c
c     read qb array for overset grids
c
      if(iovrlp(nbl) .gt. 0) then
          .
          .
          .
    (intermediate lines not shown)
          .
          .
          .
      end if

Why corrected: Change restart file to include ghost-cell data

Change Date: June 19, 2000

--------------------
--------------------

Number:          146

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):   wrest.F

Change (in subroutine argument list):

     .                 tj0,tk0,ti0,iovrlp,qb,iipntsg,lig,iitot)

To:

     .                 tj0,tk0,ti0)

Delete:

      dimension qb(iitot,5,3),iipntsg(maxbl),lig(maxbl),iovrlp(maxbl),
     .          mytag_qb(8)

After:

      common /maxiv/ ivmx

Add:

      common /ghost/ irghost,iwghost

Change:

c   ***CGNSstart
      if (icgns .eq. 1) then
      itag_bci   = itag_cmuv  + ioffset
      itag_bcj   = itag_bci   + ioffset
      itag_bck   = itag_bcj   + ioffset
      itag_qi0   = itag_bck   + ioffset
      itag_qj0   = itag_qi0   + ioffset
      itag_qk0   = itag_qj0   + ioffset
      itag_vi0   = itag_qk0   + ioffset
      itag_vj0   = itag_vi0   + ioffset
      itag_vk0   = itag_vj0   + ioffset
      itag_ti0   = itag_vk0   + ioffset
      itag_tj0   = itag_ti0   + ioffset
      itag_tk0   = itag_tj0   + ioffset
      end if
c   ***CGNSend
      mytag_qb(1) = 0
      do ll=2,8
        mytag_qb(ll) = mytag_qb(ll-1) + maxbl
      end do
 

To:

      itag_bci   = itag_cmuv  + ioffset
      itag_bcj   = itag_bci   + ioffset
      itag_bck   = itag_bcj   + ioffset
      itag_qi0   = itag_bck   + ioffset
      itag_qj0   = itag_qi0   + ioffset
      itag_qk0   = itag_qj0   + ioffset
      itag_vi0   = itag_qk0   + ioffset
      itag_vj0   = itag_vi0   + ioffset
      itag_vk0   = itag_vj0   + ioffset
      itag_ti0   = itag_vk0   + ioffset
      itag_tj0   = itag_ti0   + ioffset
      itag_tk0   = itag_tj0   + ioffset

Change:

c   ***CGNSstart
      if (icgns .eq. 1) then
      jk2   = jdim*kdim*2
      ki2   = kdim*idim1*2
      ji2   = jdim*idim1*2
      jk20  = jdim*kdim*20
      ki20  = kdim*idim1*20
      ji20  = jdim*idim1*20
      jk4   = jdim*kdim*4
      ki4   = kdim*idim1*4
      ji4   = jdim*idim1*4
      jk8   = jdim*kdim*8
      ki8   = kdim*idim1*8
      ji8   = jdim*idim1*8
      end if
c   ***CGNSend

To:

      jk2   = jdim*kdim*2
      ki2   = kdim*idim1*2
      ji2   = jdim*idim1*2
      jk20  = jdim*kdim*20
      ki20  = kdim*idim1*20
      ji20  = jdim*idim1*20
      jk4   = jdim*kdim*4
      ki4   = kdim*idim1*4
      ji4   = jdim*idim1*4
      jk8   = jdim*kdim*8
      ki8   = kdim*idim1*8
      ji8   = jdim*idim1*8

After:

      else if (myid .eq. myhost) then
         mytag = itag_bck + nbl
         call MPI_Recv(bck,ji2,MY_MPI_REAL,
     .                 nd_srce,mytag,mycomm,istat,ierr)
      end if

Add:

      end if
c   ***CGNSend

Change:

         else if (myid .eq. myhost) then
            mytag = itag_qk0 + nbl
            call MPI_Recv(qk0,ji20,MY_MPI_REAL,
     .                    nd_srce,mytag,mycomm,istat,ierr)
         end if
      end if
      end if
c   ***CGNSend

To:

         else if (myid .eq. myhost) then
            mytag = itag_qk0 + nbl
            call MPI_Recv(qk0,ji20,MY_MPI_REAL,
     .                    nd_srce,mytag,mycomm,istat,ierr)
         end if
      end if

After:

         write(2) ((((q(j,k,i,l),j=1,jdim1),k=1,kdim1),i=1,idim1),l=1,5)

Add:

         if (iwghost .ne. 0)
     .   write(2) ((((qi0(j,k,l,m),j=1,jdim),k=1,kdim),l=1,5),m=1,4),
     .            ((((qj0(k,i,l,m),k=1,kdim),i=1,idim1),l=1,5),m=1,4),
     .            ((((qk0(j,i,l,m),j=1,jdim),i=1,idim1),l=1,5),m=1,4)

Change:

         else if (myid .eq. myhost) then
            mytag = itag_qv + nbl
            call MPI_Recv(vist3d,jki,MY_MPI_REAL,
     .                    nd_srce,mytag,mycomm,istat,ierr)
         end if
c   ***CGNSstart
         if (icgns .eq. 1) then

To:

         else if (myid .eq. myhost) then
            mytag = itag_qv + nbl
            call MPI_Recv(vist3d,jki,MY_MPI_REAL,
     .                    nd_srce,mytag,mycomm,istat,ierr)
         end if

Change:

            else if (myid .eq. myhost) then
               mytag = itag_vk0 + nbl
               call MPI_Recv(vk0,ji4,MY_MPI_REAL,
     .                       nd_srce,mytag,mycomm,istat,ierr)
            end if
         end if
         end if
c   ***CGNSend

To:

            else if (myid .eq. myhost) then
               mytag = itag_vk0 + nbl
               call MPI_Recv(vk0,ji4,MY_MPI_REAL,
     .                       nd_srce,mytag,mycomm,istat,ierr)
            end if
         end if

After:

         write(2) (((vist3d(j,k,i),j=1,jdim1),k=1,kdim1),i=1,idim1)

Add:

         if (iwghost .ne. 0)
     .   write(2) ((((vi0(j,k,l,m),j=1,jdim),k=1,kdim),l=1,1),m=1,4),
     .            ((((vj0(k,i,l,m),k=1,kdim),i=1,idim1),l=1,1),m=1,4),
     .            ((((vk0(j,i,l,m),j=1,jdim),i=1,idim1),l=1,1),m=1,4)

Change:

         else if (myid .eq. myhost) then
            mytag = itag_qt + nbl
            call MPI_Recv(tursav,jki2,MY_MPI_REAL,
     .                    nd_srce,mytag,mycomm,istat,ierr)
         end if
c   ***CGNSstart
         if (icgns .eq. 1) then

To:

         else if (myid .eq. myhost) then
            mytag = itag_qt + nbl
            call MPI_Recv(tursav,jki2,MY_MPI_REAL,
     .                    nd_srce,mytag,mycomm,istat,ierr)
         end if

Change:

            else if (myid .eq. myhost) then
               mytag = itag_tk0 + nbl
               call MPI_Recv(tk0,ji8,MY_MPI_REAL,
     .                       nd_srce,mytag,mycomm,istat,ierr)
            end if
         end if
         end if
c   ***CGNSend

To:

            else if (myid .eq. myhost) then
               mytag = itag_tk0 + nbl
               call MPI_Recv(tk0,ji8,MY_MPI_REAL,
     .                       nd_srce,mytag,mycomm,istat,ierr)
            end if
         end if

After:

         write(2) ((((tursav(j,k,i,m),j=1,jdim1),k=1,kdim1),i=1,idim1),
     .            m=1,2)

Add:

         if (iwghost .ne. 0)
     .   write(2) ((((ti0(j,k,l,m),j=1,jdim),k=1,kdim),l=1,2),m=1,4),
     .            ((((tj0(k,i,l,m),k=1,kdim),i=1,idim1),l=1,2),m=1,4),
     .            ((((tk0(j,i,l,m),j=1,jdim),i=1,idim1),l=1,2),m=1,4)

Delete:

c     write qb array for overset grids
c
      if(iovrlp(nbl) .gt. 0) then
c
        .
        .
        .
      (intermediate lines not shown)
        .
        .
        .
      end if


Why corrected: Change restart file to include ghost-cell data

Change Date: June 19, 2000

--------------------
--------------------

Number:          147

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F

After:

      common /deformz/ beta1,ismooth,negvol

Add:

      common /ghost/ irghost,iwghost

Change:

            call rrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
     .                 ncycmax,ntr,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .                 cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,
     .                 cfttotw,rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),
     .                 w(lxib),w(lsnk0),w(lsni0),w(lxkb),w(lnbl),
     .                 w(lcmuv),maxbl,mblk2nd,myid,myhost,mycomm,
c   ***CGNSstart
c    .                 nou,bou,nbuf,ibufdim)
     .                 nou,bou,nbuf,ibufdim,igrid,
     .                 wk,idima,jdima,kdima,iovrlp,qb,iipntsg,
     .                 lig,iitot)
c   ***CGNSend

To:

            call rrest(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
     .                 ncycmax,ntr,rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,
     .                 cmxw,cmyw,cmzw,fmdotw,cftmomw,cftpw,cftvw,
     .                 cfttotw,rmstr1,rmstr2,nneg1,nneg2,iskipz,w(lvis),
     .                 w(lxib),w(lsnk0),w(lsni0),w(lxkb),w(lnbl),
     .                 w(lcmuv),maxbl,mblk2nd,myid,myhost,mycomm,
c   ***CGNSstart
c    .                 nou,bou,nbuf,ibufdim)
     .                 nou,bou,nbuf,ibufdim,igrid,
     .                 wk,idima,jdima,kdima,w(lvj0),w(lvk0),w(lvi0),
     .                 w(ltj0),w(ltk0),w(lti0))
c   ***CGNSend

Change:

         if (irest.eq.0) then
            if (mblk2nd(nbl).eq.myid) then
               call lead(nbl,lw,lw2,maxbl)
               if (isklton.eq.1) then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),350) nbl
               end if
               ldim = 5
               need  = (idim+1)*(jdim+1)*(kdim+1)*5
               if (need .gt. nwork) then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),'(''stopping...not enough work'',
     .            '' space for subroutine intrbc (q)'')')
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),'(''need, have '',2i11)')
     .            need,nwork
                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
               end if
               call intrbc(w(lq),jdim,kdim,idim,nbl,ldim,maxbl,
     .                     iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                     iiig,jjig,kkig,qb,w(lqj0),w(lqk0),
     .                     w(lqi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                     bou,nbuf,ibufdim,1)
c              turbulence quantities
               if(iviscg(nbl,1).ge.2 .or. iviscg(nbl,2).ge.2 .or.
     .            iviscg(nbl,3).ge.2) then
                  ldim = 1
                  call intrbc(w(lvis),jdim,kdim,idim,nbl,ldim,maxbl,
     .                        iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                        iiig,jjig,kkig,qb,w(lvj0),w(lvk0),
     .                        w(lvi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                        bou,nbuf,ibufdim,1)
               end if
               if(iviscg(nbl,1).ge.4 .or. iviscg(nbl,2).ge.4 .or.
     .            iviscg(nbl,3).ge.4) then
                  ldim = 2
                  call intrbc(w(lxib),jdim,kdim,idim,nbl,ldim,maxbl,
     .                        iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                        iiig,jjig,kkig,qb,w(ltj0),w(ltk0),
     .                        w(lti0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                        bou,nbuf,ibufdim,1)
               end if
            end if
         end if


To:

         if (mblk2nd(nbl).eq.myid) then
            call lead(nbl,lw,lw2,maxbl)
            if (isklton.eq.1) then
               nou(1) = min(nou(1)+1,ibufdim)
               write(bou(nou(1),1),350) nbl
            end if
            ldim = 5
            need  = (idim+1)*(jdim+1)*(kdim+1)*5
            if (need .gt. nwork) then
               nou(1) = min(nou(1)+1,ibufdim)
               write(bou(nou(1),1),'(''stopping...not enough work'',
     .         '' space for subroutine intrbc (q)'')')
               nou(1) = min(nou(1)+1,ibufdim)
               write(bou(nou(1),1),'(''need, have '',2i11)')
     .         need,nwork
               call termn8(myid,-1,ibufdim,nbuf,bou,nou)
            end if
            call intrbc(w(lq),jdim,kdim,idim,nbl,ldim,maxbl,
     .                  iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                  iiig,jjig,kkig,qb,w(lqj0),w(lqk0),
     .                  w(lqi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                  bou,nbuf,ibufdim,irghost)
c           turbulence quantities
            if(iviscg(nbl,1).ge.2 .or. iviscg(nbl,2).ge.2 .or.
     .         iviscg(nbl,3).ge.2) then
               ldim = 1
               call intrbc(w(lvis),jdim,kdim,idim,nbl,ldim,maxbl,
     .                     iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                     iiig,jjig,kkig,qb,w(lvj0),w(lvk0),
     .                     w(lvi0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                     bou,nbuf,ibufdim,irghost)
            end if
            if(iviscg(nbl,1).ge.4 .or. iviscg(nbl,2).ge.4 .or.
     .         iviscg(nbl,3).ge.4) then
               ldim = 2
               call intrbc(w(lxib),jdim,kdim,idim,nbl,ldim,maxbl,
     .                     iitot,lig,iipntsg,dxintg,dyintg,dzintg,
     .                     iiig,jjig,kkig,qb,w(ltj0),w(ltk0),
     .                     w(lti0),wk,w(lbcj),w(lbck),w(lbci),nou,
     .                     bou,nbuf,ibufdim,irghost)
            end if
         end if


Why corrected: Change restart file to include ghost-cell data

Change Date: June 19, 2000

--------------------
--------------------

Number:          148

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

Delete:

      if (iadvance(nbl).lt.0) go to 2000

Delete:

            if (iadvance(nbl).lt.0) go to 6909



Why corrected: Part of general iadvance fixup.

Change Date: June 19, 2000

--------------------
--------------------

Number:          149

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    trnsfr_vals.F

After:

      common /is_blockbc/ is_blk(5),ie_blk(5),ivolint

Add:

      common /ghost/ irghost,iwghost

After:

         work(nlast+33) = ip3dgrad

Add:

         work(nlast+34) = irghost
         work(nlast+35) = iwghost

After:

         ip3dgrad  = int(work(nlast+33))

Add:

         irghost   = int(work(nlast+34))
         iwghost   = int(work(nlast+35))

Why corrected: Changed restart file to include ghost-cell data; the new
               keywords allow older restart files to be read by the
               current code

Change Date: June 19, 2000


--------------------
--------------------

Number:          150

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    updatedg.F

Change: (2 places)

      if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0 .and.
     .   (levelg(nbl).ge.lglobal .and.

To:

      if (myid.eq.mblk2nd(nbl) .and.  (levelg(nbl).ge.lglobal .and.

Change:

         if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0 .and.
     .      (levelg(nbl).ge.lglobal .and.

To:

         if (myid.eq.mblk2nd(nbl) .and. (levelg(nbl).ge.lglobal .and.

Change:

         if (iadvance(nbl).ge.0 .and. (levelg(nbl).ge.lglobal .and.

To:

         if ((levelg(nbl).ge.lglobal .and.



Why corrected: Part of general iadvance fixup.

Change Date: June 19, 2000

--------------------
--------------------

Number:          151

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

After:

         nptsrb = 0
         nnegb1 = 0
         nnegb2 = 0
         rmstb1 = 0.
         rmstb2 = 0.
         rmsb   = 0.

Add:

         sumn1  = 0.
         sumn2  = 0.
         negn1  = 0
         negn2  = 0
 

Why corrected: Part of general iadvance fixup.

Change Date: June 20, 2000


--------------------
--------------------

Number:          152

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    histout_img.F

Change: (3 places)

            if(real(rms(n)) .le. 0.) rms(n)=1.

To:
            if(imag(rms(n)) .le. 0.) rms(n)=cmplx(real(rms(n)),1.)


Why corrected: Incorrect fixup in case residual is zero for complex case

Change Date: June 21, 2000

--------------------
--------------------

Number:          153

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    ae_corr.F

Change:

                     do iseg=1,nsegdfrm(nbl)
                        cxbs = 0.
                        cybs = 0.
                        czbs = 0.
                        if (iaesurf(nbl,iseg).eq.iaes) then
                           call genforce(jdim,kdim,idim,w(lsk),w(lsj),
     .                                   w(lsi),czbs,cybs,cxbs,w(lbcj),
     .                                   w(lbck),w(lbci),w(lblk),nbl,
     .                                   w(lqj0),w(lqk0),w(lqi0),maxbl,
     .                                   maxseg,n2,w(lxmdj),w(lxmdk),
     .                                   w(lxmdi),aesrfdat,nmds,maxaes,
     .                                   maxsegdg,nsegdfrm,jcsi,jcsf,
     .                                   kcsi,kcsf,icsi,icsf,idfrmseg)
                           cxb = cxb + cxbs
                           cyb = cyb + cybs
                           czb = czb + czbs
                        end if
                     end do

To:

                     call genforce(jdim,kdim,idim,w(lsk),w(lsj),
     .                             w(lsi),czb,cyb,cxb,w(lbcj),
     .                             w(lbck),w(lbci),w(lblk),nbl,
     .                             w(lqj0),w(lqk0),w(lqi0),maxbl,
     .                             maxseg,n2,w(lxmdj),w(lxmdk),
     .                             w(lxmdi),aesrfdat,nmds,maxaes,
     .                             maxsegdg,nsegdfrm,jcsi,jcsf,
     .                             kcsi,kcsf,icsi,icsf,idfrmseg,
     .                             iaes,iaesurf)


Why Changed: There is also a loop over is = 1,nsegdfrm(nbl) inside
             subroutine genforce, making this outer one unneccessary.
             Only affects cases with multiple aeroelastic segments
             on a given block face, in which case the error lead to
             the segments being updated twice. Very similar to the
             error in Correction Number 119


Change Date: June 29, 2000

--------------------
--------------------

Number:          154

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    genforce.F

Change:

     .                    idfrmseg)

To:

     .                    idfrmseg,iaes,iaesurf)

Change:

      dimension nsegdfrm(maxbl),idfrmseg(maxbl,maxsegdg)

To:

      dimension nsegdfrm(maxbl),idfrmseg(maxbl,maxsegdg),
     .          iaesurf(maxbl,maxsegdg)

Change:

         if (idfrmseg(nbl,iseg) .eq. 99) then

To:

         if (iaesurf(nbl,iseg).eq.iaes .and.
     .       idfrmseg(nbl,iseg).eq.99) then

Why Changed: A consequence of Change 153; the check for whether the segment
             is associated with the current aeroelastic surface number
             or not is now done inside genforce, not outside.

Change Date: June 29, 2000


--------------------
--------------------

Number:          155

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    rrestg.F

Change:  (2 places)

                  if (ita .gt. 1) then

To:

                  if (abs(ita) .gt. 1) then

Remove:

c
c              the restart file is written out at time step n; we need
c              to reconstruct the grid at time step n, and for second
c              order time accurate solutions, we also need the grid
c              at time n-1 (first order does not require the grid at
c              n-1). to minimize the amount of grid data written to
c              the restart file, the following approach is used:
c
c            - for first order time solutions, the restart file
c              contains the grid at n (all that is needed). the
c              boundary displacements at time n are also output,
c              though they are not needed.
c
c            - for second order time solutions, the restart file
c              contains the full grid at n-1, plus the boundary
c              displacements at time n. The mesh deformation scheme
c              then uses the grid at time n-1 and the displacements
c              at time n to reconstruct the grid at time n, just like
c              a standard update. this approach saves roughly the
c              size of one grid in the restart file (as opposed to
c              storing the full grids at both n and n-1 in the
c              restart file).
c
c              with this approach the restart file always contains
c              the same amount of data regardless of whether first
c              or second order time is used - only the interpretation
c              of whether the full grid xyz data is at t(n) or t(n-1)
c              changes
c
c              (note: this code uses the Geometric Conservation Law
c              to replace the volume-derivative terms with unsteady
c              metric terms, so the old volumes need not be saved)
c


Why Changed: Incorrect deforming mesh data was read when using the recommended 
             tau-ts scheme (ita <0). The comment were removed because this is
             no longer the information in the restart file.

Change Date: July 17, 2000

--------------------
--------------------

Number:          156

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

Change:  

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster)

To:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster,5)


Why Changed:  slavept array needs to be calculated at start of computation,
              using the original, undeformed grid, in order to give the 
              same result with and without restarting. To accomodate mesh
              sequencing, need to add another index to this array. 
            

Change Date: July 24, 2000


--------------------
--------------------

Number:          157

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

After:

      common /motionmc/ xmc0,ymc0,zmc0,utransmc,vtransmc,wtransmc,
     .                  omegaxmc,omegaymc,omegazmc,xorigmc,yorigmc,
     .                  zorigmc,xorig0mc,yorig0mc,zorig0mc,thetaxmc,
     .                  thetaymc,thetazmc,dxmxmc,dymxmc,dzmxmc,
     .                  dthxmxmc,dthymxmc,dthzmxmc,rfreqtmc,
     .                  rfreqrmc,itransmc,irotatmc,time2mc

Add:

      common /trim/ dmtrmn,dmtrmnm,dlcln,dlclnm,trtol,cmy,cnw,alf0,
     .              alf1,dzdt,thtd0,thtd1,zrg0,zrg1,dtrmsmx,dtrmsmn,
     .              dalfmx,ddtmx,ddtrm0,ddtrm1,itrmt,itrminc,fp(4,4),
     .              tp(4,4)
      common /rigidbody/ irigb,irbtrim

After:

 108        continue
            iupdat = 0
            level  = levelt(iseq)

Add:

            irigb0   = 0
            irbtrim0 = 0

Change:

            call updateg(lw,lw2,w,mgwk,wk,nwork,iupdat,iseq,maxbl,
     .                   maxgr,maxseg,nbci0,nbcj0,nbck0,nbcidim,
     .                   nbcjdim,nbckdim,ibcinfo,jbcinfo,kbcinfo,
     .                   nblock,levelg,igridg,utrans,vtrans,wtrans,
     .                   omegax,omegay,omegaz,xorig,yorig,zorig,
     .                   thetax,thetay,thetaz,rfreqt,rfreqr,xorig0,
     .                   yorig0,zorig0,time2,thetaxl,thetayl,thetazl,
     .                   itrans,irotat,idefrm,ncgg,iadvance,nou,
     .                   bou,nbuf,ibufdim,myid,myhost,mycomm,mblk2nd)

To:

            call updateg(lw,lw2,w,mgwk,wk,nwork,iupdat,iseq,maxbl,
     .                   maxgr,maxseg,nbci0,nbcj0,nbck0,nbcidim,
     .                   nbcjdim,nbckdim,ibcinfo,jbcinfo,kbcinfo,
     .                   nblock,levelg,igridg,utrans,vtrans,wtrans,
     .                   omegax,omegay,omegaz,xorig,yorig,zorig,
     .                   thetax,thetay,thetaz,rfreqt,rfreqr,xorig0,
     .                   yorig0,zorig0,time2,thetaxl,thetayl,thetazl,
     .                   itrans,irotat,idefrm,ncgg,iadvance,nou,
     .                   bou,nbuf,ibufdim,myid,myhost,mycomm,mblk2nd,
     .                   irigb0,irbtrim0)


After:

c
c     aeroelastic predictor step
c
      if (iunst.gt.1 .and. naesrf.gt.0) then

Add:

#if defined DIST_MPI
         if (irigb .eq. 1) then
            call MPI_Bcast(clw(ntt),1,MY_MPI_REAL,myhost,
     .                     mycomm,ierr)
            call MPI_Bcast(cmyw(ntt),1,MY_MPI_REAL,myhost,
     .                     mycomm,ierr)
         end if
#endif

Change:

         call ae_pred(aesrfdat,stm,stmi,gforcn,gforcnm,xs,xxn,
     .                x0,perturb,nmds,maxaes,maxbl)

To:

         call ae_pred(aesrfdat,stm,stmi,gforcn,gforcnm,xs,xxn,
     .                x0,perturb,cmyw(ntt),clw(ntt),xorig,yorig,
     .                zorig,nmds,maxaes,irbtrim,maxbl)

Before:

         iupdat = 1
         call updateg(lw,lw2,w,mgwk,wk,nwork,iupdat,iseq,maxbl,

Add:

c
c        rigid body trim predictor step
c
         if (irbtrim.gt.0) irigb = 0
         if (irigb.gt.0) then
            call rb_pred(zrg1,zrg0,alf1,alf0,thtd1,thtd0,dzdt)
         end if
c

Change (in call to updatedg):

     .                bou,nbuf,ibufdim,myid,myhost,mycomm,mblk2nd)

To:

     .                bou,nbuf,ibufdim,myid,myhost,mycomm,mblk2nd,
     .                irigb,irbtrim)

After:

c
c     aeroelastic corrector step
c
      if (naesrf.gt.0) then
         call ae_corr(stm,stmi,xs,xxn,gforcn,gforcs,gforcnm,
     .                gf0,lw,lw2,w,mgwk,maxbl,maxseg,
     .                aesrfdat,nmds,maxaes,nt,mblk2nd,iseq,
     .                levelg,iadvance,nblock,icsi,icsf,jcsi,jcsf,
     .                kcsi,kcsf,myid,nsegdfrm,idfrmseg,iaesurf,
     .                perturb,aehist,ncycmax,maxsegdg,myhost,mycomm)
      end if

Add:

c
c     rigid body mode corrector step
c
      if (irbtrim.ne.0) irigb = 0
      if (irigb.eq.1) then
#if defined DIST_MPI
         call MPI_Bcast(clw(ntt),1,MY_MPI_REAL,myhost,
     .                  mycomm,ierr)
         call MPI_Bcast(cmyw(ntt),1,MY_MPI_REAL,myhost,
     .                  mycomm,ierr)
#endif
         call rb_corr(clw(ntt),cmyw(ntt))
      end if


Why Changed: to accomodate new rigid body trim option 
            

Change Date: July 24, 2000


--------------------
--------------------

Number:          158

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

Change:

      if (movie.lt.0) then

To:

      if (if real(dt).gt.0. and. movie.lt.0) then

Change:

      if (movabs.gt.0) then

To:

      if (real(dt).gt.0. .and. movabs.gt.0) then

Why Changed: Prevent multiple plot3d frames being output in steady-state
             cases if movie parameter is inadvetantly non-zero


Change Date: July 24, 2000

--------------------
--------------------

Number:          159

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgblk.F

Before and after each call to qout, Add:

            do iii = 1,iwk3
               iwk(iii) = 0
            end do
            do iii = 1,nwork
               wk(iii) = 0.0
            end do


Why Changed: reinitialize data in wk/iwk arrays for safety in
             call to qout

Change Date: July 24, 2000

--------------------
--------------------

Number:          160

Version:          6.0

Type:                Error     Problem  X  Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    resetg.F

Change:

         call updateg(lw,lw2,w,mgwk,wk,nwork,iupdat,iseqr,maxbl,
     .                maxgr,maxseg,nbci0,nbcj0,nbck0,nbcidim,
     .                nbcjdim,nbckdim,ibcinfo,jbcinfo,kbcinfo,
     .                nblock,levelg,igridg,utrans,vtrans,wtrans,
     .                omegax,omegay,omegaz,xorig,yorig,zorig,
     .                thetax,thetay,thetaz,rfreqt,rfreqr,xorig0,
     .                yorig0,zorig0,time2,thetaxl,thetayl,thetazl,
     .                itrans,irotat,idefrm,ncgg,iadvance,
     .                nou,bou,nbuf,ibufdim,myid,myhost,mycomm,
     .                mblk2nd)

To:

         irigb0   = 0
         irbtrim0 = 0
         call updateg(lw,lw2,w,mgwk,wk,nwork,iupdat,iseqr,maxbl,
     .                maxgr,maxseg,nbci0,nbcj0,nbck0,nbcidim,
     .                nbcjdim,nbckdim,ibcinfo,jbcinfo,kbcinfo,
     .                nblock,levelg,igridg,utrans,vtrans,wtrans,
     .                omegax,omegay,omegaz,xorig,yorig,zorig,
     .                thetax,thetay,thetaz,rfreqt,rfreqr,xorig0,
     .                yorig0,zorig0,time2,thetaxl,thetayl,thetazl,
     .                itrans,irotat,idefrm,ncgg,iadvance,
     .                nou,bou,nbuf,ibufdim,myid,myhost,mycomm,
     .                mblk2nd,irigb0,irbtrim0)

Why Changed: to accomodate new rigid body trim option


Change Date: July 24, 2000


--------------------
--------------------

Number:          161

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F

Change: (in subroutine argument list)

     .                 icouple)

To:

     .                 icouple,lfgm)

Change:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster)

To:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster,5)

After:

 1000 continue

Add:

c
c     initialize slavept data for mesh deformation
c
      if (iunst.gt.1 .or. idef_ss .gt. 0) then
         call setslave(lw,lw2,w,mgwk,wk,nwork,maxbl,maxgr,maxseg,
     .                 nbci0,nbcj0,nbck0,nbcidim,nbcjdim,nbckdim,
     .                 ibcinfo,jbcinfo,kbcinfo,nblock,idefrm,
     .                 iadvance,nou,bou,nbuf,ibufdim,myid,myhost,
     .                 mycomm,mblk2nd,icsi,icsf,jcsi,jcsf,kcsi,
     .                 kcsf,slavept,nslave,nsegdfrm,idfrmseg,
     .                 maxsegdg,iwk,iwork,nmaster,ngrid,jskip,kskip,
     .                 iskip,nblg,levelg,lfgm)
      end if
c

Change:

                  call cntsurf(nsurf,maxbl,maxgr,maxseg,ngrid,nblg,
     .                         nbci0,nbcj0,nbck0,nbcidim,nbcjdim,
     .                         nbckdim,ibcinfo,jbcinfo,kbcinfo)

To:

                  call cntsurf(nsurf,maxbl,maxgr,maxseg,ngrid,nblg,
     .                         nbci0,nbcj0,nbck0,nbcidim,nbcjdim,
     .                         nbckdim,ibcinfo,jbcinfo,kbcinfo,2004)

Why Changed:  slavept array needs to be calculated at start of computation,
              using the original, undeformed grid, in order to give the
              same result with and without restarting. To accomodate mesh
              sequencing, need to add another index to this array. The
              change in the call to cntsurf is a consequence of using
              cntsurf during the sizing process in order to provide 
              sufficient work space to the iwk in the call to setslave.

Change Date: July 24, 2000 


--------------------
--------------------

Number:          162

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F

After:

                  read(2,end=8995) (xxn(n,iaes),n=1,2*nmodes)
                  read(2,end=8995) (gforcn(n,iaes),n=1,2*nmodes)
                  read(2,end=8995) (gforcnm(n,iaes),n=1,2*nmodes)
                  read(2,end=8995) (((aehist(nn,ll,n,iaes),nn=1,ntt),
     .                                ll=1,3),n=1,nmodes)

Add:

                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),'('' reading generalized force/'',
     .            ''displacement data for aeroelastic surface '',i4)')
     .            iaes
c
c                 if x0 data is non-zero in input file, overwrite xxn with x0
c                 this allows a static ae solution to be perturbed for dynamic
c                 response
c
                  do n=1,2*nmodes
                     if (abs(real(x0(n,iaes))) .ne. 0.) then
                        xxn(n,iaes) = x0(n,iaes)
                     end if
                  end do

Why Changed: Allow x0 input data to be used to perturb an exisitng solution.
             Also output some restart info to the main output file. 

Change Date: July 24, 2000


--------------------
--------------------

Number:          163

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    setup.F

After:

      common /ghost/ irghost,iwghost

Add:

      common /rigidbody/ irigb,irbtrim

Why Changed: to accomodate new rigid body trim option

Change Date: July 24, 2000


--------------------
--------------------

Number:          164

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    updatedg.F

Change: (in subroutine argument list)

    .                   mblk2nd)

To:

    .                   mblk2nd,irigb,irbtrim)

After:

      common /motionmc/ xmc0,ymc0,zmc0,utransmc,vtransmc,wtransmc,
     .                  omegaxmc,omegaymc,omegazmc,xorigmc,yorigmc,
     .                  zorigmc,xorig0mc,yorig0mc,zorig0mc,thetaxmc,
     .                  thetaymc,thetazmc,dxmxmc,dymxmc,dzmxmc,
     .                  dthxmxmc,dthymxmc,dthzmxmc,rfreqtmc,
     .                  rfreqrmc,itransmc,irotatmc,time2mc

Add:

      common /trim/ dmtrmn,dmtrmnm,dlcln,dlclnm,trtol,cmy,cnw,alf0,
     .              alf1,dzdt,thtd0,thtd1,zrg0,zrg1,dtrmsmx,dtrmsmn,
     .              dalfmx,ddtmx,ddtrm0,ddtrm1,itrmt,itrminc,fp(4,4),
     .              tp(4,4)

Change:

         iuns = max(irotat(nbl),itrans(nbl))

To:

         iuns1 = max(irotat(nbl),itrans(nbl))
         iuns  = max(iuns1,irigb,irbtrim)

After:

   55       continue

Add:

c
c           translation/rotation corresponding to rigid-body modes
c           (currently restricted to z-translation and y-rotation only)
c
            if (irigb .gt. 0) then
c
               if (isklton.eq.1) then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),605) nbl
  605             format(1x,20htranslating rb-block,i4,
     .                   16h to new position)
               end if
c
               if (nwork.lt.mdim) then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),410)
                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
               end if
c
               zorig(nbl) = zrg1
               wtrans(nbl)= dzdt
               xold = xorig(nbl)
               yold = yorig(nbl)
               zold = zorig(nbl)
               call trans(jdim,kdim,idim,wk(lvel),wk(lacci),wk(laccj),
     .                    wk(lacck),w(lx),w(ly),w(lz),99,
     .                    rfreqt(nbl),utrans(nbl),vtrans(nbl),
     .                    wtrans(nbl),xorig(nbl),yorig(nbl),
     .                    zorig(nbl),xold,yold,zold,xorig0(nbl),
     .                    yorig0(nbl),zorig0(nbl),iupdat,time2(nbl))
c
c              rotation corresponding to rigid-body modes
c              (currently restricted to y-rotation only)
c
               if(isklton.eq.1)then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),615) nbl
               end if
  615          format(1x,19hrotating rb-block   ,i4
     .                                ,16h to new position)
c
               nroom = nwork-lt1wk
               mdim  = jdim*kdim*idim*3
               if (nroom.lt.mdim) then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),420)
                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
               end if
c
               thetaxl(nbl) = thetax(nbl)
               thetayl(nbl) = thetay(nbl)
               thetazl(nbl) = thetaz(nbl)
               thetay(nbl)  = alf1
               omegay(nbl)  = thtd1
               call rotate(jdim,kdim,idim,wk(lvel),wk(lacci),wk(laccj),
     .                     wk(lacck),wk(lt1wk),w(lx),w(ly),w(lz),nbl,
     .                     99,rfreqr(nbl),omegax(nbl),
     .                     omegay(nbl),omegaz(nbl),xorig(nbl),
     .                     yorig(nbl),zorig(nbl),thetax(nbl),
     .                     thetay(nbl),thetaz(nbl),thetaxl(nbl),
     .                     thetayl(nbl),thetazl(nbl),iupdat,time2(nbl),
     .                     nou,bou,nbuf,ibufdim)
            end if
c
c           trim step for rigid-body modes
c           (trim currently restricted to y-rotation only)
c
            if (irbtrim .gt. 0) then
c
               if(isklton.eq.1)then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),625) nbl
               end if
  625          format(1x,19hrotating rb-block  ,i4,8h to trim)
c
               nroom = nwork-lt1wk
               mdim  = jdim*kdim*idim*3
               if (nroom.lt.mdim) then
                  nou(1) = min(nou(1)+1,ibufdim)
                  write(bou(nou(1),1),420)
                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
               end if
c
               thetaxl(nbl) = thetax(nbl)
               thetayl(nbl) = thetay(nbl)
               thetazl(nbl) = thetaz(nbl)
               thetay(nbl)  = alf1
               omegay(nbl)  = (alf1-alf0)/dt
               call rotate(jdim,kdim,idim,wk(lvel),wk(lacci),wk(laccj),
     .                     wk(lacck),wk(lt1wk),w(lx),w(ly),w(lz),nbl,
     .                     99,rfreqr(nbl),omegax(nbl),
     .                     omegay(nbl),omegaz(nbl),xorig(nbl),
     .                     yorig(nbl),zorig(nbl),thetax(nbl),
     .                     thetay(nbl),thetaz(nbl),thetaxl(nbl),
     .                     thetayl(nbl),thetazl(nbl),iupdat,time2(nbl),
     .                     nou,bou,nbuf,ibufdim)
            end if

Before:

               call trans(jdim,kdim,idim,wk(lvel),wk(lacci),wk(laccj),

Add:

               xold = xorig(nbl)
               yold = yorig(nbl)
               zold = zorig(nbl)

Change:

               call trans(jdim,kdim,idim,wk(lvel),wk(lacci),wk(laccj),
     .                    wk(lacck),w(lx),w(ly),w(lz),itrans(nbl),
     .                    rfreqt(nbl),utrans(nbl),vtrans(nbl),
     .                    wtrans(nbl),xorig(nbl),yorig(nbl),
     .                    zorig(nbl),xorig0(nbl),yorig0(nbl),
     .                    zorig0(nbl),iupdat,time2(nbl))

To:

               call trans(jdim,kdim,idim,wk(lvel),wk(lacci),wk(laccj),
     .                    wk(lacck),w(lx),w(ly),w(lz),itrans(nbl),
     .                    rfreqt(nbl),utrans(nbl),vtrans(nbl),
     .                    wtrans(nbl),xorig(nbl),yorig(nbl),
     .                    zorig(nbl),xold,yold,zold,xorig0(nbl),
     .                    yorig0(nbl),zorig0(nbl),iupdat,time2(nbl))

Change:

               call rotate(jdim,kdim,idim,wk(lvel),wk(lacci),wk(laccj),
     .                     wk(lacck),wk(lt1wk),w(lx),w(ly),w(lz),nbl,
     .                     irotat(nbl),rfreqr(nbl),omegax(nbl),
     .                     omegay(nbl),omegaz(nbl),xorig(nbl),
     .                     yorig(nbl),zorig(nbl),thetax(nbl),
     .                     thetay(nbl),thetaz(nbl),iupdat,time2(nbl),
     .                     nou,bou,nbuf,ibufdim)

To:

               call rotate(jdim,kdim,idim,wk(lvel),wk(lacci),wk(laccj),
     .                     wk(lacck),wk(lt1wk),w(lx),w(ly),w(lz),nbl,
     .                     irotat(nbl),rfreqr(nbl),omegax(nbl),
     .                     omegay(nbl),omegaz(nbl),xorig(nbl),
     .                     yorig(nbl),zorig(nbl),thetax(nbl),
     .                     thetay(nbl),thetaz(nbl),thetaxl(nbl),
     .                     thetayl(nbl),thetazl(nbl),iupdat,time2(nbl),
     .                     nou,bou,nbuf,ibufdim)

Why Changed: to accomodate new rigid body trim option

Change Date: July 24, 2000

--------------------
--------------------

Number:          165

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    wrest.F

After:

      itag_tk0   = itag_tj0   + ioffset

Add:

c
      if (myid .eq. mblk2nd(nbl)) then
         mytag = nbl
         call MPI_Send(thetay(nbl),1,MY_MPI_REAL,
     .                 myhost,mytag,mycomm,ierr)
      else if (myid .eq. myhost) then
         mytag = nbl
         call MPI_Recv(thetay(nbl),1,MY_MPI_REAL,
     .                 nd_srce,mytag,mycomm,istat,ierr)
      end if

Why Changed: Pass the correct thetay of the current block to the host 
             for use in writing alphw to the restart file

Change Date: July 24, 2000

--------------------
--------------------

Number:          166

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    cfl3d.F

Change:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster)

To:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster,5)

Change:

      call umalloc(ip_slavept,3*nslave*nmaster,0,icall,memuse)

To:

      call umalloc(ip_slavept,15*nslave*nmaster,0,icall,memuse)


Why Changed:  slavept array needs to be calculated at start of computation,
              using the original, undeformed grid, in order to give the
              same result with and without restarting. To accomodate mesh
              sequencing, need to add another index to this array.

Change Date: July 24, 2000


--------------------
--------------------

Number:          167

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    sizer.F

Change:

         call cntsurf(nsurf,maxbl0,maxgr0,maxseg0,ngrid,nblg,
     .                nbci0,nbcj0,nbck0,nbcidim,nbcjdim,
     .                nbckdim,ibcinfo,jbcinfo,kbcinfo)

To:

         call cntsurf(nsurf,maxbl0,maxgr0,maxseg0,ngrid,nblg,
     .                nbci0,nbcj0,nbck0,nbcidim,nbcjdim,
     .                nbckdim,ibcinfo,jbcinfo,kbcinfo,2004)

After:

c
c     in setup, to call findmin_new (nroomi already calculated above)
      itempi = nroomi + needi_set
      needi  = max(needi,itempi)

Add:

c
c     in setslave, to call setcorner
      if (iunst.gt.1 .or. idef_ss.gt.0) then
         call cntsurf(ns2004,maxbl0,maxgr0,maxseg0,ngrid,nblg,
     .                nbci0,nbcj0,nbck0,nbcidim,nbcjdim,
     .                nbckdim,ibcinfo,jbcinfo,kbcinfo,2004)
         call cntsurf(ns1005,maxbl0,maxgr0,maxseg0,ngrid,nblg,
     .                nbci0,nbcj0,nbck0,nbcidim,nbcjdim,
     .                nbckdim,ibcinfo,jbcinfo,kbcinfo,1005)
         call cntsurf(ns1006,maxbl0,maxgr0,maxseg0,ngrid,nblg,
     .                nbci0,nbcj0,nbck0,nbcidim,nbcjdim,
     .                nbckdim,ibcinfo,jbcinfo,kbcinfo,1006)
         nsurf = ns2004 + ns1005 + ns1006
         itempi = nsurf + needi_set
         needi  = max(needi,itempi)
      end if

Why Changed:  slavept array needs to be calculated at start of computation,
              using the original, undeformed grid, in order to give the
              same result with and without restarting. Additional integer
              work space may be needed.

Change Date: July 24, 2000


--------------------
--------------------

Number:          168

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgbl.F

Change:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster)

To:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster,5)

Change: (in call to setup)

     .           zorgae0,icouple)

To:

     .           zorgae0,icouple,lfgm)

Why Changed:  slavept array needs to be calculated at start of computation,
              using the original, undeformed grid, in order to give the
              same result with and without restarting. 

Change Date: July 24, 2000

--------------------
--------------------

Number:          169

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    updatedg.F

Change:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster)

To:

      dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster,5)

Delete:

               if (nt .eq. 1) nflag = 1

Change: (in call to subroutine deform)

     .                     nmaster)

To:

     .                     nmaster,iseqr)


Why Changed:  slavept array needs to be calculated at start of computation,
              using the original, undeformed grid, in order to give the
              same result with and without restarting. 

Change Date: July 24, 2000

--------------------
--------------------

Number:          170

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    resp.F

Change:

      if (real(dt).lt.0. .and.   nt.eq.1) then
         iflag = 1
         if (myid.eq.mblk2nd(nbl)) then
To:

      if (real(dt).lt.0. .and.   nt.eq.1) then
         iflag = 1
         resd = 0.
         if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0) then

Change:

      if (real(dt).gt.0. .and. icyc.eq.ioutsub) then
         iflag = 1
c        l2-norm of density residual EXCLUDING time terms
         if (myid.eq.mblk2nd(nbl)) then

To:

      if (real(dt).gt.0. .and. icyc.eq.ioutsub) then
         iflag = 1
c        l2-norm of density residual EXCLUDING time terms
         resd = 0.
         if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0) then

Change:

      if (iflag.eq.1) then
c
c        density residual
c
         if (myid.eq.myhost) then
            rmssum    = 0.

To:

      if (iflag.eq.1) then
c
c        density residual
c
         if (myid.eq.myhost .and. iadvance(nbl).ge.0) then
            rmssum    = 0.

Change:

c
c        turbulence residual
c
         if (iviscg(nbl,1).gt.2 .or. iviscg(nbl,2).gt.2
     .      .or. iviscg(nbl,3).gt.2) then

To:

c
c        turbulence residual
c
         if (iviscg(nbl,1).gt.2 .or. iviscg(nbl,2).gt.2
     .      .or. iviscg(nbl,3).gt.2 .and. iadvance(nbl).ge.0) then

Change:

c
      if (real(dt).ge.0. .and. ncyc.gt.1) then
c
c        l2-norm of full residual (INCLUDING time terms)
c
         if (myid.eq.mblk2nd(nbl)) then

To:

c
      if (real(dt).ge.0. .and. ncyc.gt.1) then
c
c        l2-norm of full residual (INCLUDING time terms)
c
         resd = 0.
         if (myid.eq.mblk2nd(nbl) .and. iadvance(nbl).ge.0) then

Change:

         if (myid.eq.myhost) then
            rmssum = 0.
            if (nptsrb.gt.0) rmssum = rmsb*rmsb*float(nptsrb)
            t1     = float(1*jdim1*kdim1*idim1)
            rmstb  = sqrt(resd/t1)
            nptsrb = nptsrb + jdim1*kdim1*idim1
            rmssum = rmssum + resd
            rmsb   = sqrt(  rmssum / float( nptsrb) )
         end if
c
c        turbulence residual
c
         if (iviscg(nbl,1).gt.2 .or. iviscg(nbl,2).gt.2 .or.
     .       iviscg(nbl,3).gt.2) then

To:

         if (myid.eq.myhost .and. iadvance(nbl).ge.0) then
            rmssum = 0.
            if (nptsrb.gt.0) rmssum = rmsb*rmsb*float(nptsrb)
            t1     = float(1*jdim1*kdim1*idim1)
            rmstb  = sqrt(resd/t1)
            nptsrb = nptsrb + jdim1*kdim1*idim1
            rmssum = rmssum + resd
            rmsb   = sqrt(  rmssum / float( nptsrb) )
         end if
c
c        turbulence residual
c
         if (iviscg(nbl,1).gt.2 .or. iviscg(nbl,2).gt.2 .or.
     .       iviscg(nbl,3).gt.2 .and. iadvance(nbl).ge.0) then

Why corrected: Part of general iadvance fixup.

Change Date: July 24, 2000

--------------------
--------------------

Number:          171

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    ae_pred.F

Change:

      subroutine ae_pred(aesrfdat,stm,stmi,gforcn,gforcnm,xs,xxn,
     .                x0,perturb,nmds,maxaes)

To:

      subroutine ae_pred(aesrfdat,stm,stmi,gforcn,gforcnm,xs,xxn,
     .                x0,perturb,cmyt,cnwt,xorig,yorig,
     .                zorig,nmds,maxaes,irbtrim,maxbl)

After:

      dimension gforcn(2*nmds,maxaes),gforcnm(2*nmds,maxaes),
     .          stm(2*nmds,2*nmds,maxaes),stmi(2*nmds,2*nmds,maxaes),
     .          xs(2*nmds,maxaes),xxn(2*nmds,maxaes),x0(2*nmds,maxaes),
     .          aesrfdat(5,maxaes),perturb(nmds,maxaes,4)

Add:

      dimension xorig(maxbl),yorig(maxbl),zorig(maxbl)

Change:

      call moddefl(xs,aesrfdat,perturb,maxaes,nmds)

To:

      call moddefl(xs,aesrfdat,perturb,cmyt,cnwt,xorig,yorig,
     .             zorig,maxaes,nmds,irbtrim,maxbl)


Why corrected: Part of new rigid-body mode option

Change Date: July 24, 2000

--------------------
--------------------

Number:          172

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    moddefl.F

Change:

      subroutine moddefl(xs,aesrfdat,perturb,maxaes,nmds)

To:

      subroutine moddefl(xs,aesrfdat,perturb,cmyt,cnwt,xorig,yorig,
     .                   zorig,maxaes,nmds,irbtrim,maxbl)


After:

      dimension aesrfdat(5,maxaes),perturb(nmds,maxaes,4),
     .          xs(2*nmds,maxaes)

Add:

      dimension xorig(maxbl),yorig(maxbl),zorig(maxbl)

After:

      common /info/ title(20),rkap(3),xmach,alpha,beta,dt,fmax,nit,ntt,
     .        idiag(3),nitfo,iflagts,iflim(3),nres,levelb(5),mgflag,
     .        iconsf,mseq,ncyc1(5),levelt(5),nitfo1(5),ngam,nsm(5),iipv

Add:

      common /rbstmt2/ tmass,yinert,uinfrb,qinfrb,greflrb,gaccel,crefrb,
     .                 xtmref,areat
      common /trim/ dmtrmn,dmtrmnm,dlcln,dlclnm,trtol,cmy,cnw,alf0,
     .              alf1,dzdt,thtd0,thtd1,zrg0,zrg1,dtrmsmx,dtrmsmn,
     .              dalfmx,ddtmx,ddtrm0,ddtrm1,itrmt,itrminc,fp(4,4),
     .              tp(4,4)
      common /motionmc/ xmc0,ymc0,zmc0,utransmc,vtransmc,wtransmc,
     .                  omegaxmc,omegaymc,omegazmc,xorigmc,yorigmc,
     .                  zorigmc,xorig0mc,yorig0mc,zorig0mc,thetaxmc,
     .                  thetaymc,thetazmc,dxmxmc,dymxmc,dzmxmc,
     .                  dthxmxmc,dthymxmc,dthzmxmc,rfreqtmc,
     .                  rfreqrmc,itransmc,irotatmc,time2mc

After:

c
c           step pulse modal deflection
c
            if (moddfl.eq.3) then
               amp         = perturb(nm,iaes,2)
               t0          = perturb(nm,iaes,4)
               if (real(time).lt.real(t0-dt/2.)) then
                  xs(2*nm-1,iaes) = 0.
                  xs(2*nm,iaes)   = 0.
               else if (real(time).gt.real(t0-dt/2.) .and.
     .                  real(time).lt.real(t0+dt/2.)) then
                  xs(2*nm-1,iaes) = amp
                  xs(2*nm,iaes)   = amp/dt
               else
                  xs(2*nm-1,iaes) = amp
                  xs(2*nm,iaes)   = 0.
               end if
            end if

Add:

c
c           rigid body mode
c
            if (moddfl.eq.4) then
c
               if (ntt/itrminc*itrminc .eq. ntt) then
c
c                 Update the angle of attack and control surface trim
c                 angle to reach the trim lift coefficient
c                 (tmass*g/(qinf*areat*gfrefl*gfrefl))
c                 and zero moment coefficient.
c
c                 Level 1 g flight
c
                  dmtrmnm = dmtrmn
                  cmy     = cmyt + cnwt*(xorig(1)-xmc0)
                  dmtrmn  = cmy
                  cnw     = cnwt
                  dlclnm  = dlcln
                  dlcln   = cnw - ((tmass*gaccel)/
     .                        (2.*qinfrb*areat*greflrb*greflrb))
                  if ((abs(real(dlcln)).lt.real(trtol)) .and.
     .                    (abs(real(dmtrmn)).lt.real(trtol))) return

                  ddtrm0 = xs(2*nm-1,iaes)
                  alf0   = alf1
                  relax  = .20
                  alf1   =alf0  +relax*(-fp(1,1)*dlcln-fp(1,2)*dmtrmn)
                  ddtrm1 =ddtrm0+relax*(-fp(2,1)*dlcln-fp(2,2)*dmtrmn)
                  write(79,21928) itrmt,ntt,cmy,ddtrm0,ddtrm1,dlcln
     .                            ,alf0,alf1
                  if(real(ddtrm1).gt.real(dtrmsmx)) ddtrm1 = dtrmsmx
                  if(real(ddtrm1).lt.real(dtrmsmn)) ddtrm1 = dtrmsmn
                  if(abs(rel(ddtrm1-ddtrm0)).gt.real(ddtmx)) then
                     ddtrm1 = ddtrm0 + ddtmx*(ddtrm1-ddtrm0)
     .                                    /ccabs(ddtrm1-ddtrm0)
                  end if
                  xs(2*nm-1,iaes) = ddtrm1
                  if (abs(real(alf1-alf0)).gt.real(dalfmx)) then
                        alf1 = alf0+dalfmx*(alf1-alf0)/ccabs(alf1-alf0)
                  end if
21928             format(2i8,6(1x,f16.9))
                  itrmt = itrmt + 1
                  irbtrim = 1
               end if
            end if
c

Why corrected: Part of new rigid-body mode option

Change Date: July 24, 2000

--------------------
--------------------

Number:          173

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    rotate.F

Change:

      subroutine rotate(jdim,kdim,idim,t,tti,ttj,ttk,t1,x,y,z,nbl,
     .                  irot,rfreqr,omegx,omegy,omegz,xorg,yorg,zorg,
     .                  thetax,thetay,thetaz,iupdat,time2,
     .                  nou,bou,nbuf,ibufdim)

To:

      subroutine rotate(jdim,kdim,idim,t,tti,ttj,ttk,t1,x,y,z,nbl,
     .                  irot,rfreqr,omegx,omegy,omegz,xorg,yorg,zorg,
     .                  thetax,thetay,thetaz,thxold,thyold,thzold,
     .                  iupdat,time2,nou,bou,nbuf,ibufdim)

After:

c             =  3 smooth increase in rotational displacement,
c                  asypmtotically reaching a fixed rotational displacement

Add:

c             = 99 modulation driven external to this routine: on
c                  input thetax,thetay,thetaz already contain new
c                  angular displacements, and omegx,omegy,omegz
c                  already contain new rotational rates.

After:

      else if (irot .eq. 3)  then
         expt   = exp(-rfreqr*time2)
         ft     = 1.-expt
         dfdt   = rfreqr*expt
         d2fdt2 = -(rfreqr)**2*expt

Add:

      else if (irot .eq. 99)  then
         ft     = 0.
         dfdt   = 1.0
         d2fdt2 = 0.

Change: (similar mods for y and z components)

            theold = thetax

To:

            theold = thxold

Change: (similar mods for y and z components)

         theta    = omegx*ft

To:

         if (irot .ne. 99) then
            theta = omegx*ft
         else
            theta = thetax
         end if

Why corrected: Part of new rigid-body mode option

Change Date: July 24, 2000

--------------------
--------------------

Number:          174

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    trans.F

Change:

      subroutine trans(jdim,kdim,idim,t,tti,ttj,ttk,x,y,z,itran,rfreqt,
     .                 utran,vtran,wtran,xorg,yorg,zorg,xorg0,yorg0,
     .                 zorg0,iupdat,time2)

To:

      subroutine trans(jdim,kdim,idim,t,tti,ttj,ttk,x,y,z,itran,rfreqt,
     .                 utran,vtran,wtran,xorg,yorg,zorg,xold,yold,
     .                 zold,xorg0,yorg0,zorg0,iupdat,time2)

After:

c              =  3 smooth increase in displacement, asypmtotically
c                   reaching a fixed displacement

Add:

c              = 99 modulation driven external to this routine: on
c                   input xorg,yorg,zorg already contain new
c                   translational displacements, and utran,vtran,wtran
c                   already contain new rotational rates.

After:

      else if (itran .eq. 3)  then
         expt   = exp(-rfreqt*time2)
         ft     = 1.-expt
         dfdt   = rfreqt*expt
         d2fdt2 = -(rfreqt)**2*expt

Add:

      else if (itran .eq. 99)  then
         ft     = 0.
         dfdt   = 1.
         d2fdt2 = 0.

Change:

      xold = xorg
      yold = yorg
      zold = zorg
c
      xnew = utran*ft + xorg0
      ynew = vtran*ft + yorg0
      znew = wtran*ft + zorg0

To:

      if (itran .ne. 99) then
         xnew = utran*ft + xorg0
         ynew = vtran*ft + yorg0
         znew = wtran*ft + zorg0
      else
         xnew = xorg
         ynew = yorg
         znew = zorg
      end if

Change:

         xorg = xorg+dx
         yorg = yorg+dy
         zorg = zorg+dz

To:

         xorg = xold+dx
         yorg = yold+dy
         zorg = zold+dz

Why corrected: Part of new rigid-body mode option

Change Date: July 24, 2000


--------------------
--------------------

Number:          175

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    cntsurf.F

Change:

      subroutine cntsurf(nsurf,maxbl,maxgr,maxseg,ngrid,nblg,nbci0,
     .                   nbcj0,nbck0,nbcidim,nbcjdim,nbckdim,ibcinfo,
     .                   jbcinfo,kbcinfo)

To:

      subroutine cntsurf(nsurf,maxbl,maxgr,maxseg,ngrid,nblg,nbci0,
     .                   nbcj0,nbck0,nbcidim,nbcjdim,nbckdim,ibcinfo,
     .                   jbcinfo,kbcinfo,ibctyp)

Change:

c     Purpose: To count the number of solid surface points (nsurf)

To:

c     Purpose: To count the number of surface points (nsurf) with
c     boundary condition type ibctyp

Change: (muliple occurances)

               if(abs(nbctype).eq.2004) then

To:

               if(abs(nbctype).eq.ibctyp) then


Why corrected: To make the routine a more general counter for any type
               of bc. Specifically changed to allow cntsurf to count
               inviscid surface points for use in setting integer work
               requirements for deforming mesh scheme.

Change Date: July 24, 2000

--------------------
--------------------

Number:          176

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F

Change: (in subroutine argument)

     .                  nmaster)

To:

     .                  nmaster,iseq)

Change:

      dimension wk(9*nsurf),slavept(nslave,3,nmaster)

To:

      dimension wk(9*nsurf),slavept(nslave,3,nmaster,5)

Change: (similar changes in all calls to setcorner)

                   call setcorner(j,k,1,xnm1,ynm1,znm1,dx,dy,
     .                            dz,jdim,kdim,idim,wk,nsurf,iflag,
     .                            ivert,slavept,nslave,nou,bou,
     .                            ibufdim,nbuf,myid,ibl,nmaster)

To:

                   call setcorner(j,k,1,xnm1,ynm1,znm1,dx,dy,
     .                            dz,jdim,kdim,idim,wk,nsurf,iflag,
     .                            ivert,slavept,nslave,nou,bou,
     .                            ibufdim,nbuf,myid,ibl,nmaster,
     .                            iseq)


Why Changed:  slavept array needs to be calculated at start of computation,
              using the original, undeformed grid, in order to give the
              same result with and without restarting. To accomodate mesh
              sequencing, need to add another index to this array.

Change Date: July 24, 2000


--------------------
--------------------

Number:          177

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    setcorner.F

Change: (in subroutine argument)

     .                     nou,bou,ibufdim,nbuf,myid,ibl,nmaster)

To:

     .                     nou,bou,ibufdim,nbuf,myid,ibl,nmaster,iseq)


Change:

      dimension wk(9*nsurf),slavept(nslave,3,nmaster),ibl(nsurf)

To:

      dimension wk(9*nsurf),slavept(nslave,3,nmaster,5),ibl(nsurf)

Change:

            slavept(ivert,1,nm) = float(lsmin)
            slavept(ivert,2,nm) = dsmin
            if (nm .eq. 1) then
               slavept(ivert,3,nm) = 1.
            else
               slavept(ivert,3,nm) =
     .         slavept(ivert,2,1)/slavept(ivert,2,nm)
            end if
         end do
         wttot = 0.
         do nm=1,nmaster
            wttot = wttot + slavept(ivert,3,nm)
         end do
         do nm=1,nmaster
            slavept(ivert,3,nm) = slavept(ivert,3,nm)/wttot
         end do
      end if

To:

            slavept(ivert,1,nm,iseq) = float(lsmin)
            slavept(ivert,2,nm,iseq) = dsmin
            if (nm .eq. 1) then
               slavept(ivert,3,nm,iseq) = 1.
            else
               slavept(ivert,3,nm,iseq) =
     .         slavept(ivert,2,1,iseq)/slavept(ivert,2,nm,iseq)
            end if
         end do
         wttot = 0.
         do nm=1,nmaster
            wttot = wttot + slavept(ivert,3,nm,iseq)
         end do
         do nm=1,nmaster
            slavept(ivert,3,nm,iseq) = slavept(ivert,3,nm,iseq)/wttot
         end do
         return
      end if

Change:

         lsmin  = int(slavept(ivert,1,nm))
         dsmin  = slavept(ivert,2,nm)
         wt     = slavept(ivert,3,nm)

To:

         lsmin  = int(slavept(ivert,1,nm,iseq))
         dsmin  = slavept(ivert,2,nm,iseq)
         wt     = slavept(ivert,3,nm,iseq)

Change:

         damp1  = beta1*dv/(eps+dm)

To:

         damp1  = ccabs(beta1)*dv/(eps+dm)



Why Changed:  slavept array needs to be calculated at start of computation,
              using the original, undeformed grid, in order to give the
              same result with and without restarting. To accomodate mesh
              sequencing, need to add another index to this array. The change
              from beta1 to ccabs(beta1) is to allow beta1 < 0 to be used
              to trigger TFI on the surface as well as on the interior, 
              at the request of Boeing Phantom Works, Long Beach.

Change Date: July 24, 2000

--------------------
--------------------

Number:          178

Version:          6.0

Type:              X Error     Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global0.F

After:

c
c     dynamic patch data
c
      intmx0 = 1
      msub10 = 1

Add:

      nint1  = 0

Why Changed: Need to initialize nint1 in case it is not read from the
             input file - otherwise could lead to incorrect parameter
             size 

Change Date: July 24, 2000


--------------------
--------------------

Number:          179

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F

Change: (2 places)

         if (abs(ibctyp).ne.2004 .or.
     .       abs(ibctyp).ne.1005 .or.
     .       abs(ibctyp).ne.1006) then

To:

         if (abs(ibctyp).ne.2004 .and.
     .       abs(ibctyp).ne.1005 .and.
     .       abs(ibctyp).ne.1006 .or.
     .       real(beta1).lt.0.) then

Change: (2 places)

            if (abs(jbctyp).ne.2004 .or.
     .          abs(jbctyp).ne.1005 .or.
     .          abs(jbctyp).ne.1006) then

To:

            if (abs(jbctyp).ne.2004 .and.
     .          abs(jbctyp).ne.1005 .and.
     .          abs(jbctyp).ne.1006 .or.
     .          real(beta1).lt.0.) then

Change: (2 places)

            if (abs(kbctyp).ne.2004 .or.
     .          abs(kbctyp).ne.1005 .or.
     .          abs(kbctyp).ne.1006) then

To:

            if (abs(kbctyp).ne.2004 .and.
     .          abs(kbctyp).ne.1005 .and.
     .          abs(kbctyp).ne.1006 .or.
     .          real(beta1).lt.0.) then


Why Changed: Only needs to be done if NOT a solid surface (bctypes 2004,
             1005 and 1006). Previous coding caused following calls to
             always be done. The test for real(beta1).lt.0. is to allow
             beta1 < 0 to be used to trigger TFI on the surface as well
             as on the interior, at the request of Boeing Phantom Works,
             Long Beach.

Change Date: July 26, 2000

--------------------
--------------------

Number:          180

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    deform.F

Change: (6 places)

c
c            preseve deltas on solid surfaces
c
             if (idefrm(nbl).lt.999) then

To:

c
c            preserve deltas on edges of solid surfaces
c
             if (idefrm(nbl).lt.999 .and. real(beta1).ge.0.) then

Why Changed: The test for real(beta1).ge.0. is to allow beta1 < 0 to be
             used to trigger TFI on the surface as well as on the
             interior, at the request of Boeing Phantom Works, Long Beach.

Change Date: July 26, 2000


--------------------
--------------------

Number:          180

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/libs

Subroutine(s):    global.F

Remove:

         beta1 = abs(beta1)

After: (3 places)

            write(iunit11,'(i8,f9.6,2i9)') ngrid,real(beta1),nmastr,
     .            ismooth

Add:

            if (real(beta1).lt.0.) then
               write(iunit11,'(/,'' WARNING: beta<0 may severely '',
     .         ''compromise fidelity of surface geometry'',/)')
            end if


Why Changed: To allow beta1 < 0 to be used to trigger TFI on the surface
             as well as on the interior, at the request of Boeing Phantom
             Works, Long Beach.

Change Date: July 26, 2000

--------------------
--------------------

Number:          181

Version:          6.0

Type:                Error     Problem   X Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    resp.F

After:

         iwrit3 = 2
c
         if (myid.eq.myhost) then
            if (ncyc.gt.1 .and. nbl .eq. nblendg) then
               nout = (nt-1)*ncyc+icyc
               if (iwrit3.gt.0) then
                  if (ihstry.eq.0) then

Add:

                     if (ialph.eq.0) then

After:

                     if (nout.eq.1) write(23,1000)
                     write(23,1020) nout,log10(real(rmsb)),real(cltsub),
     .               real(cdtsub),real(cytsub),real(cmytsub)

Add:

                     else
                     if (nout.eq.1) write(23,1001)
                     write(23,1020) nout,log10(real(rmsb)),real(cltsub),
     .               real(cdtsub),real(cztsub),real(cmztsub)
                     end if

Change:

 1000 format(4x,5hsubit,3x,11hlog(subres),7x,2hcl,12x,2hcd,
     .       12x,2hcy,12x,2hcm)

To:

 1000 format(4x,5hsubit,3x,11hlog(subres),7x,2hcl,12x,2hcd,
     .       12x,2hcy,11x,3hcmy)
 1001 format(4x,5hsubit,3x,11hlog(subres),7x,2hcl,12x,2hcd,
     .       12x,2hcz,11x,3hcmz)


Why Changed: To output cy,cmy or cz,cmz, depending on which direction is 
             pointing "up" in the grid (as indicated by ialph), for the
             subiteration convergence history. 

Change Date: August 1, 2000

--------------------
--------------------

Number:          182

Version:          6.0

Type:                Error   X Problem     Modification/enhancement     Other
                  ---       ---         ---                          ---

Directory(s):     cfl3dv6/source/cfl3d/dist

Subroutine(s):    mgbl.F

Change:

         if (movie.eq.0) then

To:

         if (real(dt).lt.0. .or. (real(dt).gt.0..and.movie.eq.0)) then

Why Changed: To prevent plot3d files from not being output for steady
             state cases if movie is nonzero


Change Date: August 1, 2000

--------------------
--------------------

</pre>

<p><strong><a href="#top">Return to Top</a></strong></p>

<br>&nbsp;
<p>
<hr WIDTH="100%">
<p style="font-family: helvetica,arial,sans-serif;"><a href="https://www.nasa.gov/about/highlights/HP_Privacy.html" target="_blank">Privacy Act Statement</a> </p>
<p align="right" style="font-family: helvetica,arial,sans-serif;"><strong>Responsible NASA Official:</strong>
  <a href="mailto:c.l.rumsey@nasa.gov">Christopher Rumsey</a> <br>
<strong>Page Curator:</strong>
  <a href="mailto:c.l.rumsey@nasa.gov">Christopher Rumsey</a> <br>
<strong>Last Updated:</strong> 03/29/2013
<br>&nbsp;
</body>
</html>
