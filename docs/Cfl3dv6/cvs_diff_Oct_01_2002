Index: README
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/README,v
retrieving revision 1.2
retrieving revision 1.7
diff -r1.2 -r1.7
3c3
< http://fmad-www.larc.nasa.gov/~biedron/Cfl3dv6/cfl3dv6.html
---
> http://cfl3d.larc.nasa.gov/Cfl3dv6/cfl3dv6.html
Index: build/Install
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/Install,v
retrieving revision 1.2
retrieving revision 1.11
diff -r1.2 -r1.11
3c3
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
57a58,61
> #   -purify        compile using Rational Software's Purify (memory checker)
> #                  - must have a licence for Purify
> #                  - this option only effective on SGI platform
> #
75a80
> do_purify=no    # don't use purify
82c87,88
<     -f77)         do_f90=no;;
---
>     -f77)         do_f90=no ;;
>     -purify)      do_purify=yes ;;
92a99
>        -purify
243a251
>         SV1) GARCH=CRAY ;;
410a419,422
> 
> # Intel 
> # CC="icc"
> 
417a430
>   FFLAG_SPEC="$FFLAG"
496a510,515
>   if [ ! "$FARCH" = IRIX64 ] ; then
>      if [ $do_purify = yes ] ; then
>         echo 'purify option only enabled for IRIX64 architecture'
>         exit 1
>      fi
>   fi
514a534,555
>   FFLAG_SPEC="$FFLAG"
>   INLINE="-Oinlinefrom=ccomplex.F"
> esac
> 
> #########################################
> #        CRAY SV1 ARCHITECTURE
> #########################################
> 
> case $LLARCH in SV1)
>   MPI_HOME="/opt/ctl/mpt/1.4.0.0"
>   MPI_INCDIR="$MPI_HOME/include"
>   MPI_LLIBDIR="$MPI_HOME/lib"
>   MAKEFILE="makefile_cpp"
>   PREC_MPI=""
>   PREC=""
>   CFLAG="$PREC"
>   CPP="/opt/ctl/bin/cpp"
>   CPPOPT_SP="-DASN_P3D -DCRAY_TIME -DWKSTN_OFF"
>   AROPT="ruc"
>   RANLIB="true"
>   FFLAG="-Oscalar3,vector3,nopattern -a taskcommon"
>   FFLAG_SPEC="-O1 nopattern -a taskcommon"
547a589
>   FFLAG_SPEC="$FFLAG"
554a597,610
>   if [ $do_purify = yes ];then
>      FFLAG="-g"
>      FFLAG_SPEC="$FFLAG"
>      LFLAG=""
>      CFLAG="$PREC"
>      FTN="purify $FTN"
>     if [ ! x$cgnsdir = x ]; then
>        CGNS_LLIB="cgns.mips4_32"
>     fi
>     if [ x$mpichdir = x ]; then
>        MPI_LLIBDIR="$MPI_HOME/lib32"
>     fi
> 
>   fi
569a626
>   FFLAG_SPEC="$FFLAG"
594a652
>   FFLAG_SPEC="$FFLAG"
612a671
>   FFLAG_SPEC="$FFLAG"
634a694
>   FFLAG_SPEC="$FFLAG"
644,645c704,710
< # NOTE: the following are specific to ICASE Beowulf machine "Coral",
< # which consists of 33 400 Mhz Pentium II processors
---
> # NOTE: due to the variability of Linux installations,
> # available compilers, etc., it is not possible to
> # set FFLAGS, FTN, etc varables universally once
> # Linux has been identified as the OS. Below are
> # some values which have been used in the past -
> # however these may well need to be tweeked for
> # any particular installation
648c713,730
<    FFLAG="-O0 -Mdalign -tp p6 -Mbyteswapio"
---
> 
> # Portland Group Compiler
>   FFLAG="-fast -tp p7 -byteswapio"
> 
> # Alpha Compiler
> # FFLAG="-O2 -convert big_endian"
> 
> # Lahey Fujitsu Compiler
> # FFLAG="--o1 --ap"
> # Note: the following evironment variable must be set in order
> #       to use "bigendian" files (like those generated on an SGI)
> #       with the Lahey Fujitsu compiler
> #setenv FORT90L -Wl,-T
> 
> # Intel Fortan Compiler
> # FFLAG="-O3 -tpp7 -w -ip"
> 
>   FFLAG_SPEC="$FFLAG"
650c732,744
<      PREC="-Mr8"
---
> 
> #    Portland Group Compiler
>      PREC="-r8"
> 
> # Alpha Compiler
> #    PREC="-r8"
> 
> #    Lahey Fujitsu Compiler
> #    PREC="--dbl"
> 
> # Intel Fortan Compiler
> #    PREC="-r8"
> 
651a746
> 
652a748
> 
654,655c750,764
<   CPP="/usr/local/pgi/linux86/bin/pgcpp1"
<   FTN="/usr/local/pgi/linux86/bin/pgf90"
---
> 
>   CPP="cpp"
> 
> # Portland Group Compiler
>   FTN="pgf90"
> 
> # Alpha Compiler
> # FTN="fort"
> 
> # Lahey Fujitsu Compiler
> # FTN="lf95"
> 
> # Intel Fortan Compiler
> # FTN="ifc"
> 
656a766
> 
694a805,807
> # Intel Fortran Compiler
> # LLIB="$LLIB -lsvml -lPEPCF90"
> 
719a833
> s;@FFLAG_SPEC@;$FFLAG_SPEC;g
768a883,885
> if [ $do_purify = yes ]; then
>    echo 'makefile created using purify.................yes'
> fi
805a923,937
> case $LLARCH in SV1)
>    echo ' '
>    echo 'On the SV1, use "mpirun -nt ..." rather than "mpirun -np ..."'
> esac
> case $LARCH in Linux)
>    echo ' '
>    echo 'NOTE: due to the variability of Linux installations,'
>    echo 'available compilers, etc., it is not possible to'
>    echo 'set FFLAGS, FTN, etc varables universally once'
>    echo 'Linux has been identified as the OS. See the section'
>    echo '"LINUX ARCHITECTURE" in the Install script for'
>    echo 'some values which have been used in the past -'
>    echo 'however these may well need to be tweeked for'
>    echo 'any particular installation'
> esac
Index: build/Makefile.in
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/Makefile.in,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
2c2
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
49a50
> FFLAG_SPEC   = @FFLAG_SPEC@
318a320
> 	CFLSRC_D="../../$(CFLSRC_D)" \
330a333
> 	CFLSRC_D="../../$(CFLSRC_D)" \
342a346
> 	CFLSRC_D="../../$(CFLSRC_D)" \
373a378
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
377c382
< 	CPPOPT="$(CPPOPT) $(CPPOPT_SP)" \
---
> 	CPPOPT="$(CPPOPT_SP)" \
386a392
> 	CFLSRC_D="../../$(CFLSRC_D)" \
398a405
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
424a432
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
428c436
< 	CPPOPT="$(CPPOPT) $(CPPOPT_SP) $(CPPOPT_CMPLX)" \
---
> 	CPPOPT="$(CPPOPT_SP) $(CPPOPT_CMPLX)" \
437a446
> 	CFLSRC_D="../../$(CFLSRC_D)" \
449a459
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
475a486
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
501a513
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
525a538
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
548a562
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
571a586
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC) $(INLINE)" \
594a610
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC)" \
603a620
> 	CFLSRC_D="../../$(CFLSRC_D)" \
615a633
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC)" \
625a644
> 	CFLSRC_D="../../$(CFLSRC_D)" \
637a657
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC)" \
647a668
> 	CFLSRC_D="../../$(CFLSRC_D)" \
659a681
> 	FFLAG_SPEC="$(FFLAG_SPEC) $(PREC)" \
Index: build/cfl/libs/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cfl/libs/makefile,v
retrieving revision 1.2
retrieving revision 1.6
diff -r1.2 -r1.6
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18a19
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
37c38
< 	collxtb.F      expand.F       int2.F         addx.F \
---
> 	collxtb.F      expand.F       int2.F \
84,85c85,86
< 	rpatch0.F      cntsurf.F      cctogp.F       umalloc.F \
< 	ufree.F        modread.F      genforce.F     rotsurf.F \
---
> 	rpatch0.F      cntsurf.F      cctogp.F       bc2009.F \
> 	modread.F      genforce.F     rotsurf.F \
95c96,101
< 	pltmode.F
---
> 	pltmode.F      bcnonin.F      initnonin.F     resnonin.F
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F addx.F
100a107,108
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
105,106c113,115
< $(COMMONLIB): $(FSRC_LIBS) $(FOBJ_LIBS) $(CSRC_LIBS) $(COBJ_LIBS)
< 	ar $(AROPT) $(COMMONLIB) $(FOBJ_LIBS) $(COBJ_LIBS) 
---
> $(COMMONLIB): $(FSRC_LIBS) $(FOBJ_LIBS) $(FSRC_SPEC) $(FOBJ_SPEC) \
> 	$(CSRC_LIBS) $(COBJ_LIBS)
> 	ar $(AROPT) $(COMMONLIB) $(FOBJ_LIBS) $(FOBJ_SPEC) $(COBJ_LIBS) 
110a120,122
> 
> $(FOBJ_SPEC):
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
Index: build/cfl/libs/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cfl/libs/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.7
diff -r1.2 -r1.7
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18a19
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
44c45
< 	collxtb.f      expand.f       int2.f         addx.f \
---
> 	collxtb.f      expand.f       int2.f \
91,92c92,93
< 	rpatch0.f      cntsurf.f      cctogp.f       umalloc.f \
< 	ufree.f        modread.f      genforce.f     rotsurf.f \
---
> 	rpatch0.f      cntsurf.f      cctogp.f       bc2009.f \
> 	modread.f      genforce.f     rotsurf.f \
102c103,108
< 	pltmode.f
---
> 	pltmode.f      bcnonin.f      initnonin.f    resnonin.f
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f addx.f
107a114,115
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
112,113c120,122
< $(COMMONLIB): $(FSRC_LIBS) $(FOBJ_LIBS) $(CSRC_LIBS) $(COBJ_LIBS)
< 	ar $(AROPT) $(COMMONLIB) $(FOBJ_LIBS) $(COBJ_LIBS) 
---
> $(COMMONLIB): $(FSRC_LIBS) $(FOBJ_LIBS) $(FSRC_SPEC) $(FOBJ_SPEC) \
> 	$(CSRC_LIBS) $(COBJ_LIBS)
> 	ar $(AROPT) $(COMMONLIB) $(FOBJ_LIBS) $(FOBJ_SPEC) $(COBJ_LIBS) 
117a127,129
> 
> $(FOBJ_SPEC):
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
Index: build/cfl/mpi/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cfl/mpi/makefile,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15a16
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
41c42,48
< 	updatedg.F     ae_corr.F      mgbl.F         setslave.F
---
> 	updatedg.F     ae_corr.F      mgbl.F         setslave.F \
> 	umalloc.F
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
44a52,53
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
47,48c56,57
< $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST)
< 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST)
---
> $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST) $(FOBJ_SPEC)
54a64,66
> 
> $(FOBJ_SPEC): $(HEAD_DIST)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
Index: build/cfl/mpi/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cfl/mpi/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15a16
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
48c49,55
< 	updatedg.f     ae_corr.f      mgbl.f         setslave.f
---
> 	updatedg.f     ae_corr.f      mgbl.f         setslave.f \
> 	umalloc.f
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
51a59,60
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
54,55c63,64
< $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST)
< 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST)
---
> $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST) $(FOBJ_SPEC)
61a71,73
> 
> $(FOBJ_SPEC): $(HEAD_DIST)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
Index: build/cfl/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cfl/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15a16
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
41c42,48
< 	updatedg.F     ae_corr.F      mgbl.F         setslave.F
---
> 	updatedg.F     ae_corr.F      mgbl.F         setslave.F \
> 	umalloc.F
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
44a52,53
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
47,48c56,57
< $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST)
< 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST)
---
> $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST) $(FOBJ_SPEC)
54a64,66
> 
> $(FOBJ_SPEC): $(HEAD_DIST)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
Index: build/cfl/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cfl/seq/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15a16
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
48c49,55
< 	updatedg.f     ae_corr.f      mgbl.f         setslave.f
---
> 	updatedg.f     ae_corr.f      mgbl.f         setslave.f \
> 	umalloc.f
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
51a59,60
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
54,55c63,64
< $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST)
< 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST)
---
> $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST) $(FOBJ_SPEC)
62a72,74
> $(FOBJ_SPEC): $(HEAD_DIST)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
78c90
< $(EXEC): $(FSRC_MAIN) $(FOBJ_MAIN) $(DISTLIB) $(COMMONLIB) 
---
> $(EXEC): $(FSRC_MAIN) $(FOBJ_MAIN) $(DISTLIB) $(COMMONLIB)
Index: build/cflcmplx/libs/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cflcmplx/libs/makefile,v
retrieving revision 1.2
retrieving revision 1.6
diff -r1.2 -r1.6
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18a19
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
37c38
< 	collxtb.F      expand.F       int2.F         addx.F \
---
> 	collxtb.F      expand.F       int2.F \
84,85c85,86
< 	rpatch0.F      cntsurf.F      cctogp.F       umalloc.F \
< 	ufree.F        modread.F      genforce.F     rotsurf.F \
---
> 	rpatch0.F      cntsurf.F      cctogp.F       bc2009.F \
> 	modread.F      genforce.F     rotsurf.F \
95c96,102
< 	init_trim.F    pltmode.F
---
> 	init_trim.F    pltmode.F      bcnonin.F      initnonin.F \
> 	resnonin.F
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F addx.F
100a108,109
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
105,106c114,116
< $(COMMONLIB): $(FSRC_LIBS) $(FOBJ_LIBS) $(CSRC_LIBS) $(COBJ_LIBS)
< 	ar $(AROPT) $(COMMONLIB) $(FOBJ_LIBS) $(COBJ_LIBS) 
---
> $(COMMONLIB): $(FSRC_LIBS) $(FOBJ_LIBS) $(FSRC_SPEC) $(FOBJ_SPEC) \
> 	$(CSRC_LIBS) $(COBJ_LIBS)
> 	ar $(AROPT) $(COMMONLIB) $(FOBJ_LIBS) $(FOBJ_SPEC) $(COBJ_LIBS) 
110a121,123
> 
> $(FOBJ_SPEC):
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
Index: build/cflcmplx/libs/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cflcmplx/libs/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.7
diff -r1.2 -r1.7
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18a19
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
44c45
< 	collxtb.f      expand.f       int2.f         addx.f \
---
> 	collxtb.f      expand.f       int2.f \
56c57
< 	tau2x.f        tdq.f          tinvr.f        tmetric.f\
---
> 	tau2x.f        tdq.f          tinvr.f        tmetric.f \
91,92c92,93
< 	rpatch0.f      cntsurf.f      cctogp.f       umalloc.f \
< 	ufree.f        modread.f      genforce.f     rotsurf.f \
---
> 	rpatch0.f      cntsurf.f      cctogp.f       bc2009.f \
> 	modread.f      genforce.f     rotsurf.f \
102c103,109
< 	init_trim.f    pltmode.f
---
> 	init_trim.f    pltmode.f      bcnonin.f      initnonin.f \
> 	resnonin.f
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f addx.f
107a115,116
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
112,113c121,123
< $(COMMONLIB): $(FSRC_LIBS) $(FOBJ_LIBS) $(CSRC_LIBS) $(COBJ_LIBS)
< 	ar $(AROPT) $(COMMONLIB) $(FOBJ_LIBS) $(COBJ_LIBS) 
---
> $(COMMONLIB): $(FSRC_LIBS) $(FOBJ_LIBS) $(FSRC_SPEC) $(FOBJ_SPEC) \
> 	$(CSRC_LIBS) $(COBJ_LIBS)
> 	ar $(AROPT) $(COMMONLIB) $(FOBJ_LIBS) $(FOBJ_SPEC) $(COBJ_LIBS) 
117a128,130
> 
> $(FOBJ_SPEC):
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
Index: build/cflcmplx/mpi/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cflcmplx/mpi/makefile,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15a16
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
41c42,48
< 	updatedg.F     ae_corr.F      mgbl.F         setslave.F
---
> 	updatedg.F     ae_corr.F      mgbl.F         setslave.F \
> 	umalloc.F
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
44a52,53
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
47,48c56,57
< $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST)
< 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST)
---
> $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST) $(FOBJ_SPEC)
54a64,66
> 
> $(FOBJ_SPEC): $(HEAD_DIST)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
Index: build/cflcmplx/mpi/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cflcmplx/mpi/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15a16
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
48c49,55
< 	updatedg.f     ae_corr.f      mgbl.f         setslave.f
---
> 	updatedg.f     ae_corr.f      mgbl.f         setslave.f \
> 	umalloc.f
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
51a59,60
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
54,55c63,64
< $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST)
< 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST)
---
> $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST) $(FOBJ_SPEC)
61a71,73
> 
> $(FOBJ_SPEC): $(HEAD_DIST)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
Index: build/cflcmplx/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cflcmplx/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15a16
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
41c42,48
< 	updatedg.F     ae_corr.F      mgbl.F         setslave.F
---
> 	updatedg.F     ae_corr.F      mgbl.F         setslave.F \
> 	umalloc.F
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
44a52,53
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
47,48c56,57
< $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST)
< 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST)
---
> $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST) $(FOBJ_SPEC)
54a64,66
> 
> $(FOBJ_SPEC): $(HEAD_DIST)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
Index: build/cflcmplx/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/cflcmplx/seq/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15a16
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
29c30
< 	$(CPP) $(CPPFLAG) $(CPPOPT) $*.F > $*.TMP1
---
> 	$(CPP) $(CPPFLAG) $(CPPOPT) $*.F  > $*.TMP1
48c49,55
< 	updatedg.f     ae_corr.f      mgbl.f         setslave.f
---
> 	updatedg.f     ae_corr.f      mgbl.f         setslave.f \
> 	umalloc.f
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
51a59,60
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
54,55c63,64
< $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST)
< 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST)
---
> $(DISTLIB): $(FSRC_DIST) $(FOBJ_DIST) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(DISTLIB) $(FOBJ_DIST) $(FOBJ_SPEC)
62a72,74
> $(FOBJ_SPEC): $(HEAD_DIST)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
78c90
< $(EXEC): $(FSRC_MAIN) $(FOBJ_MAIN) $(DISTLIB) $(COMMONLIB) 
---
> $(EXEC): $(FSRC_MAIN) $(FOBJ_MAIN) $(DISTLIB) $(COMMONLIB)
Index: build/mag/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/mag/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
14a15
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
28a30,34
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
> 
30a37,38
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
36,37c44,48
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(MAG_HEAD)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/mag/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/mag/seq/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
14a15
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
35a37,41
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
> 
37a44,45
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
43,44c51,55
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(MAG_HEAD)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/precfl/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/precfl/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18,19c18
< 	ln -s $(CFLSRC_S)/umalloc.F .
< 	ln -s $(CFLSRC_S)/ufree.F .
---
> 	ln -s $(CFLSRC_D)/umalloc.F .
38a38
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
51c51
< 	 compg2n.F     umalloc.F        ufree.F          cntsurf.F \
---
> 	 compg2n.F     umalloc.F        cntsurf.F \
56a57,61
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
> 
58a64,65
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
64,65c71,75
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(PRE_HEAD)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/precfl/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/precfl/seq/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18,19c18
< 	ln -s $(CFLSRC_S)/umalloc.F .
< 	ln -s $(CFLSRC_S)/ufree.F .
---
> 	ln -s $(CFLSRC_D)/umalloc.F .
38a38
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
58c58
< 	 compg2n.f     umalloc.f        ufree.f          cntsurf.f \
---
> 	 compg2n.f     umalloc.f        cntsurf.f \
63a64,68
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
> 
65a71,72
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
71,72c78,82
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(PRE_HEAD)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/preron/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/preron/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18,19c18
< 	ln -s  $(CFLSRC_S)/umalloc.F .
< 	ln -s  $(CFLSRC_S)/ufree.F .
---
> 	ln -s  $(CFLSRC_D)/umalloc.F .
22a22
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
33c33
< SOURCE = global2.F    termn8.F    usrint.F    umalloc.F   ufree.F \
---
> SOURCE = global2.F    termn8.F    usrint.F    umalloc.F \
35a36,40
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
> 
37a43,44
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
43,44c50,54
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(PRERON_HEAD)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/preron/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/preron/seq/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18,19c18
< 	ln -s  $(CFLSRC_S)/umalloc.F .
< 	ln -s  $(CFLSRC_S)/ufree.F .
---
> 	ln -s  $(CFLSRC_D)/umalloc.F .
22a22
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
40c40
< SOURCE = global2.f    termn8.f    usrint.f    umalloc.f   ufree.f\
---
> SOURCE = global2.f    termn8.f    usrint.f    umalloc.f \
42a43,47
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
> 
44a50,51
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
50,51c57,61
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(PRERON_HEAD)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/ron/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/ron/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
17,18c17
< 	ln -s  $(CFLSRC_S)/umalloc.F .
< 	ln -s  $(CFLSRC_S)/ufree.F .
---
> 	ln -s  $(CFLSRC_D)/umalloc.F .
48a48
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
66c66,71
< 	 ufree.F      pre_patch.F  sizer.F      ccomplex.F   main.F
---
> 	 pre_patch.F  sizer.F      ccomplex.F   main.F
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
69a75,76
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
75,76c82,86
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(RON_HEAD)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/ron/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/ron/seq/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
17,18c17
< 	ln -s  $(CFLSRC_S)/umalloc.F .
< 	ln -s  $(CFLSRC_S)/ufree.F .
---
> 	ln -s  $(CFLSRC_D)/umalloc.F .
48a48
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
73c73,78
< 	 ufree.f      pre_patch.f  sizer.f      ccomplex.f   main.f
---
> 	 pre_patch.f  sizer.f      ccomplex.f   main.f
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
76a82,83
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
82,83c89,93
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(RON_HEAD)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/split/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/split/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15,16c15
< 	ln -s $(CFLSRC_S)/umalloc.F .
< 	ln -s $(CFLSRC_S)/ufree.F .
---
> 	ln -s $(CFLSRC_D)/umalloc.F .
19a19
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
35c35
< 	 ufree.F            mkseg.F       splt2.F      ingrd.F \
---
> 	 mkseg.F            splt2.F       ingrd.F \
37a38,41
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
40a45,46
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
46,47c52,56
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(CPPOPT) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(SPLIT_HEAD)
> 	$(FTN) $(FFLAG_SPEC) -c $*.F
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/split/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/split/seq/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15,16c15
< 	ln -s $(CFLSRC_S)/umalloc.F .
< 	ln -s $(CFLSRC_S)/ufree.F .
---
> 	ln -s $(CFLSRC_D)/umalloc.F .
19a19
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
42c42
< 	 ufree.f            mkseg.f       splt2.f      ingrd.f \
---
> 	 mkseg.f            splt2.f       ingrd.f \
44a45,48
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
47a52,53
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
53,54c59,63
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(SPLIT_HEAD)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/splitcmplx/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/splitcmplx/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15,18c15,16
< 	ln -s $(CFLSRC_S)/umalloc.F .
< 	ln -s $(CFLSRC_S)/ufree.F .
< 	ln -s $(CFLSRC_S)/umalloc_c.F .
< 	ln -s $(CFLSRC_S)/ufree_c.F .
---
> 	ln -s $(CFLSRC_D)/umalloc.F .
> 	ln -s $(CFLSRC_D)/umalloc_c.F .
21a20
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
37,38c36,37
< 	 ufree.F            mkseg.F       splt2.F         ingrd_cmplx.F \
< 	 umalloc_c.F        ufree_c.F     readkey.F       parser.F \
---
> 	 mkseg.F            splt2.F       ingrd_cmplx.F \
> 	 umalloc_c.F        readkey.F     parser.F \
40a40,43
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
43a47,48
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
49,50c54,58
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(SPLIT_HEAD)
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(CPPOPT) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/splitcmplx/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/splitcmplx/seq/makefile_cpp,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15,18c15,16
< 	ln -s $(CFLSRC_S)/umalloc.F .
< 	ln -s $(CFLSRC_S)/ufree.F .
< 	ln -s $(CFLSRC_S)/umalloc_c.F .
< 	ln -s $(CFLSRC_S)/ufree_c.F .
---
> 	ln -s $(CFLSRC_D)/umalloc.F .
> 	ln -s $(CFLSRC_D)/umalloc_c.F .
21a20
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
44,45c43,44
< 	 ufree.f            mkseg.f       splt2.f         ingrd_cmplx.f \
< 	 umalloc_c.f        ufree_c.f     readkey.f       parser.f \
---
> 	 mkseg.f            splt2.f       ingrd_cmplx.f \
> 	 umalloc_c.f        readkey.f     parser.f \
47a47,50
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
50a54,55
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
56,57c61,65
< $(EXEC): $(SOURCE) $(OBJECT)
< 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(LLIBS)
---
> $(FOBJ_SPEC): $(SPLIT_HEAD)
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
> $(EXEC): $(SOURCE) $(OBJECT) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	$(FTN) $(LFLAG) -o $(EXEC) $(OBJECT) $(FOBJ_SPEC) $(LLIBS)
Index: build/tools/seq/makefile
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/tools/seq/makefile,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15,18c15,16
< 	ln -s $(CFLSRC_S)/umalloc_r.F .
< 	ln -s $(CFLSRC_S)/umalloc_c.F .
< 	ln -s $(CFLSRC_S)/ufree_r.F .
< 	ln -s $(CFLSRC_S)/ufree_c.F .
---
> 	ln -s $(CFLSRC_D)/umalloc_r.F .
> 	ln -s $(CFLSRC_D)/umalloc_c.F .
24a23
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
35c34
< SOURCELIBS = umalloc_c.F ufree_c.F umalloc_r.F ufree_r.F \
---
> SOURCELIBS = umalloc_c.F umalloc_r.F \
37a37,41
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.F
> 
39a44,45
> FOBJ_SPEC = $(FSRC_SPEC:.F=.o)
> 
42,43c48,49
< $(LIBS): $(SOURCELIBS) $(OBJECTLIBS)
< 	ar $(AROPT) $(LIBS) $(OBJECTLIBS)
---
> $(LIBS): $(SOURCELIBS) $(OBJECTLIBS) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(LIBS) $(OBJECTLIBS) $(FOBJ_SPEC)
47a54,56
> 
> $(FOBJ_SPEC):
> 	$(FTN) $(CPPOPT) $(FFLAG_SPEC) -c $*.F
Index: build/tools/seq/makefile_cpp
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/build/tools/seq/makefile_cpp,v
retrieving revision 1.3
retrieving revision 1.5
diff -r1.3 -r1.5
1c1
< #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> #     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15,18c15,16
< 	ln -s $(CFLSRC_S)/umalloc_r.F .
< 	ln -s $(CFLSRC_S)/umalloc_c.F .
< 	ln -s $(CFLSRC_S)/ufree_r.F .
< 	ln -s $(CFLSRC_S)/ufree_c.F .
---
> 	ln -s $(CFLSRC_D)/umalloc_r.F .
> 	ln -s $(CFLSRC_D)/umalloc_c.F .
24a23
> 	ln -s $(CFLSRC_D)/development.F_clean fake.F
42c41,47
< SOURCELIBS = umalloc_c.f ufree_c.f umalloc_r.f ufree_r.f
---
> SOURCELIBS = umalloc_c.f umalloc_r.f \
> 	readkey.f global0.f cgnstools.f termn8.f parser.f outbuf.f
> 
> #place routines needing special compilation flags (e.g low-level optimization)
> #in FSRC_SPEC...include a fake routine in case there are no others
> 
> FSRC_SPEC = fake.f
45a51,52
> FOBJ_SPEC = $(FSRC_SPEC:.f=.o)
> 
48,49c55,56
< $(LIBS): $(SOURCELIBS) $(OBJECTLIBS)
< 	ar $(AROPT) $(LIBS) $(OBJECTLIBS)
---
> $(LIBS): $(SOURCELIBS) $(OBJECTLIBS) $(FSRC_SPEC) $(FOBJ_SPEC)
> 	ar $(AROPT) $(LIBS) $(OBJECTLIBS) $(FOBJ_SPEC)
54a62,64
> $(FOBJ_SPEC):
> 	$(FTN) $(FFLAG_SPEC) -c $*.f
> 
63c73
< SOURCE9  = readkey.f global0.f cgnstools.f termn8.f parser.f outbuf.f cfl3d_to_pegbc.f
---
> SOURCE9  = cfl3d_to_pegbc.f
Index: header/mag1.h
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/header/mag1.h,v
retrieving revision 1.1.1.1
retrieving revision 1.5
diff -r1.1.1.1 -r1.5
Index: source/cfl3d/dist/ae_corr.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/ae_corr.F,v
retrieving revision 1.2
retrieving revision 1.6
diff -r1.2 -r1.6
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
67c67
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/dist/bc_blkint.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/bc_blkint.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
9c9
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
58c58
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
191c191
<                         lvolk0 = lw(49,ic_blk)
---
>                         lvolk0 = lw(50,ic_blk)
196,198c196,198
<      .                              kdimn,idimc,jdimc,limblk(1,1,n),
<      .                              isva(1,1,n),it,ir,ldim,
<      .                              w(lbck),iedge,1)
---
>      .                               kdimn,idimc,jdimc,limblk(1,1,n),
>      .                               isva(1,1,n),it,ir,ldim,
>      .                               w(lbck),iedge,1)
255c255
<                         lvolj0 = lw(48,ic_blk)
---
>                         lvolj0 = lw(49,ic_blk)
319c319
<                         lvoli0 = lw(50,ic_blk)
---
>                         lvoli0 = lw(51,ic_blk)
321c321
<                            lvojk0 = lvolj0 + jdimc*kdimc*1*2
---
>                            lvoli0 = lvoli0 + jdimc*kdimc*1*2
852c852
<                         lvolk0 = lw(49,ic_blk)
---
>                         lvolk0 = lw(50,ic_blk)
858,860c858,860
<      .                                kdimn,idimc,jdimc,limblk(1,1,n),
<      .                                isva(1,1,n),it,ir,maxdims,ldim,
<      .                                w(lbck),iedge)
---
>      .                                 kdimn,idimc,jdimc,limblk(1,1,n),
>      .                                 isva(1,1,n),it,ir,maxdims,ldim,
>      .                                 w(lbck),iedge)
928c928
<                         lvolj0 = lw(48,ic_blk)
---
>                         lvolj0 = lw(49,ic_blk)
1004c1004
<                         lvoli0 = lw(50,ic_blk)
---
>                         lvoli0 = lw(51,ic_blk)
1006c1006
<                            lvolj0 = lvolj0 + jdimc*kdimc*1*2
---
>                            lvoli0 = lvoli0 + jdimc*kdimc*1*2
1010,1012c1010,1012
<      .                                kdimn,jdimc,kdimc,limblk(1,1,n),
<      .                                isva(1,1,n),it,ir,maxdims,ldim,
<      .                                w(lbci),iedge)
---
>      .                                 kdimn,jdimc,kdimc,limblk(1,1,n),
>      .                                 isva(1,1,n),it,ir,maxdims,ldim,
>      .                                 w(lbci),iedge)
Index: source/cfl3d/dist/bc_embed.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/bc_embed.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
55c55
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/dist/bc_period.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/bc_period.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
10c10
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
70c70
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/dist/cfl3d.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/cfl3d.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
41a42
>       integer stats
43,48d43
<       dimension bcfilei(maxbl,maxseg,2),bcfilej(maxbl,maxseg,2),
<      .          bcfilek(maxbl,maxseg,2)
<       dimension istat2_bl(istat_size,mxbli*5),
<      .          istat2_pa(istat_size,intmax*nsub1*3),
<      .          istat2_em(istat_size,lbcemb*3),
<      .          istat2_pe(istat_size,lbcprd*5)
50,297d44
<       dimension work(mwork),iwork(mworki),lwdat(maxbl,maxseg,6)
<       dimension lw(65,maxbl),lw2(43,maxbl)
<       dimension nblk(2,mxbli),limblk(2,6,mxbli),
<      .          isva(2,2,mxbli),nblon(mxbli)
<       dimension resmx(maxbl),imx(maxbl),jmx(maxbl),kmx(maxbl)
<       dimension vormax(maxbl),ivmax(maxbl),jvmax(maxbl),kvmax(maxbl)
<       dimension lig(maxbl),lbg(maxbl),iovrlp(maxbl),qb(iitot,5,3)
<       dimension ibpntsg(maxbl,4),iipntsg(maxbl)
<       dimension iibg(iitot),kkbg(iitot),jjbg(iitot),ibcg(iitot)
<       dimension dxintg(iitot),dyintg(iitot),dzintg(iitot),
<      .          iiig(iitot),jjig(iitot),kkig(iitot)
<       dimension rkap0g(maxbl,3),levelg(maxbl),igridg(maxbl),
<      .          iflimg(maxbl,3),ifdsg(maxbl,3),iviscg(maxbl,3),
<      .          jdimg(maxbl),kdimg(maxbl),idimg(maxbl),idiagg(maxbl,3),
<      .          nblcg(maxbl),idegg(maxbl,3),
<      .          jsg(maxbl),ksg(maxbl),isg(maxbl),jeg(maxbl),keg(maxbl),
<      .          ieg(maxbl),mit(5,maxbl),ilamlog(maxbl),ilamhig(maxbl),
<      .          jlamlog(maxbl),jlamhig(maxbl),klamlog(maxbl),
<      .          klamhig(maxbl),iwfg(maxbl,3)
<       dimension utrans(maxbl),vtrans(maxbl),wtrans(maxbl),
<      .          omegax(maxbl),omegay(maxbl),omegaz(maxbl),xorig(maxbl),
<      .          yorig(maxbl),zorig(maxbl),dxmx(maxbl),dymx(maxbl),
<      .          dzmx(maxbl),dthxmx(maxbl),dthymx(maxbl),dthzmx(maxbl),
<      .          thetax(maxbl),thetay(maxbl),thetaz(maxbl),rfreqt(maxbl),
<      .          rfreqr(maxbl),xorig0(maxbl),yorig0(maxbl),zorig0(maxbl),
<      .          time2(maxbl),thetaxl(maxbl),thetayl(maxbl),
<      .          thetazl(maxbl),itrans(maxbl),irotat(maxbl),idefrm(maxbl)
<       dimension bcvali(maxbl,maxseg,7,2),
<      .          bcvalj(maxbl,maxseg,7,2),bcvalk(maxbl,maxseg,7,2),
<      .          nbci0(maxbl),nbcidim(maxbl),nbcj0(maxbl),nbcjdim(maxbl),
<      .          nbck0(maxbl),nbckdim(maxbl),ibcinfo(maxbl,maxseg,7,2),
<      .          jbcinfo(maxbl,maxseg,7,2),kbcinfo(maxbl,maxseg,7,2)
<       dimension ncgg(maxgr),nblg(maxgr),iemg(maxgr),inewgg(maxgr)
<       dimension inpl3d(nplots,11),inpr(nplots,11)
<       dimension iadvance(maxbl),iforce(maxbl)
<       dimension rms(ncycmax),clw(ncycmax),
<      .          cdw(ncycmax),cdpw(ncycmax),cdvw(ncycmax),
<      .          cxw(ncycmax),cyw(ncycmax),czw(ncycmax),
<      .          cmxw(ncycmax),cmyw(ncycmax),cmzw(ncycmax),
<      .          chdw(ncycmax),swetw(ncycmax),
<      .          fmdotw(ncycmax),cfttotw(ncycmax),
<      .          cftmomw(ncycmax),cftpw(ncycmax),cftvw(ncycmax),
<      .          rmstr1(ncycmax),rmstr2(ncycmax),
<      .          nneg1(ncycmax),nneg2(ncycmax),timekeep(ncycmax)
<       dimension swett(maxbl),clt(maxbl),cdt(maxbl),cxt(maxbl),
<      .          cyt(maxbl),czt(maxbl),cmxt(maxbl),cmyt(maxbl),
<      .          cmzt(maxbl),cdpt(maxbl),cdvt(maxbl)
<       dimension sx(maxcs),sy(maxcs),sz(maxcs),stot(maxcs),
<      .          pav(maxcs),ptav(maxcs),tav(maxcs),ttav(maxcs),
<      .          xmav(maxcs),fmdot(maxcs),
<      .          cfxp(maxcs),cfyp(maxcs),cfzp(maxcs),
<      .          cfdp(maxcs),cflp(maxcs),cftp(maxcs),
<      .          cfxv(maxcs),cfyv(maxcs),cfzv(maxcs),
<      .          cfdv(maxcs),cflv(maxcs),cftv(maxcs),
<      .          cfxmom(maxcs),cfymom(maxcs),cfzmom(maxcs),
<      .          cfdmom(maxcs),cflmom(maxcs),cftmom(maxcs),
<      .          cfxtot(maxcs),cfytot(maxcs),cfztot(maxcs),
<      .          cfdtot(maxcs),cfltot(maxcs),cfttot(maxcs),
<      .          icsinfo(maxcs,9)
<       dimension windex(maxxe,2),iindex(intmax,6*nsub1+9),
<      .          nblkpt(maxxe)
<       dimension windx(mxxe,2),iindx(intmx,6*msub1+9),
<      .          llimit(intmx),iitmax(intmx),mmcxie(intmx),
<      .          mmceta(intmx),ncheck(maxbl),iifit(intmx),
<      .          mblkpt(mxxe),iic0(intmx),iiorph(intmx),iitoss(intmx),
<      .          ifiner(intmx)
<       dimension dthetxx(intmax,nsub1),dthetyy(intmax,nsub1),
<      .          dthetzz(intmax,nsub1)
<       dimension dx(intmx,msub1),dy(intmx,msub1),dz(intmx,msub1),
<      .          dthetx(intmx,msub1),dthety(intmx,msub1),
<      .          dthetz(intmx,msub1)
<       dimension lout(msub1),xif1(msub1),xif2(msub1),etf1(msub1),
<      .          etf2(msub1),jjmax1(nsub1),kkmax1(nsub1),iiint1(nsub1),
<      .          iiint2(nsub1),jimage(msub1,mptch+2,mptch+2),
<      .          kimage(msub1,mptch+2,mptch+2),jte(msub1),kte(msub1),
<      .          jmm(mptch+2),kmm(mptch+2),nblk1(mptch+2),nblk2(mptch+2),
<      .          xte(mptch+2,mptch+2,msub1),yte(mptch+2,mptch+2,msub1),
<      .          zte(mptch+2,mptch+2,msub1),xmi(mptch+2,mptch+2,msub1),
<      .          ymi(mptch+2,mptch+2,msub1),zmi(mptch+2,mptch+2,msub1),
<      .          xmie(mptch+2,mptch+2,msub1),ymie(mptch+2,mptch+2,msub1),
<      .          zmie(mptch+2,mptch+2,msub1),sxie(mptch+2,mptch+2,msub1),
<      .          seta(mptch+2,mptch+2,msub1),sxie2(mptch+2,mptch+2),
<      .          seta2(mptch+2,mptch+2),xie2s(mptch+2,mptch+2),
<      .          eta2s(mptch+2,mptch+2),temp((mptch+2)*(mptch+2)),
<      .          x2(mptch+2,mptch+2),y2(mptch+2,mptch+2),
<      .          z2(mptch+2,mptch+2),x1(mptch+2,mptch+2),
<      .          y1(mptch+2,mptch+2),z1(mptch+2,mptch+2),
<      .          factjlo(intmx,msub1),factjhi(intmx,msub1),
<      .          factklo(intmx,msub1),factkhi(intmx,msub1),ifrom(msub1)
<       dimension geom_miss(2*mxbli),period_miss(lbcprd)
<       dimension isav_blk(2*mxbli,17)
<       dimension isav_prd(lbcprd,12)
<       dimension isav_pat(intmax,17),isav_pat_b(intmax,nsub1,6)
<       dimension isav_dpat(intmx,17),isav_dpat_b(intmx,msub1,6)
<       dimension isav_emb(lbcemb,12)
<       dimension mblk2nd(maxbl)
<       dimension utrnsae(maxbl,maxsegdg),vtrnsae(maxbl,maxsegdg),
<      .          wtrnsae(maxbl,maxsegdg),omgxae(maxbl,maxsegdg),
<      .          omgyae(maxbl,maxsegdg),omgzae(maxbl,maxsegdg),
<      .          xorgae(maxbl,maxsegdg),yorgae(maxbl,maxsegdg),
<      .          zorgae(maxbl,maxsegdg),thtxae(maxbl,maxsegdg),
<      .          thtyae(maxbl,maxsegdg),thtzae(maxbl,maxsegdg),
<      .          rfrqtae(maxbl,maxsegdg),rfrqrae(maxbl,maxsegdg)
<       dimension xorgae0(maxbl,maxsegdg),yorgae0(maxbl,maxsegdg),
<      .          zorgae0(maxbl,maxsegdg),icouple(maxbl,maxsegdg)
<       dimension icsi(maxbl,maxsegdg),icsf(maxbl,maxsegdg),
<      .          jcsi(maxbl,maxsegdg),jcsf(maxbl,maxsegdg),
<      .          kcsi(maxbl,maxsegdg),kcsf(maxbl,maxsegdg)
<       dimension nsegdfrm(maxbl),idfrmseg(maxbl,maxsegdg),
<      .          iaesurf(maxbl,maxsegdg)
<       dimension freq(nmds,maxaes),gmass(nmds,maxaes),x0(2*nmds,maxaes),
<      .          gf0(2*nmds,maxaes),damp(nmds,maxaes),
<      .          perturb(nmds,maxaes,4),aehist(ncycmax,3,nmds,maxaes)
<       dimension aesrfdat(5,maxaes),slavept(nslave,3,nmaster,5)
<       dimension iskip(maxbl),jskip(maxbl),kskip(maxbl)
<       dimension bmat(2*nmds,2*nmds,maxaes),gforcn(2*nmds,maxaes),
<      .          gforcnm(2*nmds,maxaes),gforcs(2*nmds,maxaes),
<      .          stm(2*nmds,2*nmds,maxaes),stmi(2*nmds,2*nmds,maxaes),
<      .          xs(2*nmds,maxaes),xxn(2*nmds,maxaes)
< c
<       pointer (ip_work,work),(ip_iwork,iwork),(ip_lwdat,lwdat)
<       pointer (ip_lw,lw),(ip_lw2,lw2)
<       pointer (ip_nblk,nblk),(ip_limblk,limblk),
<      .        (ip_isva,isva),(ip_nblon,nblon)
<       pointer (ip_resmx,resmx),(ip_imx,imx),(ip_jmx,jmx),(ip_kmx,kmx)
<       pointer (ip_vormax,vormax),(ip_ivmax,ivmax),(ip_jvmax,jvmax),
<      .        (ip_kvmax,kvmax)
<       pointer (ip_lig,lig),(ip_lbg,lbg),(ip_iovrlp,iovrlp),(ip_qb,qb)
<       pointer (ip_ibpntsg,ibpntsg),(ip_iipntsg,iipntsg)
<       pointer (ip_iibg,iibg),(ip_kkbg,kkbg),(ip_jjbg,jjbg),
<      .        (ip_ibcg,ibcg)
<       pointer (ip_dxintg,dxintg),(ip_dyintg,dyintg),(ip_dzintg,dzintg),
<      .        (ip_iiig,iiig),(ip_jjig,jjig),(ip_kkig,kkig)
<       pointer (ip_rkap0g,rkap0g),(ip_levelg,levelg),(ip_igridg,igridg),
<      .        (ip_iflimg,iflimg),(ip_ifdsg,ifdsg),(ip_iviscg,iviscg),
<      .        (ip_jdimg,jdimg),(ip_kdimg,kdimg),(ip_idimg,idimg),
<      .        (ip_idiagg,idiagg),(ip_nblcg,nblcg),(ip_idegg,idegg),
<      .        (ip_jsg,jsg),(ip_ksg,ksg),(ip_isg,isg),(ip_jeg,jeg),
<      .        (ip_keg,keg),(ip_ieg,ieg),(ip_mit,mit),
<      .        (ip_ilamlog,ilamlog),(ip_ilamhig,ilamhig),
<      .        (ip_jlamlog,jlamlog),(ip_jlamhig,jlamhig),
<      .        (ip_klamlog,klamlog),(ip_klamhig,klamhig),(ip_iwfg,iwfg)
<       pointer (ip_utrans,utrans),(ip_vtrans,vtrans),(ip_wtrans,wtrans),
<      .        (ip_omegax,omegax),(ip_omegay,omegay),(ip_omegaz,omegaz),
<      .        (ip_xorig,xorig),(ip_yorig,yorig),(ip_zorig,zorig),
<      .        (ip_dxmx,dxmx),(ip_dymx,dymx),
<      .        (ip_dzmx,dzmx),(ip_dthxmx,dthxmx),(ip_dthymx,dthymx),
<      .        (ip_dthzmx,dthzmx),(ip_thetax,thetax),(ip_thetay,thetay),
<      .        (ip_thetaz,thetaz),(ip_rfreqt,rfreqt),
<      .        (ip_rfreqr,rfreqr),(ip_xorig0,xorig0),(ip_yorig0,yorig0),
<      .        (ip_zorig0,zorig0),(ip_time2,time2),(ip_thetaxl,thetaxl),
<      .        (ip_thetayl,thetayl),(ip_thetazl,thetazl),
<      .        (ip_itrans,itrans),(ip_irotat,irotat),(ip_idefrm,idefrm)
<       pointer (ip_bcvali,bcvali),(ip_bcvalj,bcvalj),
<      .        (ip_bcvalk,bcvalk),(ip_nbci0,nbci0),
<      .        (ip_nbcidim,nbcidim),(ip_nbcj0,nbcj0),
<      .        (ip_nbcjdim,nbcjdim),(ip_nbck0,nbck0),
<      .        (ip_nbckdim,nbckdim),(ip_ibcinfo,ibcinfo),
<      .        (ip_jbcinfo,jbcinfo),(ip_kbcinfo,kbcinfo)
<       pointer (ip_bcfilei,bcfilei),(ip_bcfilej,bcfilej),
<      .        (ip_bcfilek,bcfilek)
<       pointer (ip_ncgg,ncgg),(ip_nblg,nblg),(ip_iemg,iemg),
<      .        (ip_inewgg,inewgg)
<       pointer (ip_inpl3d,inpl3d),(ip_inpr,inpr)
<       pointer (ip_iadvance,iadvance),(ip_iforce,iforce)
<       pointer (ip_rms,rms),(ip_clw,clw),
<      .        (ip_cdw,cdw),(ip_cdpw,cdpw),(ip_cdvw,cdvw),
<      .        (ip_cxw,cxw),(ip_cyw,cyw),(ip_czw,czw),
<      .        (ip_cmxw,cmxw),(ip_cmyw,cmyw),(ip_cmzw,cmzw),
<      .        (ip_chdw,chdw),(ip_swetw,swetw),
<      .        (ip_fmdotw,fmdotw),(ip_cfttotw,cfttotw),
<      .        (ip_cftmomw,cftmomw),(ip_cftpw,cftpw),(ip_cftvw,cftvw),
<      .        (ip_rmstr1,rmstr1),(ip_rmstr2,rmstr2),
<      .        (ip_nneg1,nneg1),(ip_nneg2,nneg2),(ip_timekeep,timekeep)
<       pointer (ip_swett,swett),(ip_clt,clt),(ip_cdt,cdt),(ip_cxt,cxt),
<      .        (ip_cyt,cyt),(ip_czt,czt),(ip_cmxt,cmxt),(ip_cmyt,cmyt),
<      .        (ip_cmzt,cmzt),(ip_cdpt,cdpt),(ip_cdvt,cdvt)
<       pointer (ip_sx,sx),(ip_sy,sy),(ip_sz,sz),(ip_stot,stot),
<      .        (ip_pav,pav),(ip_ptav,ptav),(ip_tav,tav),(ip_ttav,ttav),
<      .        (ip_xmav,xmav),(ip_fmdot,fmdot),
<      .        (ip_cfxp,cfxp),(ip_cfyp,cfyp),(ip_cfzp,cfzp),
<      .        (ip_cfdp,cfdp),(ip_cflp,cflp),(ip_cftp,cftp),
<      .        (ip_cfxv,cfxv),(ip_cfyv,cfyv),(ip_cfzv,cfzv),
<      .        (ip_cfdv,cfdv),(ip_cflv,cflv),(ip_cftv,cftv),
<      .        (ip_cfxmom,cfxmom),(ip_cfymom,cfymom),(ip_cfzmom,cfzmom),
<      .        (ip_cfdmom,cfdmom),(ip_cflmom,cflmom),(ip_cftmom,cftmom),
<      .        (ip_cfxtot,cfxtot),(ip_cfytot,cfytot),(ip_cfztot,cfztot),
<      .        (ip_cfdtot,cfdtot),(ip_cfltot,cfltot),(ip_cfttot,cfttot),
<      .        (ip_icsinfo,icsinfo)
<       pointer (ip_windex,windex),(ip_iindex,iindex),
<      .        (ip_nblkpt,nblkpt)
<       pointer (ip_windx,windx),(ip_iindx,iindx),
<      .        (ip_llimit,llimit),(ip_iitmax,iitmax),(ip_mmcxie,mmcxie),
<      .        (ip_mmceta,mmceta),(ip_ncheck,ncheck),(ip_iifit,iifit),
<      .        (ip_mblkpt,mblkpt),(ip_iic0,iic0),(ip_iiorph,iiorph),
<      .        (ip_iitoss,iitoss),(ip_ifiner,ifiner)
<       pointer (ip_dthetxx,dthetxx),(ip_dthetyy,dthetyy),
<      .        (ip_dthetzz,dthetzz)
<       pointer (ip_dx,dx),(ip_dy,dy),(ip_dz,dz),
<      .        (ip_dthetx,dthetx),(ip_dthety,dthety),
<      .        (ip_dthetz,dthetz)
<       pointer (ip_lout,lout),(ip_xif1,xif1),(ip_xif2,xif2),
<      .        (ip_etf1,etf1),(ip_etf2,etf2),
<      .        (ip_jjmax1,jjmax1),(ip_kkmax1,kkmax1),(ip_iiint1,iiint1),
<      .        (ip_iiint2,iiint2),(ip_jimage,jimage),
<      .        (ip_kimage,kimage),(ip_jte,jte),(ip_kte,kte),
<      .        (ip_jmm,jmm),(ip_kmm,kmm),(ip_nblk1,nblk1),
<      .        (ip_nblk2,nblk2),(ip_xte,xte),(ip_yte,yte),
<      .        (ip_zte,zte),(ip_xmi,xmi),
<      .        (ip_ymi,ymi),(ip_zmi,zmi),
<      .        (ip_xmie,xmie),(ip_ymie,ymie),
<      .        (ip_zmie,zmie),(ip_sxie,sxie),
<      .        (ip_seta,seta),(ip_sxie2,sxie2),
<      .        (ip_seta2,seta2),(ip_xie2s,xie2s),
<      .        (ip_eta2s,eta2s),(ip_temp,temp),
<      .        (ip_x2,x2),(ip_y2,y2),
<      .        (ip_z2,z2),(ip_x1,x1),
<      .        (ip_y1,y1),(ip_z1,z1),
<      .        (ip_factjlo,factjlo),(ip_factjhi,factjhi),
<      .        (ip_factklo,factklo),(ip_factkhi,factkhi),
<      .        (ip_ifrom,ifrom)
<       pointer (ip_geom_miss,geom_miss),(ip_period_miss,period_miss)
<       pointer (ip_isav_blk,isav_blk)
<       pointer (ip_isav_prd,isav_prd)
<       pointer (ip_isav_pat,isav_pat),(ip_isav_pat_b,isav_pat_b)
<       pointer (ip_isav_dpat,isav_dpat),(ip_isav_dpat_b,isav_dpat_b)
<       pointer (ip_isav_emb,isav_emb)
<       pointer (ip_mblk2nd,mblk2nd)
<       pointer (ip_istat2_bl,istat2_bl),(ip_istat2_pa,istat2_pa),
<      .        (ip_istat2_em,istat2_em),(ip_istat2_pe,istat2_pe)
<       pointer (ip_aesrfdat,aesrfdat),(ip_utrnsae,utrnsae),
<      .        (ip_vtrnsae,vtrnsae),(ip_wtrnsae,wtrnsae),
<      .        (ip_omgxae,omgxae),(ip_omgyae,omgyae),(ip_omgzae,omgzae),
<      .        (ip_xorgae,xorgae),(ip_yorgae,yorgae),(ip_zorgae,zorgae),
<      .        (ip_xorgae0,xorgae0),(ip_yorgae0,yorgae0),
<      .        (ip_zorgae0,zorgae0),(ip_icouple,icouple),
<      .        (ip_thtxae,thtxae),(ip_thtyae,thtyae),(ip_thtzae,thtzae),
<      .        (ip_rfrqtae,rfrqtae),(ip_rfrqrae,rfrqrae),(ip_icsi,icsi),
<      .        (ip_icsf,icsf),(ip_jcsi,jcsi),(ip_jcsf,jcsf),
<      .        (ip_kcsi,kcsi),(ip_kcsf,kcsf),(ip_freq,freq),
<      .        (ip_gmass,gmass),(ip_damp,damp),(ip_x0,x0),(ip_gf0,gf0),
<      .        (ip_perturb,perturb),(ip_slavept,slavept),
<      .        (ip_iskip,iskip),(ip_jskip,jskip),(ip_kskip,kskip),
<      .        (ip_bmat,bmat),(ip_stm,stm),(ip_stmi,stmi),(ip_xs,xs),
<      .        (ip_xxn,xxn),(ip_gforcn,gforcn),(ip_gforcnm,gforcnm),
<      .        (ip_gforcs,gforcs),(ip_nsegdfrm,nsegdfrm),
<      .        (ip_idfrmseg,idfrmseg),(ip_iaesurf,iaesurf),
<      .        (ip_aehist,aehist)
299,303c46,357
< c     keep work array pointers in common to avoid "stacksize limit"
< c     problems on SGIs
< c
<       common /wrk/ ip_work
<       common /wrki/ ip_iwork
---
>       allocatable :: aehist(:,:,:,:)
>       allocatable :: aesrfdat(:,:)
>       allocatable :: bcfilei(:,:,:)
>       allocatable :: bcfilej(:,:,:)
>       allocatable :: bcfilek(:,:,:)
>       allocatable :: bcvali(:,:,:,:)
>       allocatable :: bcvalj(:,:,:,:)
>       allocatable :: bcvalk(:,:,:,:)
>       allocatable :: bmat(:,:,:)
>       allocatable :: cdpt(:)
>       allocatable :: cdpw(:)
>       allocatable :: cdt(:)
>       allocatable :: cdvt(:)
>       allocatable :: cdvw(:)
>       allocatable :: cdw(:)
>       allocatable :: cfdmom(:)
>       allocatable :: cfdp(:)
>       allocatable :: cfdtot(:)
>       allocatable :: cfdv(:)
>       allocatable :: cflmom(:)
>       allocatable :: cflp(:)
>       allocatable :: cfltot(:)
>       allocatable :: cflv(:)
>       allocatable :: cftmom(:)
>       allocatable :: cftmomw(:)
>       allocatable :: cftp(:)
>       allocatable :: cftpw(:)
>       allocatable :: cfttot(:)
>       allocatable :: cfttotw(:)
>       allocatable :: cftv(:)
>       allocatable :: cftvw(:)
>       allocatable :: cfxmom(:)
>       allocatable :: cfxp(:)
>       allocatable :: cfxtot(:)
>       allocatable :: cfxv(:)
>       allocatable :: cfymom(:)
>       allocatable :: cfyp(:)
>       allocatable :: cfytot(:)
>       allocatable :: cfyv(:)
>       allocatable :: cfzmom(:)
>       allocatable :: cfzp(:)
>       allocatable :: cfztot(:)
>       allocatable :: cfzv(:)
>       allocatable :: chdw(:)
>       allocatable :: clt(:)
>       allocatable :: clw(:)
>       allocatable :: cmxt(:)
>       allocatable :: cmxw(:)
>       allocatable :: cmyt(:)
>       allocatable :: cmyw(:)
>       allocatable :: cmzt(:)
>       allocatable :: cmzw(:)
>       allocatable :: cxt(:)
>       allocatable :: cxw(:)
>       allocatable :: cyt(:)
>       allocatable :: cyw(:)
>       allocatable :: czt(:)
>       allocatable :: czw(:)
>       allocatable :: damp(:,:)
>       allocatable :: dthetx(:,:)
>       allocatable :: dthetxx(:,:)
>       allocatable :: dthety(:,:)
>       allocatable :: dthetyy(:,:)
>       allocatable :: dthetz(:,:)
>       allocatable :: dthetzz(:,:)
>       allocatable :: dthxmx(:)
>       allocatable :: dthymx(:)
>       allocatable :: dthzmx(:)
>       allocatable :: dx(:,:)
>       allocatable :: dxintg(:)
>       allocatable :: dxmx(:)
>       allocatable :: dy(:,:)
>       allocatable :: dyintg(:)
>       allocatable :: dymx(:)
>       allocatable :: dz(:,:)
>       allocatable :: dzintg(:)
>       allocatable :: dzmx(:)
>       allocatable :: eta2s(:,:)
>       allocatable :: etf1(:)
>       allocatable :: etf2(:)
>       allocatable :: factjhi(:,:)
>       allocatable :: factjlo(:,:)
>       allocatable :: factkhi(:,:)
>       allocatable :: factklo(:,:)
>       allocatable :: fmdot(:)
>       allocatable :: fmdotw(:)
>       allocatable :: freq(:,:)
>       allocatable :: geom_miss(:)
>       allocatable :: gf0(:,:)
>       allocatable :: gforcn(:,:)
>       allocatable :: gforcnm(:,:)
>       allocatable :: gforcs(:,:)
>       allocatable :: gmass(:,:)
>       allocatable :: iadvance(:)
>       allocatable :: iaesurf(:,:)
>       allocatable :: ibcg(:)
>       allocatable :: ibcinfo(:,:,:,:)
>       allocatable :: ibpntsg(:,:)
>       allocatable :: icouple(:,:)
>       allocatable :: icsf(:,:)
>       allocatable :: icsi(:,:)
>       allocatable :: icsinfo(:,:)
>       allocatable :: idefrm(:)
>       allocatable :: idegg(:,:)
>       allocatable :: idfrmseg(:,:)
>       allocatable :: idiagg(:,:)
>       allocatable :: idimg(:)
>       allocatable :: ieg(:)
>       allocatable :: iemg(:)
>       allocatable :: ifdsg(:,:)
>       allocatable :: ifiner(:)
>       allocatable :: iflimg(:,:)
>       allocatable :: iforce(:)
>       allocatable :: ifrom(:)
>       allocatable :: igridg(:)
>       allocatable :: iibg(:)
>       allocatable :: iic0(:)
>       allocatable :: iifit(:)
>       allocatable :: iiig(:)
>       allocatable :: iiint1(:)
>       allocatable :: iiint2(:)
>       allocatable :: iindex(:,:)
>       allocatable :: iindx(:,:)
>       allocatable :: iiorph(:)
>       allocatable :: iipntsg(:)
>       allocatable :: iitmax(:)
>       allocatable :: iitoss(:)
>       allocatable :: ilamhig(:)
>       allocatable :: ilamlog(:)
>       allocatable :: imx(:)
>       allocatable :: inewgg(:)
>       allocatable :: inpl3d(:,:)
>       allocatable :: inpr(:,:)
>       allocatable :: iovrlp(:)
>       allocatable :: irotat(:)
>       allocatable :: isav_blk(:,:)
>       allocatable :: isav_dpat(:,:)
>       allocatable :: isav_dpat_b(:,:,:)
>       allocatable :: isav_emb(:,:)
>       allocatable :: isav_pat(:,:)
>       allocatable :: isav_pat_b(:,:,:)
>       allocatable :: isav_prd(:,:)
>       allocatable :: isg(:)
>       allocatable :: iskip(:)
>       allocatable :: istat2_bl(:,:)
>       allocatable :: istat2_em(:,:)
>       allocatable :: istat2_pa(:,:)
>       allocatable :: istat2_pe(:,:)
>       allocatable :: isva(:,:,:)
>       allocatable :: itrans(:)
>       allocatable :: iviscg(:,:)
>       allocatable :: ivmax(:)
>       allocatable :: iwfg(:,:)
>       allocatable :: iwork(:)
>       allocatable :: jbcinfo(:,:,:,:)
>       allocatable :: jcsf(:,:)
>       allocatable :: jcsi(:,:)
>       allocatable :: jdimg(:)
>       allocatable :: jeg(:)
>       allocatable :: jimage(:,:,:)
>       allocatable :: jjbg(:)
>       allocatable :: jjig(:)
>       allocatable :: jjmax1(:)
>       allocatable :: jlamhig(:)
>       allocatable :: jlamlog(:)
>       allocatable :: jmm(:)
>       allocatable :: jmx(:)
>       allocatable :: jsg(:)
>       allocatable :: jskip(:)
>       allocatable :: jte(:)
>       allocatable :: jvmax(:)
>       allocatable :: kbcinfo(:,:,:,:)
>       allocatable :: kcsf(:,:)
>       allocatable :: kcsi(:,:)
>       allocatable :: kdimg(:)
>       allocatable :: keg(:)
>       allocatable :: kimage(:,:,:)
>       allocatable :: kkbg(:)
>       allocatable :: kkig(:)
>       allocatable :: kkmax1(:)
>       allocatable :: klamhig(:)
>       allocatable :: klamlog(:)
>       allocatable :: kmm(:)
>       allocatable :: kmx(:)
>       allocatable :: ksg(:)
>       allocatable :: kskip(:)
>       allocatable :: kte(:)
>       allocatable :: kvmax(:)
>       allocatable :: lbg(:)
>       allocatable :: levelg(:)
>       allocatable :: lig(:)
>       allocatable :: limblk(:,:,:)
>       allocatable :: llimit(:)
>       allocatable :: lout(:)
>       allocatable :: lw(:,:)
>       allocatable :: lw2(:,:)
>       allocatable :: lwdat(:,:,:)
>       allocatable :: mblk2nd(:)
>       allocatable :: mblkpt(:)
>       allocatable :: mit(:,:)
>       allocatable :: mmceta(:)
>       allocatable :: mmcxie(:)
>       allocatable :: nbci0(:)
>       allocatable :: nbcidim(:)
>       allocatable :: nbcj0(:)
>       allocatable :: nbcjdim(:)
>       allocatable :: nbck0(:)
>       allocatable :: nbckdim(:)
>       allocatable :: nblcg(:)
>       allocatable :: nblg(:)
>       allocatable :: nblk(:,:)
>       allocatable :: nblk1(:)
>       allocatable :: nblk2(:)
>       allocatable :: nblkpt(:)
>       allocatable :: nblon(:)
>       allocatable :: ncgg(:)
>       allocatable :: ncheck(:)
>       allocatable :: nneg1(:)
>       allocatable :: nneg2(:)
>       allocatable :: nsegdfrm(:)
>       allocatable :: omegax(:)
>       allocatable :: omegay(:)
>       allocatable :: omegaz(:)
>       allocatable :: omgxae(:,:)
>       allocatable :: omgyae(:,:)
>       allocatable :: omgzae(:,:)
>       allocatable :: pav(:)
>       allocatable :: period_miss(:)
>       allocatable :: perturb(:,:,:)
>       allocatable :: ptav(:)
>       allocatable :: qb(:,:,:)
>       allocatable :: resmx(:)
>       allocatable :: rfreqr(:)
>       allocatable :: rfreqt(:)
>       allocatable :: rfrqrae(:,:)
>       allocatable :: rfrqtae(:,:)
>       allocatable :: rkap0g(:,:)
>       allocatable :: rms(:)
>       allocatable :: rmstr1(:)
>       allocatable :: rmstr2(:)
>       allocatable :: seta(:,:,:)
>       allocatable :: seta2(:,:)
>       allocatable :: slavept(:,:,:,:)
>       allocatable :: stm(:,:,:)
>       allocatable :: stmi(:,:,:)
>       allocatable :: stot(:)
>       allocatable :: swett(:)
>       allocatable :: swetw(:)
>       allocatable :: sx(:)
>       allocatable :: sxie(:,:,:)
>       allocatable :: sxie2(:,:)
>       allocatable :: sy(:)
>       allocatable :: sz(:)
>       allocatable :: tav(:)
>       allocatable :: temp(:)
>       allocatable :: thetax(:)
>       allocatable :: thetaxl(:)
>       allocatable :: thetay(:)
>       allocatable :: thetayl(:)
>       allocatable :: thetaz(:)
>       allocatable :: thetazl(:)
>       allocatable :: thtxae(:,:)
>       allocatable :: thtyae(:,:)
>       allocatable :: thtzae(:,:)
>       allocatable :: time2(:)
>       allocatable :: timekeep(:)
>       allocatable :: ttav(:)
>       allocatable :: utrans(:)
>       allocatable :: utrnsae(:,:)
>       allocatable :: vormax(:)
>       allocatable :: vtrans(:)
>       allocatable :: vtrnsae(:,:)
>       allocatable :: windex(:,:)
>       allocatable :: windx(:,:)
>       allocatable :: work(:)
>       allocatable :: wtrans(:)
>       allocatable :: wtrnsae(:,:)
>       allocatable :: x0(:,:)
>       allocatable :: x1(:,:)
>       allocatable :: x2(:,:)
>       allocatable :: xie2s(:,:)
>       allocatable :: xif1(:)
>       allocatable :: xif2(:)
>       allocatable :: xmav(:)
>       allocatable :: xmi(:,:,:)
>       allocatable :: xmie(:,:,:)
>       allocatable :: xorgae(:,:)
>       allocatable :: xorgae0(:,:)
>       allocatable :: xorig(:)
>       allocatable :: xorig0(:)
>       allocatable :: xs(:,:)
>       allocatable :: xte(:,:,:)
>       allocatable :: xxn(:,:)
>       allocatable :: y1(:,:)
>       allocatable :: y2(:,:)
>       allocatable :: ymi(:,:,:)
>       allocatable :: ymie(:,:,:)
>       allocatable :: yorgae(:,:)
>       allocatable :: yorgae0(:,:)
>       allocatable :: yorig(:)
>       allocatable :: yorig0(:)
>       allocatable :: yte(:,:,:)
>       allocatable :: z1(:,:)
>       allocatable :: z2(:,:)
>       allocatable :: zmi(:,:,:)
>       allocatable :: zmie(:,:,:)
>       allocatable :: zorgae(:,:)
>       allocatable :: zorgae0(:,:)
>       allocatable :: zorig(:)
>       allocatable :: zorig0(:)
>       allocatable :: zte(:,:,:)
> 
311d364
<       icall  = 0
314,625c367,988
<       call umalloc(ip_work,mwork,0,icall,memuse)
<       call umalloc(ip_iwork,mworki,1,icall,memuse)
<       call umalloc(ip_lwdat,maxbl*maxseg*6,1,icall,memuse)
<       call umalloc(ip_lw,65*maxbl,1,icall,memuse)
<       call umalloc(ip_lw2,43*maxbl,1,icall,memuse)
<       call umalloc(ip_nblk,2*mxbli,1,icall,memuse)
<       call umalloc(ip_limblk,12*mxbli,1,icall,memuse)
<       call umalloc(ip_isva,4*mxbli,1,icall,memuse)
<       call umalloc(ip_nblon,mxbli,1,icall,memuse)
<       call umalloc(ip_resmx,maxbl,0,icall,memuse)
<       call umalloc(ip_imx,maxbl,1,icall,memuse)
<       call umalloc(ip_jmx,maxbl,1,icall,memuse)
<       call umalloc(ip_kmx,maxbl,1,icall,memuse)
<       call umalloc(ip_vormax,maxbl,0,icall,memuse)
<       call umalloc(ip_ivmax,maxbl,1,icall,memuse)
<       call umalloc(ip_jvmax,maxbl,1,icall,memuse)
<       call umalloc(ip_kvmax,maxbl,1,icall,memuse)
<       call umalloc(ip_lig,maxbl,1,icall,memuse)
<       call umalloc(ip_lbg,maxbl,1,icall,memuse)
<       call umalloc(ip_iovrlp,maxbl,1,icall,memuse)
<       call umalloc(ip_qb,15*iitot,0,icall,memuse)
<       call umalloc(ip_ibpntsg,4*maxbl,1,icall,memuse)
<       call umalloc(ip_iipntsg,maxbl,1,icall,memuse)
<       call umalloc(ip_iibg,iitot,1,icall,memuse)
<       call umalloc(ip_jjbg,iitot,1,icall,memuse)
<       call umalloc(ip_kkbg,iitot,1,icall,memuse)
<       call umalloc(ip_ibcg,iitot,1,icall,memuse)
<       call umalloc(ip_dxintg,iitot,0,icall,memuse)
<       call umalloc(ip_dyintg,iitot,0,icall,memuse)
<       call umalloc(ip_dzintg,iitot,0,icall,memuse)
<       call umalloc(ip_iiig,iitot,1,icall,memuse)
<       call umalloc(ip_jjig,iitot,1,icall,memuse)
<       call umalloc(ip_kkig,iitot,1,icall,memuse)
<       call umalloc(ip_rkap0g,3*maxbl,0,icall,memuse)
<       call umalloc(ip_levelg,maxbl,1,icall,memuse)
<       call umalloc(ip_igridg,maxbl,1,icall,memuse)
<       call umalloc(ip_iflimg,3*maxbl,1,icall,memuse)
<       call umalloc(ip_ifdsg,3*maxbl,1,icall,memuse)
<       call umalloc(ip_iviscg,3*maxbl,1,icall,memuse)
<       call umalloc(ip_jdimg,maxbl,1,icall,memuse)
<       call umalloc(ip_kdimg,maxbl,1,icall,memuse)
<       call umalloc(ip_idimg,maxbl,1,icall,memuse)
<       call umalloc(ip_idiagg,3*maxbl,1,icall,memuse)
<       call umalloc(ip_nblcg,maxbl,1,icall,memuse)
<       call umalloc(ip_idegg,3*maxbl,1,icall,memuse)
<       call umalloc(ip_jsg,maxbl,1,icall,memuse)
<       call umalloc(ip_ksg,maxbl,1,icall,memuse)
<       call umalloc(ip_isg,maxbl,1,icall,memuse)
<       call umalloc(ip_jeg,maxbl,1,icall,memuse)
<       call umalloc(ip_keg,maxbl,1,icall,memuse)
<       call umalloc(ip_ieg,maxbl,1,icall,memuse)
<       call umalloc(ip_mit,5*maxbl,1,icall,memuse)
<       call umalloc(ip_jlamlog,maxbl,1,icall,memuse)
<       call umalloc(ip_klamlog,maxbl,1,icall,memuse)
<       call umalloc(ip_ilamlog,maxbl,1,icall,memuse)
<       call umalloc(ip_jlamhig,maxbl,1,icall,memuse)
<       call umalloc(ip_klamhig,maxbl,1,icall,memuse)
<       call umalloc(ip_ilamhig,maxbl,1,icall,memuse)
<       call umalloc(ip_iwfg,3*maxbl,1,icall,memuse)
<       call umalloc(ip_utrans,maxbl,0,icall,memuse)
<       call umalloc(ip_vtrans,maxbl,0,icall,memuse)
<       call umalloc(ip_wtrans,maxbl,0,icall,memuse)
<       call umalloc(ip_omegax,maxbl,0,icall,memuse)
<       call umalloc(ip_omegay,maxbl,0,icall,memuse)
<       call umalloc(ip_omegaz,maxbl,0,icall,memuse)
<       call umalloc(ip_xorig,maxbl,0,icall,memuse)
<       call umalloc(ip_yorig,maxbl,0,icall,memuse)
<       call umalloc(ip_zorig,maxbl,0,icall,memuse)
<       call umalloc(ip_dxmx,maxbl,0,icall,memuse)
<       call umalloc(ip_dymx,maxbl,0,icall,memuse)
<       call umalloc(ip_dzmx,maxbl,0,icall,memuse)
<       call umalloc(ip_dthxmx,maxbl,0,icall,memuse)
<       call umalloc(ip_dthymx,maxbl,0,icall,memuse)
<       call umalloc(ip_dthzmx,maxbl,0,icall,memuse)
<       call umalloc(ip_thetax,maxbl,0,icall,memuse)
<       call umalloc(ip_thetay,maxbl,0,icall,memuse)
<       call umalloc(ip_thetaz,maxbl,0,icall,memuse)
<       call umalloc(ip_rfreqt,maxbl,0,icall,memuse)
<       call umalloc(ip_rfreqr,maxbl,0,icall,memuse)
<       call umalloc(ip_xorig0,maxbl,0,icall,memuse)
<       call umalloc(ip_yorig0,maxbl,0,icall,memuse)
<       call umalloc(ip_zorig0,maxbl,0,icall,memuse)
<       call umalloc(ip_time2,maxbl,0,icall,memuse)
<       call umalloc(ip_thetaxl,maxbl,0,icall,memuse)
<       call umalloc(ip_thetayl,maxbl,0,icall,memuse)
<       call umalloc(ip_thetazl,maxbl,0,icall,memuse)
<       call umalloc(ip_itrans,maxbl,1,icall,memuse)
<       call umalloc(ip_irotat,maxbl,1,icall,memuse)
<       call umalloc(ip_idefrm,maxbl,1,icall,memuse)
<       call umalloc(ip_bcvali,14*maxseg*maxbl,0,icall,memuse)
<       call umalloc(ip_bcvalj,14*maxseg*maxbl,0,icall,memuse)
<       call umalloc(ip_bcvalk,14*maxseg*maxbl,0,icall,memuse)
<       call umalloc(ip_nbci0,maxbl,1,icall,memuse)
<       call umalloc(ip_nbcj0,maxbl,1,icall,memuse)
<       call umalloc(ip_nbck0,maxbl,1,icall,memuse)
<       call umalloc(ip_nbcidim,maxbl,1,icall,memuse)
<       call umalloc(ip_nbcjdim,maxbl,1,icall,memuse)
<       call umalloc(ip_nbckdim,maxbl,1,icall,memuse)
<       call umalloc(ip_ibcinfo,14*maxseg*maxbl,1,icall,memuse)
<       call umalloc(ip_jbcinfo,14*maxseg*maxbl,1,icall,memuse)
<       call umalloc(ip_kbcinfo,14*maxseg*maxbl,1,icall,memuse)
<       call umalloc(ip_bcfilei,2*maxseg*maxbl,1,icall,memuse)
<       call umalloc(ip_bcfilej,2*maxseg*maxbl,1,icall,memuse)
<       call umalloc(ip_bcfilek,2*maxseg*maxbl,1,icall,memuse)
<       call umalloc(ip_ncgg,maxgr,1,icall,memuse)
<       call umalloc(ip_nblg,maxgr,1,icall,memuse)
<       call umalloc(ip_iemg,maxgr,1,icall,memuse)
<       call umalloc(ip_inewgg,maxgr,1,icall,memuse)
<       call umalloc(ip_inpl3d,11*nplots,1,icall,memuse)
<       call umalloc(ip_inpr,11*nplots,1,icall,memuse)
<       call umalloc(ip_iadvance,maxbl,1,icall,memuse)
<       call umalloc(ip_iforce,maxbl,1,icall,memuse)
<       call umalloc(ip_rms,ncycmax,0,icall,memuse)
<       call umalloc(ip_clw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cdw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cdpw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cdvw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cxw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cyw,ncycmax,0,icall,memuse)
<       call umalloc(ip_czw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cmxw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cmyw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cmzw,ncycmax,0,icall,memuse)
<       call umalloc(ip_chdw,ncycmax,0,icall,memuse)
<       call umalloc(ip_swetw,ncycmax,0,icall,memuse)
<       call umalloc(ip_fmdotw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cfttotw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cftmomw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cftpw,ncycmax,0,icall,memuse)
<       call umalloc(ip_cftvw,ncycmax,0,icall,memuse)
<       call umalloc(ip_rmstr1,ncycmax,0,icall,memuse)
<       call umalloc(ip_rmstr2,ncycmax,0,icall,memuse)
<       call umalloc(ip_nneg1,ncycmax,1,icall,memuse)
<       call umalloc(ip_nneg2,ncycmax,1,icall,memuse)
<       call umalloc(ip_swett,maxbl,0,icall,memuse)
<       call umalloc(ip_clt,maxbl,0,icall,memuse)
<       call umalloc(ip_cdt,maxbl,0,icall,memuse)
<       call umalloc(ip_cxt,maxbl,0,icall,memuse)
<       call umalloc(ip_cyt,maxbl,0,icall,memuse)
<       call umalloc(ip_czt,maxbl,0,icall,memuse)
<       call umalloc(ip_cmxt,maxbl,0,icall,memuse)
<       call umalloc(ip_cmyt,maxbl,0,icall,memuse)
<       call umalloc(ip_cmzt,maxbl,0,icall,memuse)
<       call umalloc(ip_cdpt,maxbl,0,icall,memuse)
<       call umalloc(ip_cdvt,maxbl,0,icall,memuse)
<       call umalloc(ip_sx,maxcs,0,icall,memuse)
<       call umalloc(ip_sy,maxcs,0,icall,memuse)
<       call umalloc(ip_sz,maxcs,0,icall,memuse)
<       call umalloc(ip_stot,maxcs,0,icall,memuse)
<       call umalloc(ip_pav,maxcs,0,icall,memuse)
<       call umalloc(ip_ptav,maxcs,0,icall,memuse)
<       call umalloc(ip_tav,maxcs,0,icall,memuse)
<       call umalloc(ip_ttav,maxcs,0,icall,memuse)
<       call umalloc(ip_xmav,maxcs,0,icall,memuse)
<       call umalloc(ip_fmdot,maxcs,0,icall,memuse)
<       call umalloc(ip_cfxp,maxcs,0,icall,memuse)
<       call umalloc(ip_cfyp,maxcs,0,icall,memuse)
<       call umalloc(ip_cfzp,maxcs,0,icall,memuse)
<       call umalloc(ip_cfdp,maxcs,0,icall,memuse)
<       call umalloc(ip_cflp,maxcs,0,icall,memuse)
<       call umalloc(ip_cftp,maxcs,0,icall,memuse)
<       call umalloc(ip_cfxv,maxcs,0,icall,memuse)
<       call umalloc(ip_cfyv,maxcs,0,icall,memuse)
<       call umalloc(ip_cfzv,maxcs,0,icall,memuse)
<       call umalloc(ip_cfdv,maxcs,0,icall,memuse)
<       call umalloc(ip_cflv,maxcs,0,icall,memuse)
<       call umalloc(ip_cftv,maxcs,0,icall,memuse)
<       call umalloc(ip_cfxmom,maxcs,0,icall,memuse)
<       call umalloc(ip_cfymom,maxcs,0,icall,memuse)
<       call umalloc(ip_cfzmom,maxcs,0,icall,memuse)
<       call umalloc(ip_cfdmom,maxcs,0,icall,memuse)
<       call umalloc(ip_cflmom,maxcs,0,icall,memuse)
<       call umalloc(ip_cftmom,maxcs,0,icall,memuse)
<       call umalloc(ip_cfxtot,maxcs,0,icall,memuse)
<       call umalloc(ip_cfytot,maxcs,0,icall,memuse)
<       call umalloc(ip_cfztot,maxcs,0,icall,memuse)
<       call umalloc(ip_cfdtot,maxcs,0,icall,memuse)
<       call umalloc(ip_cfltot,maxcs,0,icall,memuse)
<       call umalloc(ip_cfttot,maxcs,0,icall,memuse)
<       call umalloc(ip_icsinfo,9*maxcs,1,icall,memuse)
<       call umalloc(ip_windex,2*maxxe,0,icall,memuse)
<       call umalloc(ip_iindex,intmax*(6*nsub1+9),1,icall,memuse)
<       call umalloc(ip_nblkpt,maxxe,1,icall,memuse)
<       call umalloc(ip_windx,2*mxxe,0,icall,memuse)
<       call umalloc(ip_iindx,intmx*(6*msub1+9),1,icall,memuse)
<       call umalloc(ip_llimit,intmx,1,icall,memuse)
<       call umalloc(ip_iitmax,intmx,1,icall,memuse)
<       call umalloc(ip_mmcxie,intmx,1,icall,memuse)
<       call umalloc(ip_mmceta,intmx,1,icall,memuse)
<       call umalloc(ip_ncheck,maxbl,1,icall,memuse)
<       call umalloc(ip_iifit,intmx,1,icall,memuse)
<       call umalloc(ip_mblkpt,mxxe,1,icall,memuse)
<       call umalloc(ip_iic0,intmx,1,icall,memuse)
<       call umalloc(ip_iiorph,intmx,1,icall,memuse)
<       call umalloc(ip_iitoss,intmx,1,icall,memuse)
<       call umalloc(ip_ifiner,intmx,1,icall,memuse)
<       call umalloc(ip_dthetxx,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_dthetyy,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_dthetzz,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_dx,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_dy,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_dz,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_dthetx,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_dthety,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_dthetz,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_lout,msub1,1,icall,memuse)
<       call umalloc(ip_xif1,msub1,1,icall,memuse)
<       call umalloc(ip_xif2,msub1,1,icall,memuse)
<       call umalloc(ip_etf1,msub1,1,icall,memuse)
<       call umalloc(ip_etf2,msub1,1,icall,memuse)
<       call umalloc(ip_jjmax1,nsub1,1,icall,memuse)
<       call umalloc(ip_kkmax1,nsub1,1,icall,memuse)
<       call umalloc(ip_iiint1,nsub1,1,icall,memuse)
<       call umalloc(ip_iiint2,nsub1,1,icall,memuse)
<       call umalloc(ip_jimage,msub1*(mptch+2)*(mptch+2),1,icall,memuse)
<       call umalloc(ip_kimage,msub1*(mptch+2)*(mptch+2),1,icall,memuse)
<       call umalloc(ip_jte,msub1,1,icall,memuse)
<       call umalloc(ip_kte,msub1,1,icall,memuse)
<       call umalloc(ip_jmm,mptch+2,1,icall,memuse)
<       call umalloc(ip_kmm,mptch+2,1,icall,memuse)
<       call umalloc(ip_nblk1,mptch+2,1,icall,memuse)
<       call umalloc(ip_nblk2,mptch+2,1,icall,memuse)
<       call umalloc(ip_xte,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_yte,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_zte,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_xmi,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_ymi,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_zmi,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_xmie,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_ymie,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_zmie,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_sxie,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_seta,msub1*(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_sxie2,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_seta2,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_xie2s,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_eta2s,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_temp,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_x2,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_y2,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_z2,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_x1,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_y1,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_z1,(mptch+2)*(mptch+2),0,icall,memuse)
<       call umalloc(ip_factjlo,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_factjhi,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_factklo,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_factkhi,intmx*msub1,0,icall,memuse)
<       call umalloc(ip_ifrom,msub1,0,icall,memuse)
<       call umalloc(ip_geom_miss,2*mxbli,0,icall,memuse)
<       call umalloc(ip_period_miss,lbcprd,0,icall,memuse)
<       call umalloc(ip_isav_blk,34*mxbli,1,icall,memuse)
<       call umalloc(ip_isav_prd,12*lbcprd,1,icall,memuse)
<       call umalloc(ip_isav_pat,17*intmax,1,icall,memuse)
<       call umalloc(ip_isav_pat_b,6*intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_isav_dpat,17*intmx,1,icall,memuse)
<       call umalloc(ip_isav_dpat_b,6*intmx*msub1,1,icall,memuse)
<       call umalloc(ip_isav_emb,12*lbcemb,1,icall,memuse)
<       call umalloc(ip_mblk2nd,maxbl,1,icall,memuse)
<       call umalloc(ip_istat2_bl,istat_size*mxbli*5,1,icall,memuse)
<       call umalloc(ip_istat2_pa,istat_size*intmax*nsub1*3,1,icall,
<      .             memuse)
<       call umalloc(ip_istat2_pe,istat_size*lbcprd*5,1,icall,memuse)
<       call umalloc(ip_istat2_em,istat_size*lbcemb*3,1,icall,memuse)
<       call umalloc(ip_utrnsae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_vtrnsae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_wtrnsae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_omgxae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_omgyae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_omgzae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_xorgae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_yorgae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_zorgae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_xorgae0,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_yorgae0,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_zorgae0,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_icouple,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_thtxae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_thtyae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_thtzae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_rfrqtae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_rfrqrae,maxbl*maxsegdg,0,icall,memuse)
<       call umalloc(ip_icsi,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_icsf,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_jcsi,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_jcsf,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_kcsi,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_kcsf,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_nsegdfrm,maxbl,1,icall,memuse)
<       call umalloc(ip_idfrmseg,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_iaesurf,maxbl*maxsegdg,1,icall,memuse)
<       call umalloc(ip_freq,nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_gmass,nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_x0,2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_gf0,2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_damp,nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_perturb,4*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_aesrfdat,5*maxaes,0,icall,memuse)
<       call umalloc(ip_slavept,15*nslave*nmaster,0,icall,memuse)
<       call umalloc(ip_iskip,maxbl,1,icall,memuse)
<       call umalloc(ip_jskip,maxbl,1,icall,memuse)
<       call umalloc(ip_kskip,maxbl,1,icall,memuse)
<       call umalloc(ip_bmat,2*nmds*2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_stm,2*nmds*2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_stmi,2*nmds*2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_xs,2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_xxn,2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_gforcn,2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_gforcnm,2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_gforcs,2*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_aehist,ncycmax*3*nmds*maxaes,0,icall,memuse)
<       call umalloc(ip_timekeep,ncycmax,0,icall,memuse)
---
>       allocate( aehist(ncycmax,3,nmds,maxaes),stat=stats )
>       call umalloc(ncycmax*3*nmds*maxaes,0,'aehist',memuse,stats)
>       allocate( aesrfdat(5,maxaes),stat=stats )
>       call umalloc(5*maxaes,0,'aesrfdat',memuse,stats)
>       allocate( bcfilei(maxbl,maxseg,2),stat=stats )
>       call umalloc(maxbl*maxseg*2,1,'bcfilei',memuse,stats)
>       allocate( bcfilej(maxbl,maxseg,2),stat=stats )
>       call umalloc(maxbl*maxseg*2,1,'bcfilej',memuse,stats)
>       allocate( bcfilek(maxbl,maxseg,2),stat=stats )
>       call umalloc(maxbl*maxseg*2,1,'bcfilek',memuse,stats)
>       allocate( bcvali(maxbl,maxseg,7,2),stat=stats )
>       call umalloc(maxbl*maxseg*7*2,0,'bcvali',memuse,stats)
>       allocate( bcvalj(maxbl,maxseg,7,2),stat=stats )
>       call umalloc(maxbl*maxseg*7*2,0,'bcvalj',memuse,stats)
>       allocate( bcvalk(maxbl,maxseg,7,2),stat=stats )
>       call umalloc(maxbl*maxseg*7*2,0,'bcvalk',memuse,stats)
>       allocate( bmat(2*nmds,2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*2*nmds*maxaes,0,'bmat',memuse,stats)
>       allocate( cdpt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'cdpt',memuse,stats)
>       allocate( cdpw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cdpw',memuse,stats)
>       allocate( cdt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'cdt',memuse,stats)
>       allocate( cdvt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'cdvt',memuse,stats)
>       allocate( cdvw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cdvw',memuse,stats)
>       allocate( cdw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cdw',memuse,stats)
>       allocate( cfdmom(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfdmom',memuse,stats)
>       allocate( cfdp(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfdp',memuse,stats)
>       allocate( cfdtot(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfdtot',memuse,stats)
>       allocate( cfdv(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfdv',memuse,stats)
>       allocate( cflmom(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cflmom',memuse,stats)
>       allocate( cflp(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cflp',memuse,stats)
>       allocate( cfltot(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfltot',memuse,stats)
>       allocate( cflv(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cflv',memuse,stats)
>       allocate( cftmom(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cftmom',memuse,stats)
>       allocate( cftmomw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cftmomw',memuse,stats)
>       allocate( cftp(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cftp',memuse,stats)
>       allocate( cftpw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cftpw',memuse,stats)
>       allocate( cfttot(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfttot',memuse,stats)
>       allocate( cfttotw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cfttotw',memuse,stats)
>       allocate( cftv(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cftv',memuse,stats)
>       allocate( cftvw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cftvw',memuse,stats)
>       allocate( cfxmom(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfxmom',memuse,stats)
>       allocate( cfxp(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfxp',memuse,stats)
>       allocate( cfxtot(maxcs),stat=stats )
>       call umalloc(maxcs,0,'maxcs',memuse,stats)
>       allocate( cfxv(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfxv',memuse,stats)
>       allocate( cfymom(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfymom',memuse,stats)
>       allocate( cfyp(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfyp',memuse,stats)
>       allocate( cfytot(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfytot',memuse,stats)
>       allocate( cfyv(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfyv',memuse,stats)
>       allocate( cfzmom(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfzmom',memuse,stats)
>       allocate( cfzp(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfzp',memuse,stats)
>       allocate( cfztot(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfztot',memuse,stats)
>       allocate( cfzv(maxcs),stat=stats )
>       call umalloc(maxcs,0,'cfzv',memuse,stats)
>       allocate( chdw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'chdw',memuse,stats)
>       allocate( clt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'clt',memuse,stats)
>       allocate( clw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'clw',memuse,stats)
>       allocate( cmxt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'cmxt',memuse,stats)
>       allocate( cmxw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cmxw',memuse,stats)
>       allocate( cmyt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'cmyt',memuse,stats)
>       allocate( cmyw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cmyw',memuse,stats)
>       allocate( cmzt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'cmzt',memuse,stats)
>       allocate( cmzw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cmzw',memuse,stats)
>       allocate( cxt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'cxt',memuse,stats)
>       allocate( cxw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cxw',memuse,stats)
>       allocate( cyt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'cyt',memuse,stats)
>       allocate( cyw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'cyw',memuse,stats)
>       allocate( czt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'czt',memuse,stats)
>       allocate( czw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'czw',memuse,stats)
>       allocate( damp(nmds,maxaes),stat=stats )
>       call umalloc(nmds*maxaes,0,'damp',memuse,stats)
>       allocate( dthetx(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'dthetx',memuse,stats)
>       allocate( dthetxx(intmax,nsub1),stat=stats )
>       call umalloc(intmax*nsub1,0,'dthetxx',memuse,stats)
>       allocate( dthety(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'dthety',memuse,stats)
>       allocate( dthetyy(intmax,nsub1),stat=stats )
>       call umalloc(intmax*nsub1,0,'dthetyy',memuse,stats)
>       allocate( dthetz(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'dthetz',memuse,stats)
>       allocate( dthetzz(intmax,nsub1),stat=stats )
>       call umalloc(intmax*nsub1,0,'dthetzz',memuse,stats)
>       allocate( dthxmx(maxbl),stat=stats )
>       call umalloc(maxbl,0,'dthxmx',memuse,stats)
>       allocate( dthymx(maxbl),stat=stats )
>       call umalloc(maxbl,0,'dthymx',memuse,stats)
>       allocate( dthzmx(maxbl),stat=stats )
>       call umalloc(maxbl,0,'dthzmx',memuse,stats)
>       allocate( dx(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'dx',memuse,stats)
>       allocate( dxintg(iitot),stat=stats )
>       call umalloc(iitot,0,'dxintg',memuse,stats)
>       allocate( dxmx(maxbl),stat=stats )
>       call umalloc(maxbl,0,'dxmx',memuse,stats)
>       allocate( dy(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'dy',memuse,stats)
>       allocate( dyintg(iitot),stat=stats )
>       call umalloc(iitot,0,'dyintg',memuse,stats)
>       allocate( dymx(maxbl),stat=stats )
>       call umalloc(maxbl,0,'dymx',memuse,stats)
>       allocate( dz(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'dz',memuse,stats)
>       allocate( dzintg(iitot),stat=stats )
>       call umalloc(iitot,0,'dzintg',memuse,stats)
>       allocate( dzmx(maxbl),stat=stats )
>       call umalloc(maxbl,0,'dzmx',memuse,stats)
>       allocate( eta2s(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'eta2s',memuse,stats)
>       allocate( etf1(msub1),stat=stats )
>       call umalloc(msub1,1,'etf1',memuse,stats)
>       allocate( etf2(msub1),stat=stats )
>       call umalloc(msub1,1,'etf2',memuse,stats)
>       allocate( factjhi(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'factjhi',memuse,stats)
>       allocate( factjlo(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'factjlo',memuse,stats)
>       allocate( factkhi(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'factkhi',memuse,stats)
>       allocate( factklo(intmx,msub1),stat=stats )
>       call umalloc(intmx*msub1,0,'factklo',memuse,stats)
>       allocate( fmdot(maxcs),stat=stats )
>       call umalloc(maxcs,0,'fmdot',memuse,stats)
>       allocate( fmdotw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'fmdotw',memuse,stats)
>       allocate( freq(nmds,maxaes),stat=stats )
>       call umalloc(nmds*maxaes,0,'freq',memuse,stats)
>       allocate( geom_miss(2*mxbli),stat=stats )
>       call umalloc(2*mxbli,0,'geom_miss',memuse,stats)
>       allocate( gf0(2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*maxaes,0,'gf0',memuse,stats)
>       allocate( gforcn(2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*maxaes,0,'gforcn',memuse,stats)
>       allocate( gforcnm(2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*maxaes,0,'gforcnm',memuse,stats)
>       allocate( gforcs(2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*maxaes,0,'gforcs',memuse,stats)
>       allocate( gmass(nmds,maxaes),stat=stats )
>       call umalloc(nmds*maxaes,0,'gmass',memuse,stats)
>       allocate( iadvance(maxbl),stat=stats )
>       call umalloc(maxbl,1,'iadvance',memuse,stats)
>       allocate( iaesurf(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'iaesurf',memuse,stats)
>       allocate( ibcg(iitot),stat=stats )
>       call umalloc(iitot,1,'ibcg',memuse,stats)
>       allocate( ibcinfo(maxbl,maxseg,7,2),stat=stats )
>       call umalloc(maxbl*maxseg*7*2,1,'ibcinfo',memuse,stats)
>       allocate( ibpntsg(maxbl,4),stat=stats )
>       call umalloc(maxbl*4,1,'ibpntsg',memuse,stats)
>       allocate( icouple(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'icouple',memuse,stats)
>       allocate( icsf(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'icsf',memuse,stats)
>       allocate( icsi(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'icsi',memuse,stats)
>       allocate( icsinfo(maxcs,9),stat=stats )
>       call umalloc(maxcs*9,1,'csinfo',memuse,stats)
>       allocate( idefrm(maxbl),stat=stats )
>       call umalloc(maxbl,1,'idefrm',memuse,stats)
>       allocate( idegg(maxbl,3),stat=stats )
>       call umalloc(maxbl*3,1,'idegg',memuse,stats)
>       allocate( idfrmseg(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'idfrmseg',memuse,stats)
>       allocate( idiagg(maxbl,3),stat=stats )
>       call umalloc(maxbl*3,1,'idiagg',memuse,stats)
>       allocate( idimg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'idimg',memuse,stats)
>       allocate( ieg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'ieg',memuse,stats)
>       allocate( iemg(maxgr),stat=stats )
>       call umalloc(maxgr,1,'iemg',memuse,stats)
>       allocate( ifdsg(maxbl,3),stat=stats )
>       call umalloc(maxbl*3,1,'ifdsg',memuse,stats)
>       allocate( ifiner(intmx),stat=stats )
>       call umalloc(intmx,1,'ifiner',memuse,stats)
>       allocate( iflimg(maxbl,3),stat=stats )
>       call umalloc(maxbl*3,1,'iflimg',memuse,stats)
>       allocate( iforce(maxbl),stat=stats )
>       call umalloc(maxbl,1,'iforce',memuse,stats)
>       allocate( ifrom(msub1),stat=stats )
>       call umalloc(msub1,0,'ifrom',memuse,stats)
>       allocate( igridg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'igridg',memuse,stats)
>       allocate( iibg(iitot),stat=stats )
>       call umalloc(iitot,1,'iibg',memuse,stats)
>       allocate( iic0(intmx),stat=stats )
>       call umalloc(intmx,1,'iic0',memuse,stats)
>       allocate( iifit(intmx),stat=stats )
>       call umalloc(intmx,1,'iifit',memuse,stats)
>       allocate( iiig(iitot),stat=stats )
>       call umalloc(iitot,1,'iiig',memuse,stats)
>       allocate( iiint1(nsub1),stat=stats )
>       call umalloc(nsub1,1,'iiint1',memuse,stats)
>       allocate( iiint2(nsub1),stat=stats )
>       call umalloc(nsub1,1,'iiint2',memuse,stats)
>       allocate( iindex(intmax,6*nsub1+9),stat=stats )
>       call umalloc(intmax*(6*nsub1+9),1,'iindex',memuse,stats)
>       allocate( iindx(intmx,6*msub1+9),stat=stats )
>       call umalloc(intmx*(6*msub1+9),1,'iindx',memuse,stats)
>       allocate( iiorph(intmx),stat=stats )
>       call umalloc(intmx,1,'iiorph',memuse,stats)
>       allocate( iipntsg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'iipntsg',memuse,stats)
>       allocate( iitmax(intmx),stat=stats )
>       call umalloc(intmx,1,'iitmax',memuse,stats)
>       allocate( iitoss(intmx),stat=stats )
>       call umalloc(intmx,1,'iitoss',memuse,stats)
>       allocate( ilamhig(maxbl),stat=stats )
>       call umalloc(maxbl,1,'ilamhig',memuse,stats)
>       allocate( ilamlog(maxbl),stat=stats )
>       call umalloc(maxbl,1,'ilamlog',memuse,stats)
>       allocate( imx(maxbl),stat=stats )
>       call umalloc(maxbl,1,'imx',memuse,stats)
>       allocate( inewgg(maxgr),stat=stats )
>       call umalloc(maxgr,1,'inewgg',memuse,stats)
>       allocate( inpl3d(nplots,11),stat=stats )
>       call umalloc(nplots*11,1,'inpl3d',memuse,stats)
>       allocate( inpr(nplots,11),stat=stats )
>       call umalloc(nplots*11,1,'inpr',memuse,stats)
>       allocate( iovrlp(maxbl),stat=stats )
>       call umalloc(maxbl,1,'iovrlp',memuse,stats)
>       allocate( irotat(maxbl),stat=stats )
>       call umalloc(maxbl,1,'irotat',memuse,stats)
>       allocate( isav_blk(2*mxbli,17),stat=stats )
>       call umalloc(2*mxbli*17,1,'isav_blk',memuse,stats)
>       allocate( isav_dpat(intmx,17),stat=stats )
>       call umalloc(intmx*17,1,'isav_dpat',memuse,stats)
>       allocate( isav_dpat_b(intmx,msub1,6),stat=stats )
>       call umalloc(intmx*msub1*6,1,'isav_dpat_b',memuse,stats)
>       allocate( isav_emb(lbcemb,12),stat=stats )
>       call umalloc(lbcemb*12,1,'isav_emb',memuse,stats)
>       allocate( isav_pat(intmax,17),stat=stats )
>       call umalloc(intmax*17,1,'isav_pat',memuse,stats)
>       allocate( isav_pat_b(intmax,nsub1,6),stat=stats )
>       call umalloc(intmax*nsub1*6,1,'isav_pat_b',memuse,stats)
>       allocate( isav_prd(lbcprd,12),stat=stats )
>       call umalloc(lbcprd*12,1,'isav_prd',memuse,stats)
>       allocate( isg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'isg',memuse,stats)
>       allocate( iskip(maxbl),stat=stats )
>       call umalloc(maxbl,1,'iskip',memuse,stats)
>       allocate( istat2_bl(istat_size,mxbli*5),stat=stats )
>       call umalloc(istat_size*mxbli*5,1,'istat2_bl',memuse,stats)
>       allocate( istat2_em(istat_size,lbcemb*3),stat=stats )
>       call umalloc(istat_size*lbcemb*3,1,'istat2_em',memuse,stats)
>       allocate( istat2_pa(istat_size,intmax*nsub1*3),stat=stats )
>       call umalloc(istat_size*intmax*nsub1*3,1,'istat2_pa',memuse,stats)
>       allocate( istat2_pe(istat_size,lbcprd*5),stat=stats )
>       call umalloc(istat_size*lbcprd*5,1,'istat2_pe',memuse,stats)
>       allocate( isva(2,2,mxbli),stat=stats )
>       call umalloc(2*2*mxbli,1,'isva',memuse,stats)
>       allocate( itrans(maxbl),stat=stats )
>       call umalloc(maxbl,1,'itrans',memuse,stats)
>       allocate( iviscg(maxbl,3),stat=stats )
>       call umalloc(maxbl*3,1,'iviscg',memuse,stats)
>       allocate( ivmax(maxbl),stat=stats )
>       call umalloc(maxbl,1,'ivmax',memuse,stats)
>       allocate( iwfg(maxbl,3),stat=stats )
>       call umalloc(maxbl*3,1,'iwfg',memuse,stats)
>       allocate( iwork(mworki),stat=stats )
>       call umalloc(mworki,1,'iwork',memuse,stats)
>       allocate( jbcinfo(maxbl,maxseg,7,2),stat=stats )
>       call umalloc(maxbl*maxseg*7*2,1,'jbcinfo',memuse,stats)
>       allocate( jcsf(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'jcsf',memuse,stats)
>       allocate( jcsi(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'jcsi',memuse,stats)
>       allocate( jdimg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'jdimg',memuse,stats)
>       allocate( jeg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'jeg',memuse,stats)
>       allocate( jimage(msub1,mptch+2,mptch+2),stat=stats )
>       call umalloc(msub1*(mptch+2)*(mptch+2),1,'jimage',memuse,stats)
>       allocate( jjbg(iitot),stat=stats )
>       call umalloc(iitot,1,'jjbg',memuse,stats)
>       allocate( jjig(iitot),stat=stats )
>       call umalloc(iitot,1,'jjig',memuse,stats)
>       allocate( jjmax1(nsub1),stat=stats )
>       call umalloc(nsub1,1,'jjmax1',memuse,stats)
>       allocate( jlamhig(maxbl),stat=stats )
>       call umalloc(maxbl,1,'jlamhig',memuse,stats)
>       allocate( jlamlog(maxbl),stat=stats )
>       call umalloc(maxbl,1,'jlamlog',memuse,stats)
>       allocate( jmm(mptch+2),stat=stats )
>       call umalloc(mptch+2,1,'jmm',memuse,stats)
>       allocate( jmx(maxbl),stat=stats )
>       call umalloc(maxbl,1,'jmx',memuse,stats)
>       allocate( jsg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'jsg',memuse,stats)
>       allocate( jskip(maxbl),stat=stats )
>       call umalloc(maxbl,1,'jskip',memuse,stats)
>       allocate( jte(msub1),stat=stats )
>       call umalloc(msub1,1,'jte',memuse,stats)
>       allocate( jvmax(maxbl),stat=stats )
>       call umalloc(maxbl,1,'jvmax',memuse,stats)
>       allocate( kbcinfo(maxbl,maxseg,7,2),stat=stats )
>       call umalloc(maxbl*maxseg*7*2,1,'kbcinfo',memuse,stats)
>       allocate( kcsf(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'kcsf',memuse,stats)
>       allocate( kcsi(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,1,'kcsi',memuse,stats)
>       allocate( kdimg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'kdimg',memuse,stats)
>       allocate( keg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'keg',memuse,stats)
>       allocate( kimage(msub1,mptch+2,mptch+2),stat=stats )
>       call umalloc(msub1*(mptch+2)*(mptch+2),1,'kimage',memuse,stats)
>       allocate( kkbg(iitot),stat=stats )
>       call umalloc(iitot,1,'kkbg',memuse,stats)
>       allocate( kkig(iitot),stat=stats )
>       call umalloc(iitot,1,'kkig',memuse,stats)
>       allocate( kkmax1(nsub1),stat=stats )
>       call umalloc(nsub1,1,'kkmax1',memuse,stats)
>       allocate( klamhig(maxbl),stat=stats )
>       call umalloc(maxbl,1,'klamhig',memuse,stats)
>       allocate( klamlog(maxbl),stat=stats )
>       call umalloc(maxbl,1,'klamlog',memuse,stats)
>       allocate( kmm(mptch+2),stat=stats )
>       call umalloc(mptch+2,1,'kmm',memuse,stats)
>       allocate( kmx(maxbl),stat=stats )
>       call umalloc(maxbl,1,'kmx',memuse,stats)
>       allocate( ksg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'ksg',memuse,stats)
>       allocate( kskip(maxbl),stat=stats )
>       call umalloc(maxbl,1,'kskip',memuse,stats)
>       allocate( kte(msub1),stat=stats )
>       call umalloc(msub1,1,'kte',memuse,stats)
>       allocate( kvmax(maxbl),stat=stats )
>       call umalloc(maxbl,1,'kvmax',memuse,stats)
>       allocate( lbg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'lbg',memuse,stats)
>       allocate( levelg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'levelg',memuse,stats)
>       allocate( lig(maxbl),stat=stats )
>       call umalloc(maxbl,1,'lig',memuse,stats)
>       allocate( limblk(2,6,mxbli),stat=stats )
>       call umalloc(2*6*mxbli,1,'limblk',memuse,stats)
>       allocate( llimit(intmx),stat=stats )
>       call umalloc(intmx,1,'llimit',memuse,stats)
>       allocate( lout(msub1),stat=stats )
>       call umalloc(msub1,1,'lout',memuse,stats)
>       allocate( lw(65,maxbl),stat=stats )
>       call umalloc(65*maxbl,1,'lw',memuse,stats)
>       allocate( lw2(43,maxbl),stat=stats )
>       call umalloc(43*maxbl,1,'lw2',memuse,stats)
>       allocate( lwdat(maxbl,maxseg,6),stat=stats )
>       call umalloc(maxbl*maxseg*6,1,'lwdat',memuse,stats)
>       allocate( mblk2nd(maxbl),stat=stats )
>       call umalloc(maxbl,1,'mblk2nd',memuse,stats)
>       allocate( mblkpt(mxxe),stat=stats )
>       call umalloc(mxxe,1,'mblkpt',memuse,stats)
>       allocate( mit(5,maxbl),stat=stats )
>       call umalloc(5*maxbl,1,'mit',memuse,stats)
>       allocate( mmceta(intmx),stat=stats )
>       call umalloc(intmx,1,'mmceta',memuse,stats)
>       allocate( mmcxie(intmx),stat=stats )
>       call umalloc(intmx,1,'mmcxie',memuse,stats)
>       allocate( nbci0(maxbl),stat=stats )
>       call umalloc(maxbl,1,'nbci0',memuse,stats)
>       allocate( nbcidim(maxbl),stat=stats )
>       call umalloc(maxbl,1,'nbcidim',memuse,stats)
>       allocate( nbcj0(maxbl),stat=stats )
>       call umalloc(maxbl,1,'nbcj0',memuse,stats)
>       allocate( nbcjdim(maxbl),stat=stats )
>       call umalloc(maxbl,1,'nbcjdim',memuse,stats)
>       allocate( nbck0(maxbl),stat=stats )
>       call umalloc(maxbl,1,'nbck0',memuse,stats)
>       allocate( nbckdim(maxbl),stat=stats )
>       call umalloc(maxbl,1,'nbckdim',memuse,stats)
>       allocate( nblcg(maxbl),stat=stats )
>       call umalloc(maxbl,1,'nblcg',memuse,stats)
>       allocate( nblg(maxgr),stat=stats )
>       call umalloc(maxgr,1,'nblg',memuse,stats)
>       allocate( nblk(2,mxbli),stat=stats )
>       call umalloc(2*mxbli,1,'nblk',memuse,stats)
>       allocate( nblk1(mptch+2),stat=stats )
>       call umalloc(mptch+2,1,'nblk1',memuse,stats)
>       allocate( nblk2(mptch+2),stat=stats )
>       call umalloc(mptch+2,1,'nblk2',memuse,stats)
>       allocate( nblkpt(maxxe),stat=stats )
>       call umalloc(maxxe,1,'nblkpt',memuse,stats)
>       allocate( nblon(mxbli),stat=stats )
>       call umalloc(mxbli,1,'nblon',memuse,stats)
>       allocate( ncgg(maxgr),stat=stats )
>       call umalloc(maxgr,1,'ncgg',memuse,stats)
>       allocate( ncheck(maxbl),stat=stats )
>       call umalloc(maxbl,1,'ncheck',memuse,stats)
>       allocate( nneg1(ncycmax),stat=stats )
>       call umalloc(ncycmax,1,'nneg1',memuse,stats)
>       allocate( nneg2(ncycmax),stat=stats )
>       call umalloc(ncycmax,1,'nneg2',memuse,stats)
>       allocate( nsegdfrm(maxbl),stat=stats )
>       call umalloc(maxbl,1,'nsegdfrm',memuse,stats)
>       allocate( omegax(maxbl),stat=stats )
>       call umalloc(maxbl,0,'omegax',memuse,stats)
>       allocate( omegay(maxbl),stat=stats )
>       call umalloc(maxbl,0,'omegay',memuse,stats)
>       allocate( omegaz(maxbl),stat=stats )
>       call umalloc(maxbl,0,'omegaz',memuse,stats)
>       allocate( omgxae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'omgxae',memuse,stats)
>       allocate( omgyae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'omgyae',memuse,stats)
>       allocate( omgzae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'omgzae',memuse,stats)
>       allocate( pav(maxcs),stat=stats )
>       call umalloc(maxcs,0,'pav',memuse,stats)
>       allocate( period_miss(lbcprd),stat=stats )
>       call umalloc(lbcprd,0,'period_miss',memuse,stats)
>       allocate( perturb(nmds,maxaes,4),stat=stats )
>       call umalloc(nmds*maxaes*4,0,'perturb',memuse,stats)
>       allocate( ptav(maxcs),stat=stats )
>       call umalloc(maxcs,0,'ptav',memuse,stats)
>       allocate( qb(iitot,5,3),stat=stats )
>       call umalloc(iitot*5*3,0,'qb',memuse,stats)
>       allocate( resmx(maxbl),stat=stats )
>       call umalloc(maxbl,0,'resmx',memuse,stats)
>       allocate( rfreqr(maxbl),stat=stats )
>       call umalloc(maxbl,0,'rfreqr',memuse,stats)
>       allocate( rfreqt(maxbl),stat=stats )
>       call umalloc(maxbl,0,'rfreqt',memuse,stats)
>       allocate( rfrqrae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'rfrqrae',memuse,stats)
>       allocate( rfrqtae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'rfrqtae',memuse,stats)
>       allocate( rkap0g(maxbl,3),stat=stats )
>       call umalloc(maxbl*3,0,'rkap0g',memuse,stats)
>       allocate( rms(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'rms',memuse,stats)
>       allocate( rmstr1(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'rmstr1',memuse,stats)
>       allocate( rmstr2(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'rmstr2',memuse,stats)
>       allocate( seta(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'seta',memuse,stats)
>       allocate( seta2(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'seta2',memuse,stats)
>       allocate( slavept(nslave,3,nmaster,5),stat=stats )
>       call umalloc(nslave*3*nmaster*5,0,'slavept',memuse,stats)
>       allocate( stm(2*nmds,2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*2*nmds*maxaes,0,'stm',memuse,stats)
>       allocate( stmi(2*nmds,2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*2*nmds*maxaes,0,'stmi',memuse,stats)
>       allocate( stot(maxcs),stat=stats )
>       call umalloc(maxcs,0,'stot',memuse,stats)
>       allocate( swett(maxbl),stat=stats )
>       call umalloc(maxbl,0,'swett',memuse,stats)
>       allocate( swetw(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'swetw',memuse,stats)
>       allocate( sx(maxcs),stat=stats )
>       call umalloc(maxcs,0,'sx',memuse,stats)
>       allocate( sxie(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'sxie',memuse,stats)
>       allocate( sxie2(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'sxie2',memuse,stats)
>       allocate( sy(maxcs),stat=stats )
>       call umalloc(maxcs,0,'sy',memuse,stats)
>       allocate( sz(maxcs),stat=stats )
>       call umalloc(maxcs,0,'sz',memuse,stats)
>       allocate( tav(maxcs),stat=stats )
>       call umalloc(maxcs,0,'tav',memuse,stats)
>       allocate( temp((mptch+2)*(mptch+2)),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'temp',memuse,stats)
>       allocate( thetax(maxbl),stat=stats )
>       call umalloc(maxbl,0,'thetax',memuse,stats)
>       allocate( thetaxl(maxbl),stat=stats )
>       call umalloc(maxbl,0,'thetaxl',memuse,stats)
>       allocate( thetay(maxbl),stat=stats )
>       call umalloc(maxbl,0,'thetay',memuse,stats)
>       allocate( thetayl(maxbl),stat=stats )
>       call umalloc(maxbl,0,'thetayl',memuse,stats)
>       allocate( thetaz(maxbl),stat=stats )
>       call umalloc(maxbl,0,'thetaz',memuse,stats)
>       allocate( thetazl(maxbl),stat=stats )
>       call umalloc(maxbl,0,'thetazl',memuse,stats)
>       allocate( thtxae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'thtxae',memuse,stats)
>       allocate( thtyae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'thtyae',memuse,stats)
>       allocate( thtzae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'thtzae',memuse,stats)
>       allocate( time2(maxbl),stat=stats )
>       call umalloc(maxbl,0,'time2',memuse,stats)
>       allocate( timekeep(ncycmax),stat=stats )
>       call umalloc(ncycmax,0,'timekeep',memuse,stats)
>       allocate( ttav(maxcs),stat=stats )
>       call umalloc(maxcs,0,'ttav',memuse,stats)
>       allocate( utrans(maxbl),stat=stats )
>       call umalloc(maxbl,0,'utrans',memuse,stats)
>       allocate( utrnsae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'utrnsae',memuse,stats)
>       allocate( vormax(maxbl),stat=stats )
>       call umalloc(maxbl,0,'vormax',memuse,stats)
>       allocate( vtrans(maxbl),stat=stats )
>       call umalloc(maxbl,0,'vtrans',memuse,stats)
>       allocate( vtrnsae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'vtrnsae',memuse,stats)
>       allocate( windex(maxxe,2),stat=stats )
>       call umalloc(maxxe*2,0,'windex',memuse,stats)
>       allocate( windx(mxxe,2),stat=stats )
>       call umalloc(mxxe*2,0,'windx',memuse,stats)
>       allocate( work(mwork),stat=stats )
>       call umalloc(mwork,0,'work',memuse,stats)
>       allocate( wtrans(maxbl),stat=stats )
>       call umalloc(maxbl,0,'wtrans',memuse,stats)
>       allocate( wtrnsae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'wtrnsae',memuse,stats)
>       allocate( x0(2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*maxaes,0,'x0',memuse,stats)
>       allocate( x1(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'x1',memuse,stats)
>       allocate( x2(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'x2',memuse,stats)
>       allocate( xie2s(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'xie2s',memuse,stats)
>       allocate( xif1(msub1),stat=stats )
>       call umalloc(msub1,1,'xif1',memuse,stats)
>       allocate( xif2(msub1),stat=stats )
>       call umalloc(msub1,1,'xif2',memuse,stats)
>       allocate( xmav(maxcs),stat=stats )
>       call umalloc(maxcs,0,'xmav',memuse,stats)
>       allocate( xmi(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'xmi',memuse,stats)
>       allocate( xmie(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'xmie',memuse,stats)
>       allocate( xorgae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'xorgae',memuse,stats)
>       allocate( xorgae0(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'xorgae0',memuse,stats)
>       allocate( xorig(maxbl),stat=stats )
>       call umalloc(maxbl,0,'xorig',memuse,stats)
>       allocate( xorig0(maxbl),stat=stats )
>       call umalloc(maxbl,0,'xorig0',memuse,stats)
>       allocate( xs(2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*maxaes,0,'xs',memuse,stats)
>       allocate( xte(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'xte',memuse,stats)
>       allocate( xxn(2*nmds,maxaes),stat=stats )
>       call umalloc(2*nmds*maxaes,0,'xxn',memuse,stats)
>       allocate( y1(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'y1',memuse,stats)
>       allocate( y2(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'y2',memuse,stats)
>       allocate( ymi(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'ymi',memuse,stats)
>       allocate( ymie(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'ymie',memuse,stats)
>       allocate( yorgae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'yorgae',memuse,stats)
>       allocate( yorgae0(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'yorgae0',memuse,stats)
>       allocate( yorig(maxbl),stat=stats )
>       call umalloc(maxbl,0,'yorig',memuse,stats)
>       allocate( yorig0(maxbl),stat=stats )
>       call umalloc(maxbl,0,'yorig0',memuse,stats)
>       allocate( yte(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'yte',memuse,stats)
>       allocate( z1(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'z1',memuse,stats)
>       allocate( z2(mptch+2,mptch+2),stat=stats )
>       call umalloc((mptch+2)*(mptch+2),0,'z2',memuse,stats)
>       allocate( zmi(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'zmi',memuse,stats)
>       allocate( zmie(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'zmie',memuse,stats)
>       allocate( zorgae(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'zorgae',memuse,stats)
>       allocate( zorgae0(maxbl,maxsegdg),stat=stats )
>       call umalloc(maxbl*maxsegdg,0,'zorgae0',memuse,stats)
>       allocate( zorig(maxbl),stat=stats )
>       call umalloc(maxbl,0,'zorig',memuse,stats)
>       allocate( zorig0(maxbl),stat=stats )
>       call umalloc(maxbl,0,'zorig0',memuse,stats)
>       allocate( zte(mptch+2,mptch+2,msub1),stat=stats )
>       call umalloc((mptch+2)*(mptch+2)*msub1,0,'zte',memuse,stats)
707,1017c1070,1380
<          call ufree(ip_work)
<          call ufree(ip_iwork)
<          call ufree(ip_lwdat)
<          call ufree(ip_lw)
<          call ufree(ip_lw2)
<          call ufree(ip_nblk)
<          call ufree(ip_limblk)
<          call ufree(ip_isva)
<          call ufree(ip_nblon)
<          call ufree(ip_resmx)
<          call ufree(ip_imx)
<          call ufree(ip_jmx)
<          call ufree(ip_kmx)
<          call ufree(ip_vormax)
<          call ufree(ip_ivmax)
<          call ufree(ip_jvmax)
<          call ufree(ip_kvmax)
<          call ufree(ip_lig)
<          call ufree(ip_lbg)
<          call ufree(ip_iovrlp)
<          call ufree(ip_qb)
<          call ufree(ip_ibpntsg)
<          call ufree(ip_iipntsg)
<          call ufree(ip_iibg)
<          call ufree(ip_jjbg)
<          call ufree(ip_kkbg)
<          call ufree(ip_ibcg)
<          call ufree(ip_dxintg)
<          call ufree(ip_dyintg)
<          call ufree(ip_dzintg)
<          call ufree(ip_iiig)
<          call ufree(ip_jjig)
<          call ufree(ip_kkig)
<          call ufree(ip_rkap0g)
<          call ufree(ip_levelg)
<          call ufree(ip_igridg)
<          call ufree(ip_iflimg)
<          call ufree(ip_ifdsg)
<          call ufree(ip_iviscg)
<          call ufree(ip_jdimg)
<          call ufree(ip_kdimg)
<          call ufree(ip_idimg)
<          call ufree(ip_idiagg)
<          call ufree(ip_nblcg)
<          call ufree(ip_idegg)
<          call ufree(ip_jsg)
<          call ufree(ip_ksg)
<          call ufree(ip_isg)
<          call ufree(ip_jeg)
<          call ufree(ip_keg)
<          call ufree(ip_ieg)
<          call ufree(ip_mit)
<          call ufree(ip_jlamlog)
<          call ufree(ip_klamlog)
<          call ufree(ip_ilamlog)
<          call ufree(ip_jlamhig)
<          call ufree(ip_klamhig)
<          call ufree(ip_ilamhig)
<          call ufree(ip_iwfg)
<          call ufree(ip_utrans)
<          call ufree(ip_vtrans)
<          call ufree(ip_wtrans)
<          call ufree(ip_omegax)
<          call ufree(ip_omegay)
<          call ufree(ip_omegaz)
<          call ufree(ip_xorig)
<          call ufree(ip_yorig)
<          call ufree(ip_zorig)
<          call ufree(ip_dxmx)
<          call ufree(ip_dymx)
<          call ufree(ip_dzmx)
<          call ufree(ip_dthxmx)
<          call ufree(ip_dthymx)
<          call ufree(ip_dthzmx)
<          call ufree(ip_thetax)
<          call ufree(ip_thetay)
<          call ufree(ip_thetaz)
<          call ufree(ip_rfreqt)
<          call ufree(ip_rfreqr)
<          call ufree(ip_xorig0)
<          call ufree(ip_yorig0)
<          call ufree(ip_zorig0)
<          call ufree(ip_time2)
<          call ufree(ip_thetaxl)
<          call ufree(ip_thetayl)
<          call ufree(ip_thetazl)
<          call ufree(ip_itrans)
<          call ufree(ip_irotat)
<          call ufree(ip_idefrm)
<          call ufree(ip_bcvali)
<          call ufree(ip_bcvalj)
<          call ufree(ip_bcvalk)
<          call ufree(ip_nbci0)
<          call ufree(ip_nbcj0)
<          call ufree(ip_nbck0)
<          call ufree(ip_nbcidim)
<          call ufree(ip_nbcjdim)
<          call ufree(ip_nbckdim)
<          call ufree(ip_ibcinfo)
<          call ufree(ip_jbcinfo)
<          call ufree(ip_kbcinfo)
<          call ufree(ip_bcfilei)
<          call ufree(ip_bcfilej)
<          call ufree(ip_bcfilek)
<          call ufree(ip_ncgg)
<          call ufree(ip_nblg)
<          call ufree(ip_iemg)
<          call ufree(ip_inewgg)
<          call ufree(ip_inpl3d)
<          call ufree(ip_inpr)
<          call ufree(ip_iadvance)
<          call ufree(ip_iforce)
<          call ufree(ip_rms)
<          call ufree(ip_clw)
<          call ufree(ip_cdw)
<          call ufree(ip_cdpw)
<          call ufree(ip_cdvw)
<          call ufree(ip_cxw)
<          call ufree(ip_cyw)
<          call ufree(ip_czw)
<          call ufree(ip_cmxw)
<          call ufree(ip_cmyw)
<          call ufree(ip_cmzw)
<          call ufree(ip_chdw)
<          call ufree(ip_swetw)
<          call ufree(ip_fmdotw)
<          call ufree(ip_cfttotw)
<          call ufree(ip_cftmomw)
<          call ufree(ip_cftpw)
<          call ufree(ip_cftvw)
<          call ufree(ip_rmstr1)
<          call ufree(ip_rmstr2)
<          call ufree(ip_nneg1)
<          call ufree(ip_nneg2)
<          call ufree(ip_swett)
<          call ufree(ip_clt)
<          call ufree(ip_cdt)
<          call ufree(ip_cxt)
<          call ufree(ip_cyt)
<          call ufree(ip_czt)
<          call ufree(ip_cmxt)
<          call ufree(ip_cmyt)
<          call ufree(ip_cmzt)
<          call ufree(ip_cdpt)
<          call ufree(ip_cdvt)
<          call ufree(ip_sx)
<          call ufree(ip_sy)
<          call ufree(ip_sz)
<          call ufree(ip_stot)
<          call ufree(ip_pav)
<          call ufree(ip_ptav)
<          call ufree(ip_tav)
<          call ufree(ip_ttav)
<          call ufree(ip_xmav)
<          call ufree(ip_fmdot)
<          call ufree(ip_cfxp)
<          call ufree(ip_cfyp)
<          call ufree(ip_cfzp)
<          call ufree(ip_cfdp)
<          call ufree(ip_cflp)
<          call ufree(ip_cftp)
<          call ufree(ip_cfxv)
<          call ufree(ip_cfyv)
<          call ufree(ip_cfzv)
<          call ufree(ip_cfdv)
<          call ufree(ip_cflv)
<          call ufree(ip_cftv)
<          call ufree(ip_cfxmom)
<          call ufree(ip_cfymom)
<          call ufree(ip_cfzmom)
<          call ufree(ip_cfdmom)
<          call ufree(ip_cflmom)
<          call ufree(ip_cftmom)
<          call ufree(ip_cfxtot)
<          call ufree(ip_cfytot)
<          call ufree(ip_cfztot)
<          call ufree(ip_cfdtot)
<          call ufree(ip_cfltot)
<          call ufree(ip_cfttot)
<          call ufree(ip_icsinfo)
<          call ufree(ip_windex)
<          call ufree(ip_iindex)
<          call ufree(ip_nblkpt)
<          call ufree(ip_windx)
<          call ufree(ip_iindx)
<          call ufree(ip_llimit)
<          call ufree(ip_iitmax)
<          call ufree(ip_mmcxie)
<          call ufree(ip_mmceta)
<          call ufree(ip_ncheck)
<          call ufree(ip_iifit)
<          call ufree(ip_mblkpt)
<          call ufree(ip_iic0)
<          call ufree(ip_iiorph)
<          call ufree(ip_iitoss)
<          call ufree(ip_ifiner)
<          call ufree(ip_dthetxx)
<          call ufree(ip_dthetyy)
<          call ufree(ip_dthetzz)
<          call ufree(ip_dx)
<          call ufree(ip_dy)
<          call ufree(ip_dz)
<          call ufree(ip_dthetx)
<          call ufree(ip_dthety)
<          call ufree(ip_dthetz)
<          call ufree(ip_lout)
<          call ufree(ip_xif1)
<          call ufree(ip_xif2)
<          call ufree(ip_etf1)
<          call ufree(ip_etf2)
<          call ufree(ip_jjmax1)
<          call ufree(ip_kkmax1)
<          call ufree(ip_iiint1)
<          call ufree(ip_iiint2)
<          call ufree(ip_jimage)
<          call ufree(ip_kimage)
<          call ufree(ip_jte)
<          call ufree(ip_kte)
<          call ufree(ip_jmm)
<          call ufree(ip_kmm)
<          call ufree(ip_nblk1)
<          call ufree(ip_nblk2)
<          call ufree(ip_xte)
<          call ufree(ip_yte)
<          call ufree(ip_zte)
<          call ufree(ip_xmi)
<          call ufree(ip_ymi)
<          call ufree(ip_zmi)
<          call ufree(ip_xmie)
<          call ufree(ip_ymie)
<          call ufree(ip_zmie)
<          call ufree(ip_sxie)
<          call ufree(ip_seta)
<          call ufree(ip_sxie2)
<          call ufree(ip_seta2)
<          call ufree(ip_xie2s)
<          call ufree(ip_eta2s)
<          call ufree(ip_temp)
<          call ufree(ip_x2)
<          call ufree(ip_y2)
<          call ufree(ip_z2)
<          call ufree(ip_x1)
<          call ufree(ip_y1)
<          call ufree(ip_z1)
<          call ufree(ip_factjlo)
<          call ufree(ip_factjhi)
<          call ufree(ip_factklo)
<          call ufree(ip_factkhi)
<          call ufree(ip_ifrom)
<          call ufree(ip_geom_miss)
<          call ufree(ip_period_miss)
<          call ufree(ip_isav_blk)
<          call ufree(ip_isav_prd)
<          call ufree(ip_isav_pat)
<          call ufree(ip_isav_pat_b)
<          call ufree(ip_isav_dpat)
<          call ufree(ip_isav_dpat_b)
<          call ufree(ip_isav_emb)
<          call ufree(ip_mblk2nd)
<          call ufree(ip_istat2_bl)
<          call ufree(ip_istat2_pa)
<          call ufree(ip_istat2_pe)
<          call ufree(ip_istat2_em)
<          call ufree(ip_utrnsae)
<          call ufree(ip_vtrnsae)
<          call ufree(ip_wtrnsae)
<          call ufree(ip_omgxae)
<          call ufree(ip_omgyae)
<          call ufree(ip_omgzae)
<          call ufree(ip_xorgae)
<          call ufree(ip_yorgae)
<          call ufree(ip_zorgae)
<          call ufree(ip_xorgae0)
<          call ufree(ip_yorgae0)
<          call ufree(ip_zorgae0)
<          call ufree(ip_icouple)
<          call ufree(ip_thtxae)
<          call ufree(ip_thtyae)
<          call ufree(ip_thtzae)
<          call ufree(ip_rfrqtae)
<          call ufree(ip_rfrqrae)
<          call ufree(ip_icsi)
<          call ufree(ip_icsf)
<          call ufree(ip_jcsi)
<          call ufree(ip_jcsf)
<          call ufree(ip_kcsi)
<          call ufree(ip_kcsf)
<          call ufree(ip_nsegdfrm)
<          call ufree(ip_idfrmseg)
<          call ufree(ip_iaesurf)
<          call ufree(ip_freq)
<          call ufree(ip_gmass)
<          call ufree(ip_x0)
<          call ufree(ip_gf0)
<          call ufree(ip_damp)
<          call ufree(ip_perturb)
<          call ufree(ip_aesrfdat)
<          call ufree(ip_slavept)
<          call ufree(ip_iskip)
<          call ufree(ip_jskip)
<          call ufree(ip_kskip)
<          call ufree(ip_bmat)
<          call ufree(ip_stm)
<          call ufree(ip_stmi)
<          call ufree(ip_xs)
<          call ufree(ip_xxn)
<          call ufree(ip_gforcn)
<          call ufree(ip_gforcnm)
<          call ufree(ip_gforcs)
<          call ufree(ip_aehist)
<          call ufree(ip_timekeep)
---
>          deallocate(work)
>          deallocate(iwork)
>          deallocate(lwdat)
>          deallocate(lw)
>          deallocate(lw2)
>          deallocate(nblk)
>          deallocate(limblk)
>          deallocate(isva)
>          deallocate(nblon)
>          deallocate(resmx)
>          deallocate(imx)
>          deallocate(jmx)
>          deallocate(kmx)
>          deallocate(vormax)
>          deallocate(ivmax)
>          deallocate(jvmax)
>          deallocate(kvmax)
>          deallocate(lig)
>          deallocate(lbg)
>          deallocate(iovrlp)
>          deallocate(qb)
>          deallocate(ibpntsg)
>          deallocate(iipntsg)
>          deallocate(iibg)
>          deallocate(jjbg)
>          deallocate(kkbg)
>          deallocate(ibcg)
>          deallocate(dxintg)
>          deallocate(dyintg)
>          deallocate(dzintg)
>          deallocate(iiig)
>          deallocate(jjig)
>          deallocate(kkig)
>          deallocate(rkap0g)
>          deallocate(levelg)
>          deallocate(igridg)
>          deallocate(iflimg)
>          deallocate(ifdsg)
>          deallocate(iviscg)
>          deallocate(jdimg)
>          deallocate(kdimg)
>          deallocate(idimg)
>          deallocate(idiagg)
>          deallocate(nblcg)
>          deallocate(idegg)
>          deallocate(jsg)
>          deallocate(ksg)
>          deallocate(isg)
>          deallocate(jeg)
>          deallocate(keg)
>          deallocate(ieg)
>          deallocate(mit)
>          deallocate(jlamlog)
>          deallocate(klamlog)
>          deallocate(ilamlog)
>          deallocate(jlamhig)
>          deallocate(klamhig)
>          deallocate(ilamhig)
>          deallocate(iwfg)
>          deallocate(utrans)
>          deallocate(vtrans)
>          deallocate(wtrans)
>          deallocate(omegax)
>          deallocate(omegay)
>          deallocate(omegaz)
>          deallocate(xorig)
>          deallocate(yorig)
>          deallocate(zorig)
>          deallocate(dxmx)
>          deallocate(dymx)
>          deallocate(dzmx)
>          deallocate(dthxmx)
>          deallocate(dthymx)
>          deallocate(dthzmx)
>          deallocate(thetax)
>          deallocate(thetay)
>          deallocate(thetaz)
>          deallocate(rfreqt)
>          deallocate(rfreqr)
>          deallocate(xorig0)
>          deallocate(yorig0)
>          deallocate(zorig0)
>          deallocate(time2)
>          deallocate(thetaxl)
>          deallocate(thetayl)
>          deallocate(thetazl)
>          deallocate(itrans)
>          deallocate(irotat)
>          deallocate(idefrm)
>          deallocate(bcvali)
>          deallocate(bcvalj)
>          deallocate(bcvalk)
>          deallocate(nbci0)
>          deallocate(nbcj0)
>          deallocate(nbck0)
>          deallocate(nbcidim)
>          deallocate(nbcjdim)
>          deallocate(nbckdim)
>          deallocate(ibcinfo)
>          deallocate(jbcinfo)
>          deallocate(kbcinfo)
>          deallocate(bcfilei)
>          deallocate(bcfilej)
>          deallocate(bcfilek)
>          deallocate(ncgg)
>          deallocate(nblg)
>          deallocate(iemg)
>          deallocate(inewgg)
>          deallocate(inpl3d)
>          deallocate(inpr)
>          deallocate(iadvance)
>          deallocate(iforce)
>          deallocate(rms)
>          deallocate(clw)
>          deallocate(cdw)
>          deallocate(cdpw)
>          deallocate(cdvw)
>          deallocate(cxw)
>          deallocate(cyw)
>          deallocate(czw)
>          deallocate(cmxw)
>          deallocate(cmyw)
>          deallocate(cmzw)
>          deallocate(chdw)
>          deallocate(swetw)
>          deallocate(fmdotw)
>          deallocate(cfttotw)
>          deallocate(cftmomw)
>          deallocate(cftpw)
>          deallocate(cftvw)
>          deallocate(rmstr1)
>          deallocate(rmstr2)
>          deallocate(nneg1)
>          deallocate(nneg2)
>          deallocate(swett)
>          deallocate(clt)
>          deallocate(cdt)
>          deallocate(cxt)
>          deallocate(cyt)
>          deallocate(czt)
>          deallocate(cmxt)
>          deallocate(cmyt)
>          deallocate(cmzt)
>          deallocate(cdpt)
>          deallocate(cdvt)
>          deallocate(sx)
>          deallocate(sy)
>          deallocate(sz)
>          deallocate(stot)
>          deallocate(pav)
>          deallocate(ptav)
>          deallocate(tav)
>          deallocate(ttav)
>          deallocate(xmav)
>          deallocate(fmdot)
>          deallocate(cfxp)
>          deallocate(cfyp)
>          deallocate(cfzp)
>          deallocate(cfdp)
>          deallocate(cflp)
>          deallocate(cftp)
>          deallocate(cfxv)
>          deallocate(cfyv)
>          deallocate(cfzv)
>          deallocate(cfdv)
>          deallocate(cflv)
>          deallocate(cftv)
>          deallocate(cfxmom)
>          deallocate(cfymom)
>          deallocate(cfzmom)
>          deallocate(cfdmom)
>          deallocate(cflmom)
>          deallocate(cftmom)
>          deallocate(cfxtot)
>          deallocate(cfytot)
>          deallocate(cfztot)
>          deallocate(cfdtot)
>          deallocate(cfltot)
>          deallocate(cfttot)
>          deallocate(icsinfo)
>          deallocate(windex)
>          deallocate(iindex)
>          deallocate(nblkpt)
>          deallocate(windx)
>          deallocate(iindx)
>          deallocate(llimit)
>          deallocate(iitmax)
>          deallocate(mmcxie)
>          deallocate(mmceta)
>          deallocate(ncheck)
>          deallocate(iifit)
>          deallocate(mblkpt)
>          deallocate(iic0)
>          deallocate(iiorph)
>          deallocate(iitoss)
>          deallocate(ifiner)
>          deallocate(dthetxx)
>          deallocate(dthetyy)
>          deallocate(dthetzz)
>          deallocate(dx)
>          deallocate(dy)
>          deallocate(dz)
>          deallocate(dthetx)
>          deallocate(dthety)
>          deallocate(dthetz)
>          deallocate(lout)
>          deallocate(xif1)
>          deallocate(xif2)
>          deallocate(etf1)
>          deallocate(etf2)
>          deallocate(jjmax1)
>          deallocate(kkmax1)
>          deallocate(iiint1)
>          deallocate(iiint2)
>          deallocate(jimage)
>          deallocate(kimage)
>          deallocate(jte)
>          deallocate(kte)
>          deallocate(jmm)
>          deallocate(kmm)
>          deallocate(nblk1)
>          deallocate(nblk2)
>          deallocate(xte)
>          deallocate(yte)
>          deallocate(zte)
>          deallocate(xmi)
>          deallocate(ymi)
>          deallocate(zmi)
>          deallocate(xmie)
>          deallocate(ymie)
>          deallocate(zmie)
>          deallocate(sxie)
>          deallocate(seta)
>          deallocate(sxie2)
>          deallocate(seta2)
>          deallocate(xie2s)
>          deallocate(eta2s)
>          deallocate(temp)
>          deallocate(x2)
>          deallocate(y2)
>          deallocate(z2)
>          deallocate(x1)
>          deallocate(y1)
>          deallocate(z1)
>          deallocate(factjlo)
>          deallocate(factjhi)
>          deallocate(factklo)
>          deallocate(factkhi)
>          deallocate(ifrom)
>          deallocate(geom_miss)
>          deallocate(period_miss)
>          deallocate(isav_blk)
>          deallocate(isav_prd)
>          deallocate(isav_pat)
>          deallocate(isav_pat_b)
>          deallocate(isav_dpat)
>          deallocate(isav_dpat_b)
>          deallocate(isav_emb)
>          deallocate(mblk2nd)
>          deallocate(istat2_bl)
>          deallocate(istat2_pa)
>          deallocate(istat2_pe)
>          deallocate(istat2_em)
>          deallocate(utrnsae)
>          deallocate(vtrnsae)
>          deallocate(wtrnsae)
>          deallocate(omgxae)
>          deallocate(omgyae)
>          deallocate(omgzae)
>          deallocate(xorgae)
>          deallocate(yorgae)
>          deallocate(zorgae)
>          deallocate(xorgae0)
>          deallocate(yorgae0)
>          deallocate(zorgae0)
>          deallocate(icouple)
>          deallocate(thtxae)
>          deallocate(thtyae)
>          deallocate(thtzae)
>          deallocate(rfrqtae)
>          deallocate(rfrqrae)
>          deallocate(icsi)
>          deallocate(icsf)
>          deallocate(jcsi)
>          deallocate(jcsf)
>          deallocate(kcsi)
>          deallocate(kcsf)
>          deallocate(nsegdfrm)
>          deallocate(idfrmseg)
>          deallocate(iaesurf)
>          deallocate(freq)
>          deallocate(gmass)
>          deallocate(x0)
>          deallocate(gf0)
>          deallocate(damp)
>          deallocate(perturb)
>          deallocate(aesrfdat)
>          deallocate(slavept)
>          deallocate(iskip)
>          deallocate(jskip)
>          deallocate(kskip)
>          deallocate(bmat)
>          deallocate(stm)
>          deallocate(stmi)
>          deallocate(xs)
>          deallocate(xxn)
>          deallocate(gforcn)
>          deallocate(gforcnm)
>          deallocate(gforcs)
>          deallocate(aehist)
>          deallocate(timekeep)
Index: source/cfl3d/dist/cputim.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/cputim.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
51c51
<       real*4 walltime
---
>       real*4 walltime,totaltime
134c134
<       call etime_(tm)
---
>       totaltime = etime_(tm)
137c137
<       call etime(tm)
---
>       totaltime = etime(tm)
174,178c174,189
< c           correct wall time for > 24  hour runs
< c
<             walltime = tim(3,1)
<             ndays = int(real(tim(1,1))+real(tim(2,1)))/86400
<             if (ndays .gt. 0) walltime = walltime + ndays*86400
---
> c           best attempt at correct wall time for > 24  hour runs:
> c           the problem seems to be that tim(3,2), supposedly the wall
> c           time, gets reset after 24 hours. have to creative in the case
> c           the total time - system+user - is not *quite* 24 hours and
> c           the true wall time is just over 24 hours, so that ndays=0
> c           but tim(3,2) is small. in that case use the total time as
> c           the wall time.
> c
>             walltime  = tim(3,1)
>             totaltime = tim(1,1) + tim(2,1)
>             ndays = int(real(totaltime))/86400
>             if (ndays .gt. 0) then
>                walltime = walltime + ndays*86400
>             else
>                walltime = max(walltime,totaltime)
>             end if
194c205
< c              correct wall time for > 24  hour runs
---
> c              best attempt at correct wall time for > 24  hour runs
196,198c207,214
<                walltime = tim_nd(3,1)
<                ndays = int(real(tim_nd(1,1))+real(tim_nd(2,1)))/86400
<                if (ndays .gt. 0) walltime = walltime + ndays*86400
---
>                walltime  = tim_nd(3,1)
>                totaltime = tim_nd(1,1) + tim_nd(2,1)
>                ndays = int(real(totaltime))/86400
>                if (ndays .gt. 0) then
>                   walltime = walltime + ndays*86400
>                else
>                   walltime = max(walltime,totaltime)
>                end if
237c253
< c           correct wall time for > 24  hour runs
---
> c           best attempt at correct wall time for > 24  hour runs
239,241c255,262
<             walltime = tim(3,2)
<             ndays = int(real(tim(1,2))+real(tim(2,2)))/86400
<             if (ndays .gt. 0) walltime = walltime + ndays*86400
---
>             walltime  = tim(3,2)
>             totaltime = tim(1,1) + tim(2,1)
>             ndays = int(real(totaltime))/86400
>             if (ndays .gt. 0) then
>                walltime = walltime + ndays*86400
>             else
>                walltime = max(walltime,totaltime)
>             end if
258c279
< c              correct wall time for > 24  hour runs
---
> c              best attempt at correct wall time for > 24  hour runs
260,262c281,288
<                walltime = tim_nd(3,2)
<                ndays = int(real(tim_nd(1,2))+real(tim_nd(2,2)))/86400
<                if (ndays .gt. 0) walltime = walltime + ndays*86400
---
>                walltime  = tim_nd(3,2)
>                totaltime = tim(1,1) + tim(2,1)
>                ndays = int(real(totaltime))/86400
>                if (ndays .gt. 0) then
>                   walltime = walltime + ndays*86400
>                else
>                   walltime = max(walltime,totaltime)
>                end if
Index: source/cfl3d/dist/dynptch.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/dynptch.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
20c20
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
53c53
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
112c112
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
464c464
< #   ifdef IBM then
---
> #   ifdef IBM
Index: source/cfl3d/dist/findmin_new.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/findmin_new.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
81c81
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/dist/main.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/main.F,v
retrieving revision 1.4
retrieving revision 1.11
diff -r1.4 -r1.11
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
9c9
< c     VERSION 6.0 :  Computational Fluids Laboratory, Mail Stop 128,
---
> c     VERSION 6.X :  Computational Fluids Laboratory, Mail Stop 128,
155a156,157
> c           96......cfl3d_avgg.p3d
> c           97......cfl3d_avgq.p3d
243a246,249
> c
> c     As of Feb 2002, F90 allocate is used rather than Cray pointers;
> c     however, the other info in 9) below is still valid
> c
289c295
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
292a299,300
>       character*32 basedesired
>       character*80 sysfile
296d303
< c   ***CGNSstart
298d304
< c   ***CGNSend
302c308
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
307a314
>       common /wrestq/ irest,irest2
465d471
< c   ***CGNSstart
467d472
< c   ***CGNSend
470d474
< c   ***CGNSstart
477d480
< c   ***CGNSend
499a503,504
>       avgg      = 'cfl3d_avgg.p3d'
>       avgq      = 'cfl3d_avgq.p3d'
510a516,517
>       open(unit=96,file=avgg,form='unformatted',status='unknown')
>       open(unit=97,file=avgq,form='unformatted',status='unknown')
534a542,546
> c     remove the stop file if there is one 
> c
>       sysfile = 'rm -f stop'
>       call system(sysfile)
> c
667a680,695
> c   Write input file used to CGNS file
> #if defined CGNS
>       if (icgns .eq. 1 .and. myid .eq. myhost) then
>         basedesired='Base'
>         idimdesired=3
>         call wopencgns(grid,basedesired,idimdesired,iccg,
>      .              ibase,nzones)
>         call writeinput(iccg,ibase,iunit5,irest)
> c   Close data base
>         call cg_close_f(iccg, ier)
>         if (ier .ne. 0) then
>           call cg_error_print_f
>           call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>         end if
>       end if
> #endif
Index: source/cfl3d/dist/mgbl.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/mgbl.F,v
retrieving revision 1.4
retrieving revision 1.11
diff -r1.4 -r1.11
53c53
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
87c87
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
92c92
<       real*4 tim(3,3),tm(3)
---
>       real*4 tim(3,3),tm(3),walltime,totaltime
228c228
<       common /cfl/ dt0
---
>       common /cfl/ dt0,dtold
240c240
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
290,295d289
<       gamma    = 1.4e0
<       gm1      = gamma-1.0e0
<       gp1      = gamma+1.0e0
<       gm1g     = gm1/gamma
<       gp1g     = gp1/gamma
<       ggm1     = gamma*gm1
317c311
<  9990    format(2(2h *),43h   VERSION 6.0 :  Computational Fluids Lab,,
---
>  9990    format(2(2h *),43h   VERSION 6.X :  Computational Fluids Lab,,
320c314
<      .   3x,2(2h *),/2(2h *),18x,33hRelease Date:    August  8, 2001.,
---
>      .   3x,2(2h *),/2(2h *),18x,33hRelease Date:       MMM DD, YYYY.,
585a580,588
> c
> c     constants derived from gamma
> c
>       gm1  = gamma-1.0e0
>       gp1  = gamma+1.0e0
>       gm1g = gm1/gamma
>       gp1g = gp1/gamma
>       ggm1 = gamma*gm1
> c
779a783,799
> c
> c        best attempt at correct wall time for > 24  hour runs:
> c        the problem seems to be that tim(3,2), supposedly the wall
> c        time, gets reset after 24 hours. have to creative in the case
> c        the total time - system+user - is not *quite* 24 hours and 
> c        the true wall time is just over 24 hours, so that ndays=0
> c        but tim(3,2) is small. in that case use the total time as
> c        the wall time.
> c
>          walltime  = tim(3,1)
>          totaltime = tim(1,1) + tim(2,1)
>          ndays = int(real(totaltime))/86400
>          if (ndays .gt. 0) then
>             walltime = walltime + ndays*86400
>          else
>             walltime = max(walltime,totaltime)
>          end if
781c801
<             rate(iseq) = 1.e6*tim(3,2)/
---
>             rate(iseq) = 1.e6*walltime/
784c804
<             rate(iseq) = 1.e6*tim(3,2)/
---
>             rate(iseq) = 1.e6*walltime/
Index: source/cfl3d/dist/mgblk.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/mgblk.F,v
retrieving revision 1.3
retrieving revision 1.15
diff -r1.3 -r1.15
53c53
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
87a88,89
>       logical stop_me
> c
91c93
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
94d95
< c   ***CGNSstart
96d96
< c   ***CGNSend
225a226
>       dimension istop_data(10)
227c228
<       common /cfl/ dt0
---
>       common /cfl/ dt0,dtold
229d229
< c   ***CGNSstart
232d231
< c   ***CGNSend
242c241,242
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
>       common /avgdata/ xnumavg,iteravg
256c256
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
274c274
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
372a373,374
>       stop_me = .false.
> c
451a454,463
> c
> c     initialize mismatch check arrays
> c
>       do nn=1,2*mxbli
>          geom_miss(nn) = 0.
>       end do
>       do nn=1,lbcprd
>          period_miss(nn) = 0.
>       end do
> c
642a655,691
> c     check for user stop file - will then stop on next time step
> c
>       if (myid.eq.myhost) then
>         inquire (file='stop',exist=stop_me)
>         if (stop_me) then
> c         must set ntstep to current time step AND set number of cycles on all
> c         higher levels to zero
>           ntstep = nt
>           do is  = iseq+1,mseq
>             ncyc1(is) = 0
>           end do
>           write(11,*)
>           write(11,'(a,i5)')
>      .    'Stopping: user-invoked stop file detected at time step ',
>      .    ntstep
>           write(11,*)
>         end if
>       end if
> #if defined DIST_MPI
>       istop_data(1) = ntstep
>       do is =1,mseq
>         istop_data(is+1) = ncyc1(is)
>       end do
>       call MPI_Bcast (istop_data,mseq+1,MPI_INTEGER,myhost,mycomm,ierr)
>       ntstep = istop_data(1)
>       do is =1,mseq
>         ncyc1(is) = istop_data(is+1)
>       end do
> #endif
> 
> c
>       itatemp=ita
> c     always do 1st order time 1st iteration if restarting and changing time step
>       if (nt .eq. 1 .and. dt .ne. dtold) then
>         ita=sign(1,ita)
>       end if
> c
851a901,933
> c     check for user stop file - will then stop on next MG cycle
> c     (if unsteady, we don't want to stop until the next time step,
> c     so always to all MG cycles)
> c
>       if (myid .eq. myhost) then
>         if (real(dt) .lt. 0.) then
>           inquire (file='stop',exist=stop_me)
>           if (stop_me) then
> c            must set ncyc to current cycle AND set number of cycles on all
> c            higher levels to zero
>              ncyc = icyc
>              do is  = iseq+1,mseq
>                ncyc1(is) = 0
>              end do
>              write(11,*)
>              write(11,'(a,i5)') 
>      .       'Stopping: user-invoked stop file detected at cycle ',icyc
>              write(11,*)
>           end if
>         end if
>       end if
> #if defined DIST_MPI
>       istop_data(1) = ncyc
>       do is =1,mseq
>         istop_data(is+1) = ncyc1(is)
>       end do
>       call MPI_Bcast (istop_data,mseq+1,MPI_INTEGER,myhost,mycomm,ierr)
>       ncyc = istop_data(1)
>       do is =1,mseq
>         ncyc1(is) = istop_data(is+1)
>       end do
> #endif
> c
1220a1303,1310
>       if (iteravg .eq. 1 .or. iteravg .eq. 2) then
>         if (level .ge. lglobal .and. ntime .eq. nit) then
>           if (real(dt) .lt. 0. .or. (real(dt) .gt. 0. and. 
>      +        icyc .eq. ncyc)) then
>             xnumavg=xnumavg+1.
>           end if
>         end if
>       end if
1371c1461
<      .              iadvance)
---
>      .              iadvance,w(lqavg))
2245d2334
< c   ***CGNSstart
2247d2335
< c   ***CGNSend
2251d2338
< c   ***CGNSstart
2263c2350,2367
< c   ***CGNSend
---
>                end if
>                if (iteravg .eq. 1 .or. iteravg .eq. 2) then
>                  if (myid.eq.myhost) then
>                    write(11,2222)
>                    write(11,2223)
>                    write(11,2225) avgg
>                    write(11,2225) avgq
>                    rewind(96)
>                    rewind(97)
>                    write(96) ngrid
>                    write(97) ngrid
>                    write(96) (idimg(nblg(igrid)+mseq-iseq)-1,
>      .               jdimg(nblg(igrid)+mseq-iseq)-1,
>      .               kdimg(nblg(igrid)+mseq-iseq)-1,igrid=1,ngrid)
>                    write(97) (idimg(nblg(igrid)+mseq-iseq)-1,
>      .               jdimg(nblg(igrid)+mseq-iseq)-1,
>      .               kdimg(nblg(igrid)+mseq-iseq)-1,igrid=1,ngrid)
>                  end if
2271d2374
< c   ***CGNSstart
2278d2380
< c   ***CGNSend
2282d2383
< c   ***CGNSstart
2285c2386
<                  write(11,'('' not enough memory for CGNS Q write.'')')
---
>                  write(11,'('' not enough memory for cgns Q write.'')')
2295d2395
< c   ***CGNSend
2301,2302d2400
< c   ***CGNSstart
< c    .            thetay,maxbl,myid,myhost,mycomm,mblk2nd)
2306,2307c2404,2405
<      .            iwk,iwork,iovrlp(nbl),nou,bou,nbuf,ibufdim)
< c   ***CGNSend
---
>      .            iwk,iwork,iovrlp(nbl),nou,bou,nbuf,ibufdim,
>      .            w(lqavg),w(lx),w(ly),w(lz))
2311d2408
< c   ***CGNSstart
2313d2409
< c   ***CGNSend
2315d2410
< c   ***CGNSstart
2318,2319d2412
< c   Write input file used to CGNS file
<                  call writeinput(iccg,ibase,iunit5)
2329d2421
< c   ***CGNSend
2333a2426,2434
> 
> c
> c     the following line is added to allow exit from
> c     loop 7000 if the user has altered ntstep via
> c     the "stop" file
> c
>       if (icyc.ge.ncyc) go to 7011
> c
> 
2336a2438,2441
> 7011  continue
> c     recover original ita
>       ita=itatemp
> c
2392d2496
< c   ***CGNSstart
2394d2497
< c   ***CGNSend
2398d2500
< c   ***CGNSstart
2408c2510,2528
< c   ***CGNSend
---
>                end if
>                if (iteravg .eq. 1 .or. iteravg .eq. 2) then
>                  if (myid.eq.myhost) then
>                    write(11,2222)
>                    write(11,2223)
>                    write(11,2224)
>                    write(11,2225) avgg
>                    write(11,2225) avgq
>                    rewind(96)
>                    rewind(97)
>                    write(96) ngrid
>                    write(97) ngrid
>                    write(96) (idimg(nblg(igrid)+mseq-iseq)-1,
>      .               jdimg(nblg(igrid)+mseq-iseq)-1,
>      .               kdimg(nblg(igrid)+mseq-iseq)-1,igrid=1,ngrid)
>                    write(97) (idimg(nblg(igrid)+mseq-iseq)-1,
>      .               jdimg(nblg(igrid)+mseq-iseq)-1,
>      .               kdimg(nblg(igrid)+mseq-iseq)-1,igrid=1,ngrid)
>                  end if
2416d2535
< c   ***CGNSstart
2423d2541
< c   ***CGNSend
2427d2544
< c   ***CGNSstart
2430c2547
<                  write(11,'('' not enough memory for CGNS Q write.'')')
---
>                  write(11,'('' not enough memory for cgns Q write.'')')
2440d2556
< c   ***CGNSend
2446,2447d2561
< c   ***CGNSstart
< c    .            thetay,maxbl,myid,myhost,mycomm,mblk2nd)
2451,2452c2565,2566
<      .            iwk,iwork,iovrlp(nbl),nou,bou,nbuf,ibufdim)
< c   ***CGNSend
---
>      .            iwk,iwork,iovrlp(nbl),nou,bou,nbuf,ibufdim,
>      .            w(lqavg),w(lx),w(ly),w(lz))
2464d2577
< c   ***CGNSstart
2466d2578
< c   ***CGNSend
2468d2579
< c   ***CGNSstart
2474d2584
< c   ***CGNSend
2484d2593
< c   ***CGNSstart
2491d2599
< c   ***CGNSend
2495d2602
< c   ***CGNSstart
2498c2605
<                  write(11,'('' not enough memory for CGNS'',
---
>                  write(11,'('' not enough memory for cgns'',
2509d2615
< c   ***CGNSend
2524,2527c2630
< c   ***CGNSstart
< c    .                 nwork)
<      .                 nwork,idima,jdima,kdima,igrid)
< c   ***CGNSend
---
>      .                 nwork,idima,jdima,kdima,igrid,w(lxib2))
2539d2641
< c   ***CGNSstart
2546d2647
< c   ***CGNSend
2550d2650
< c   ***CGNSstart
2553c2653
<                  write(11,'('' not enough memory for CGNS'',
---
>                  write(11,'('' not enough memory for cgns'',
2564d2663
< c   ***CGNSend
2580,2583c2679
< c   ***CGNSstart
< c    .                    nwork)
<      .                    nwork,idima,jdima,kdima,igrid)
< c   ***CGNSend
---
>      .                    nwork,idima,jdima,kdima,igrid,w(lxib2))
2585a2682,2694
> #if defined CGNS
>                else
>                   do igrid=1,ngrid
> c       need to delete certain nodes if they exist
>                     call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,'end')
>                     call cg_delete_node_f('RigidGridMotion',ier)
>                     call cg_delete_node_f('ArbitraryGridMotion',ier)
>                     call cg_delete_node_f('MovedGrid',ier)
>                     call cg_delete_node_f('MovedGridLastDT',ier)
>                   enddo
> #endif
2592d2700
< c   ***CGNSstart
2594d2701
< c   ***CGNSend
2604d2710
< c   ***CGNSstart
2606,2608c2712,2723
<                          write(11,'('' cgns not working for '',
<      .                    ''deforming yet'')')
<                          call termn8(myid,-1,ibufdim,nbuf,bou,nou)
---
> #if defined CGNS
>                          maxnum=2*nmds*naesrf
>                          maxnum2=ntt*3*nmds*naesrf
>                          if ((maxnum+maxnum2) .gt. nwork) then
>                            write(11,'('' not enough room in wk for'',
>      .                       '' writing data in waeromode'')')
>                            call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>                          end if
>                          call waeromode(iccg,ibase,timekeep,xxn,gforcn,
>      .                    gforcnm,aehist,ncycmax,nmds,maxaes,
>      .                    ntt,naesrf,wk,maxnum,wk(maxnum+1),maxnum2)
> #endif
2610c2725,2732
< c   ***CGNSend
---
> #if defined CGNS
>                    else
> c       need to delete CFL3DAeroModeData node if it exists
>                      call cg_goto_f(iccg,ibase,ier,'end')
>                      call cg_delete_node_f('CFL3DAeroModeData',ier)
> #endif
2612d2733
< c   ***CGNSstart
2614d2734
< c   ***CGNSend
2616d2735
< c   ***CGNSstart
2619,2620d2737
< c   Write input file used to CGNS file
<                  call writeinput(iccg,ibase,iunit5)
2629d2745
< c   ***CGNSend
2686a2803,2809
> c     the following line is added to allow exit from
> c     loop 6000 if the user has altered ntstep via
> c     the "stop" file
> c
>       if (nt.ge.ntstep) go to 6011
> c
> 
2688a2812,2813
>  6011 continue
> c
2727a2853,2857
>  2222 format(/,50h writing unformatted running-average cell-centered,
>      .       30h PLOT3D files (MG,3D,iblanked))
>  2223 format(38h   in same precision that code was run)
>  2224 format(54h   grid is LATEST cell-center grid (not time-averaged))
>  2225 format(8x,a80)
Index: source/cfl3d/dist/patcher.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/patcher.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
16c16
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
145c145
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
201c201
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
Index: source/cfl3d/dist/plot3c.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/plot3c.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
11c11
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
1541,1543c1541,1543
<    77     format(/3x,1hI,3x,1hJ,3x,1hK,5x,1hX,10x,1hY,10x,1hZ,
<      .    8x,6hU/Uinf,5x,6hV/Vinf,5x,6hW/Winf,5x,6hP/Pinf,
<      .    5x,6hT/Tinf,6x,4hMACH,6x,6h    cp,4x,9htur. vis.)
---
>    77     format(/3x,1hI,3x,1hJ,3x,1hK,7x,1hX,12x,1hY,12x,1hZ,
>      .    10x,6hU/Uinf,7x,6hV/Vinf,7x,6hW/Winf,7x,6hP/Pinf,
>      .    7x,6hT/Tinf,8x,4hMACH,8x,6h    cp,6x,9htur. vis.)
1546,1548c1546,1548
<     7     format(/3x,1hI,3x,1hJ,3x,1hK,5x,1hX,10x,1hY,10x,1hZ,
<      .    8x,6hU/Uinf,5x,6hV/Vinf,5x,6hW/Winf,5x,6hP/Pinf,
<      .    5x,6hT/Tinf,6x,4hMACH,6x,6hpitotp,4x,9htur. vis.)
---
>     7     format(/3x,1hI,3x,1hJ,3x,1hK,7x,1hX,12x,1hY,12x,1hZ,
>      .    10x,6hU/Uinf,7x,6hV/Vinf,7x,6hW/Winf,7x,6hP/Pinf,
>      .    7x,6hT/Tinf,8x,4hMACH,8x,6hpitotp,6x,9htur. vis.)
1602c1602
<    29    format(3i4,11(1x,e10.4))
---
>    29    format(3i4,11(1x,e12.5))
Index: source/cfl3d/dist/plot3d.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/plot3d.F,v
retrieving revision 1.5
retrieving revision 1.7
diff -r1.5 -r1.7
10c10
<      .                  sj,sk,si,vol)
---
>      .                  sj,sk,si,vol,nset)
12c12
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
48c48
<       real*4    xw(jdw,kdw,idw,5),xg(jdw,kdw,idw,4)
---
>       real*4    xw(jdw,kdw,idw,nset),xg(jdw,kdw,idw,4)
51c51
<       real xw(jdw,kdw,idw,5),xg(jdw,kdw,idw,4)
---
>       real xw(jdw,kdw,idw,nset),xg(jdw,kdw,idw,4)
1287,1289c1287,1289
<    77      format(/3x,1hI,3x,1hJ,3x,1hK,5x,1hX,10x,1hY,10x,1hZ,
<      .     8x,6hU/Uinf,5x,6hV/Vinf,5x,6hW/Winf,5x,6hP/Pinf,
<      .     5x,6hT/Tinf,6x,4hMACH,6x,6h    cp,4x,9htur. vis.)
---
>    77      format(/3x,1hI,3x,1hJ,3x,1hK,7x,1hX,12x,1hY,12x,1hZ,
>      .     10x,6hU/Uinf,7x,6hV/Vinf,7x,6hW/Winf,7x,6hP/Pinf,
>      .     7x,6hT/Tinf,8x,4hMACH,8x,6h    cp,6x,9htur. vis.)
1292,1294c1292,1294
<     7      format(/3x,1hI,3x,1hJ,3x,1hK,5x,1hX,10x,1hY,10x,1hZ,
<      .     8x,6hU/Uinf,5x,6hV/Vinf,5x,6hW/Winf,5x,6hP/Pinf,
<      .     5x,6hT/Tinf,6x,4hMACH,6x,6hpitotp,4x,9htur. vis.)
---
>     7      format(/3x,1hI,3x,1hJ,3x,1hK,7x,1hX,12x,1hY,12x,1hZ,
>      .     10x,6hU/Uinf,7x,6hV/Vinf,7x,6hW/Winf,7x,6hP/Pinf,
>      .     7x,6hT/Tinf,8x,4hMACH,8x,6hpitotp,6x,9htur. vis.)
1348c1348
<    29    format(3i4,11(1x,e10.4))
---
>    29    format(3i4,11(1x,e12.5))
1380a1381
>          sgn = 1.
1385a1387
>          sgn = -1.
1417,1430d1418
< c     second cell center location - average in J and I
< c
<       q1k3 =       .25*(q(j,kd1,id,1)  +q(j-1,kd1,id,1)
<      .                + q(j,kd1,id1,1) +q(j-1,kd1,id1,1))
<       q2k3 =       .25*(q(j,kd1,id,2)  +q(j-1,kd1,id,2)
<      .                + q(j,kd1,id1,2) +q(j-1,kd1,id1,2))
<       q3k3 =       .25*(q(j,kd1,id,3)  +q(j-1,kd1,id,3)
<      .                + q(j,kd1,id1,3) +q(j-1,kd1,id1,3))
<       q4k3 =       .25*(q(j,kd1,id,4)  +q(j-1,kd1,id,4)
<      .                + q(j,kd1,id1,4) +q(j-1,kd1,id1,4))
<       q5k3 = gamma*.25*(q(j,kd1,id,5)  +q(j-1,kd1,id,5)
<      .                + q(j,kd1,id1,5) +q(j-1,kd1,id1,5))
<       t1k3 = q5k3/q1k3
< c
1446,1449d1433
<       QA1 = sqrt(q2k1**2+q3k1**2+q4k1**2)
<       QA2 = sqrt(q2k2**2+q3k2**2+q4k2**2)
<       QA3 = sqrt(q2k3**2+q3k3**2+q4k3**2)
< c     
1459,1462c1443,1457
< c     3-point average value formula
< c     Cf = 3.*(QA2-QA1) - 0.5*(QA3-QA2)
< c     2-point formula
<       Cf = 2.*(QA2-QA1)
---
> c     Use component of velocity parallel to wall (with 2-point formula)
>       urel = q2k2-q2k1
>       vrel = q3k2-q3k1
>       wrel = q4k2-q4k1
>       sk1  = (sk(j  ,kdx,id ,1)+sk(j-1,kdx,id ,1)+
>      +        sk(j  ,kdx,id1,1)+sk(j-1,kdx,id1,1))/4.
>       sk2  = (sk(j  ,kdx,id ,2)+sk(j-1,kdx,id ,2)+
>      +        sk(j  ,kdx,id1,2)+sk(j-1,kdx,id1,2))/4.
>       sk3  = (sk(j  ,kdx,id ,3)+sk(j-1,kdx,id ,3)+
>      +        sk(j  ,kdx,id1,3)+sk(j-1,kdx,id1,3))/4.
>       vnorm = (urel*sk1 + vrel*sk2 + wrel*sk3)*sgn
>       upar = urel-vnorm*sk1*sgn
>       vpar = vrel-vnorm*sk2*sgn
>       wpar = wrel-vnorm*sk3*sgn
>       Cf   = 2.*sqrt(upar**2 + vpar**2 + wpar**2)
1464a1460,1463
> c     Cf vector
>       cfx  = 4.*(emuka+avgmut)/(reue*xmach)*upar/dn
>       cfy  = 4.*(emuka+avgmut)/(reue*xmach)*vpar/dn
>       cfz  = 4.*(emuka+avgmut)/(reue*xmach)*wpar/dn
1474,1475d1472
< c        3-point average value formula
< c           Ch = 3.*(t1k2-t1k1)-0.5*(t1k3-t1k2)
1500a1498,1500
>       xw(jw,kw,iw,6) = cfx
>       xw(jw,kw,iw,7) = cfy
>       xw(jw,kw,iw,8) = cfz
1515c1515
<       nnq = jw*kw*iw*5
---
>       nnq = jw*kw*iw*8
1558c1558,1559
<      .   2hdn,9x,6hP/Pinf,7x,6hT/Tinf,9x,2hCf,11x,2hCh,9x,5hyplus)
---
>      .   2hdn,9x,6hP/Pinf,7x,6hT/Tinf,9x,2hCf,11x,2hCh,9x,5hyplus,
>      .   9x,3hCfx,9x,3hCfy,9x,3hCfz)
1564c1565,1566
<      .                  xw(jw,kw,iw,5)
---
>      .                  xw(jw,kw,iw,5),xw(jw,kw,iw,6),
>      .                  xw(jw,kw,iw,7),xw(jw,kw,iw,8)
1566a1569
>            xw(jw,kw,iw,7) = -xw(jw,kw,iw,7)
1571c1574,1575
<      .                  xw(jw,kw,iw,5)
---
>      .                  xw(jw,kw,iw,5),xw(jw,kw,iw,6),
>      .                  xw(jw,kw,iw,8),xw(jw,kw,iw,7)
1608a1613
>          sgn = 1.
1613a1619
>          sgn = -1.
1645,1658d1650
< c     second cell center location - average in K and I
< c
<       q1j3 =       .25*(q(jd1,k,id,1)  +q(jd1,k-1,id,1)
<      .                + q(jd1,k,id1,1) +q(jd1,k-1,id1,1))
<       q2j3 =       .25*(q(jd1,k,id,2)  +q(jd1,k-1,id,2)
<      .                + q(jd1,k,id1,2) +q(jd1,k-1,id1,2))
<       q3j3 =       .25*(q(jd1,k,id,3)  +q(jd1,k-1,id,3)
<      .                + q(jd1,k,id1,3) +q(jd1,k-1,id1,3))
<       q4j3 =       .25*(q(jd1,k,id,4)  +q(jd1,k-1,id,4)
<      .                + q(jd1,k,id1,4) +q(jd1,k-1,id1,4))
<       q5j3 = gamma*.25*(q(jd1,k,id,5)  +q(jd1,k-1,id,5)
<      .                + q(jd1,k,id1,5) +q(jd1,k-1,id1,5))
<       t1j3 = q5j3/q1j3
< c
1674,1677d1665
<       QA1 = sqrt(q2j1**2+q3j1**2+q4j1**2)
<       QA2 = sqrt(q2j2**2+q3j2**2+q4j2**2)
<       QA3 = sqrt(q2j3**2+q3j3**2+q4j3**2)
< c
1687,1690c1675,1689
< c     3-point average value formula
< c     Cf = 3.*(QA2-QA1) - 0.5*(QA3-QA2)
< c     2-point formula
<       Cf = 2.*(QA2-QA1)
---
> c     Use component of velocity parallel to wall
>       urel = q2j2-q2j1
>       vrel = q3j2-q3j1
>       wrel = q4j2-q4j1
>       sj1  = (sj(jdx,k  ,id ,1)+sj(jdx,k-1,id ,1)+
>      +        sj(jdx,k  ,id1,1)+sj(jdx,k-1,id1,1))/4.
>       sj2  = (sj(jdx,k  ,id ,2)+sj(jdx,k-1,id ,2)+
>      +        sj(jdx,k  ,id1,2)+sj(jdx,k-1,id1,2))/4.
>       sj3  = (sj(jdx,k  ,id ,3)+sj(jdx,k-1,id ,3)+
>      +        sj(jdx,k  ,id1,3)+sj(jdx,k-1,id1,3))/4.
>       vnorm = (urel*sj1 + vrel*sj2 + wrel*sj3)*sgn
>       upar = urel-vnorm*sj1*sgn
>       vpar = vrel-vnorm*sj2*sgn
>       wpar = wrel-vnorm*sj3*sgn
>       Cf   = 2.*sqrt(upar**2 + vpar**2 + wpar**2)
1692a1692,1695
> c     Cf vector
>       cfx  = 4.*(emuka+avgmut)/(reue*xmach)*upar/dn
>       cfy  = 4.*(emuka+avgmut)/(reue*xmach)*vpar/dn
>       cfz  = 4.*(emuka+avgmut)/(reue*xmach)*wpar/dn
1702,1703d1704
< c        3-point average value formula
< c           Ch = 3.*(t1j2-t1j1)-0.5*(t1j3-t1j2)
1728a1730,1732
>       xw(jw,kw,iw,6) = cfx
>       xw(jw,kw,iw,7) = cfy
>       xw(jw,kw,iw,8) = cfz
1743c1747
<       nnq = jw*kw*iw*5
---
>       nnq = jw*kw*iw*8
1789c1793,1794
<      .                  xw(jw,kw,iw,5)
---
>      .                  xw(jw,kw,iw,5),xw(jw,kw,iw,6),
>      .                  xw(jw,kw,iw,7),xw(jw,kw,iw,8)
1791a1797
>             xw(jw,kw,iw,7) = -xw(jw,kw,iw,7)
1796c1802,1803
<      .                  xw(jw,kw,iw,5)
---
>      .                  xw(jw,kw,iw,5),xw(jw,kw,iw,6),
>      .                  xw(jw,kw,iw,8),xw(jw,kw,iw,7)
1831a1839
>          sgn = 1.
1836a1845
>          sgn = -1.
1868,1881d1876
< c      second cell center location - average in J and K
< c
<       q1i3 =       .25*(q(j,k,id1,1)   +q(j,k-1,id1,1)
<      .                + q(j-1,k,id1,1) +q(j-1,k-1,id1,1))
<       q2i3 =       .25*(q(j,k,id1,2)   +q(j,k-1,id1,2)
<      .                + q(j-1,k,id1,2) +q(j-1,k-1,id1,2))
<       q3i3 =       .25*(q(j,k,id1,3)   +q(j,k-1,id1,3)
<      .                + q(j-1,k,id1,3) +q(j-1,k-1,id1,3))
<       q4i3 =       .25*(q(j,k,id1,4)   +q(j,k-1,id1,4)
<      .                + q(j-1,k,id1,4) +q(j-1,k-1,id1,4))
<       q5i3 = gamma*.25*(q(j,k,id1,5)   +q(j,k-1,id1,5)
<      .                + q(j-1,k,id1,5) +q(j-1,k-1,id1,5))
<       t1i3 = q5i3/q1i3
< c
1897,1900d1891
<       QA1 = sqrt(q2i1**2+q3i1**2+q4i1**2)
<       QA2 = sqrt(q2i2**2+q3i2**2+q4i2**2)
<       QA3 = sqrt(q2i3**2+q3i3**2+q4i3**2)
< c
1910,1913c1901,1915
< c     3-point average value formula
< c     Cf = 3.*(QA2-QA1) - 0.5*(QA3-QA2)
< c     2-point formula
<       Cf = 2.*(QA2-QA1)
---
> c     Use component of velocity parallel to wall
>       urel = q2i2-q2i1
>       vrel = q3i2-q3i1
>       wrel = q4i2-q4i1
>       si1  = (si(j  ,k  ,idx,1)+si(j  ,k-1,idx,1)+
>      +        si(j-1,k  ,idx,1)+si(j-1,k-1,idx,1))/4.
>       si2  = (si(j  ,k  ,idx,2)+si(j  ,k-1,idx,2)+
>      +        si(j-1,k  ,idx,2)+si(j-1,k-1,idx,2))/4.
>       si3  = (si(j  ,k  ,idx,3)+si(j  ,k-1,idx,3)+
>      +        si(j-1,k  ,idx,3)+si(j-1,k-1,idx,3))/4.
>       vnorm = (urel*si1 + vrel*si2 + wrel*si3)*sgn
>       upar = urel-vnorm*si1*sgn
>       vpar = vrel-vnorm*si2*sgn
>       wpar = wrel-vnorm*si3*sgn
>       Cf   = 2.*sqrt(upar**2 + vpar**2 + wpar**2)
1915a1918,1921
> c     Cf vector
>       cfx  = 4.*(emuka+avgmut)/(reue*xmach)*upar/dn
>       cfy  = 4.*(emuka+avgmut)/(reue*xmach)*vpar/dn
>       cfz  = 4.*(emuka+avgmut)/(reue*xmach)*wpar/dn
1925,1926d1930
< c        3-point average value formula
< c           Ch = 3.*(t1i2-t1i1)-0.5*(t1i3-t1i2)
1951a1956,1958
>       xw(jw,kw,iw,6) = cfx
>       xw(jw,kw,iw,7) = cfy
>       xw(jw,kw,iw,8) = cfz
1965c1972
<       nnq = jw*kw*iw*5
---
>       nnq = jw*kw*iw*8
2013c2020,2021
<      .                  xw(jw,kw,iw,5)
---
>      .                  xw(jw,kw,iw,5),xw(jw,kw,iw,6),
>      .                  xw(jw,kw,iw,7),xw(jw,kw,iw,8)
2015a2024
>             xw(jw,kw,iw,7) = -xw(jw,kw,iw,7)
2020c2029,2030
<      .                  xw(jw,kw,iw,5)
---
>      .                  xw(jw,kw,iw,5),xw(jw,kw,iw,6),
>      .                  xw(jw,kw,iw,8),xw(jw,kw,iw,7)
2029c2039
<    22 format(3i4,9(1x,e12.5))
---
>    22 format(3i4,12(1x,e12.5))
Index: source/cfl3d/dist/plot3t.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/plot3t.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
12c12
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
91a92,93
>       common /turbconv/ cflturb,edvislim,iturbprod,nsubturb,nfreeze,
>      .                  iwarneddy,itime2read,itaturb,tur1cut
605,608c607,612
< c   less-than-two equation models use approximation for k (from AIAA 92-0439)
<                  t11=t11+vist3d(j,k,i)*sqrt(2.*xis)/(3.*.31)
<                  t22=t22+vist3d(j,k,i)*sqrt(2.*xis)/(3.*.31)
<                  t33=t33+vist3d(j,k,i)*sqrt(2.*xis)/(3.*.31)
---
> c   less-than-two equation models use approximation for 2/3*k 
> c   (from AIAA 92-0439, where structure parameter taken as a1=0.5*(0.31))
> c   approx for k/aref^2 is:  vist3d(j,k,i)/q(j,k,i,1)*sqrt(2.*xis)/(re*.31)
>                t11=t11+2./3.*vist3d(j,k,i)/q(j,k,i,1)*sqrt(2.*xis)/.31
>                t22=t22+2./3.*vist3d(j,k,i)/q(j,k,i,1)*sqrt(2.*xis)/.31
>                t33=t33+2./3.*vist3d(j,k,i)/q(j,k,i,1)*sqrt(2.*xis)/.31
817c821,824
< c            Calculate production term:
---
> c            Calculate production term (approx form if iturbprod=0):
>             if (iturbprod .eq. 0) then
>             pk=2.*vist3d(j,k,i)*xis/(q(j,k,i,1)*re)
>             else
822a830
>             end if
Index: source/cfl3d/dist/pointers.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/pointers.F,v
retrieving revision 1.2
retrieving revision 1.6
diff -r1.2 -r1.6
12c12
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
55a56
>       common /avgdata/ xnumavg,iteravg
130,147c131,149
< c      46  ux
< c      47  cmuv
< c      48  volj0
< c      49  volk0
< c      50  voli0
< c      51  xmdj
< c      52  xmdk
< c      53  xmdi
< c      54  velg
< c      55  xnm2
< c      56  ynm2
< c      57  znm2
< c      58  deltj
< c      59  deltk
< c      60  delti
< c      61  xnm1
< c      62  ynm1
< c      63  znm1
---
> c      46  qavg
> c      47  ux
> c      48  cmuv
> c      49  volj0
> c      50  volk0
> c      51  voli0
> c      52  xmdj
> c      53  xmdk
> c      54  xmdi
> c      55  velg
> c      56  xnm2
> c      57  ynm2
> c      58  znm2
> c      59  deltj
> c      60  deltk
> c      61  delti
> c      62  xnm1
> c      63  ynm1
> c      64  znm1
358c360
< c        grid point x coordinate
---
> c        grid point y coordinate
688c690
< c........xib2(jdim,kdim,idim,2)
---
> c........xib2(jdim,kdim,idim,4)
694c696,702
<      .      .and. real(dt) .gt. 0.) ns=jmkmim*2
---
>      .      .and. real(dt) .gt. 0.) ns=jmkmim*4
> c
> c........qavg(jdim-1,kdim-1,idim-1,5) iteration-averaged data
> c
>          lw(46,nbl) = lw(45,nbl) + ns
>          ns = 0
>          if (iteravg.eq.1 .or. iteravg.eq.2) ns = jm1km1im1*5
699c707
<          lw(46,nbl) = lw(45,nbl) + ns
---
>          lw(47,nbl) = lw(46,nbl) + ns
709c717
<          lw(47,nbl) = lw(46,nbl) + ns
---
>          lw(48,nbl) = lw(47,nbl) + ns
720c728
<          lw(48,nbl) = lw(47,nbl) + ns
---
>          lw(49,nbl) = lw(48,nbl) + ns
728c736
<          lw(49,nbl) = lw(48,nbl) + ns
---
>          lw(50,nbl) = lw(49,nbl) + ns
736c744
<          lw(50,nbl) = lw(49,nbl) + ns
---
>          lw(51,nbl) = lw(50,nbl) + ns
742c750
<          lw(51,nbl) = lw(50,nbl) + ns
---
>          lw(52,nbl) = lw(51,nbl) + ns
748c756
<          lw(52,nbl) = lw(51,nbl) + ns
---
>          lw(53,nbl) = lw(52,nbl) + ns
754c762
<          lw(53,nbl) = lw(52,nbl) + ns
---
>          lw(54,nbl) = lw(53,nbl) + ns
762c770
<          lw(54,nbl) = lw(53,nbl) + ns
---
>          lw(55,nbl) = lw(54,nbl) + ns
768c776
<          lw(55,nbl) = lw(54,nbl) + ns
---
>          lw(56,nbl) = lw(55,nbl) + ns
775c783
<          lw(56,nbl) = lw(55,nbl) + ns
---
>          lw(57,nbl) = lw(56,nbl) + ns
782c790
<          lw(57,nbl) = lw(56,nbl) + ns
---
>          lw(58,nbl) = lw(57,nbl) + ns
788c796
<          lw(58,nbl) = lw(57,nbl) + ns
---
>          lw(59,nbl) = lw(58,nbl) + ns
794c802
<          lw(59,nbl) = lw(58,nbl) + ns
---
>          lw(60,nbl) = lw(59,nbl) + ns
800c808
<          lw(60,nbl) = lw(59,nbl) + ns
---
>          lw(61,nbl) = lw(60,nbl) + ns
806c814
<          lw(61,nbl) = lw(60,nbl) + ns
---
>          lw(62,nbl) = lw(61,nbl) + ns
812c820
<          lw(62,nbl) = lw(61,nbl) + ns
---
>          lw(63,nbl) = lw(62,nbl) + ns
818c826
<          lw(63,nbl) = lw(62,nbl) + ns
---
>          lw(64,nbl) = lw(63,nbl) + ns
822c830
<          nstart = lw(63,nbl) + ns
---
>          nstart = lw(64,nbl) + ns
834c842
<          memblock(nbl) = lw(63,nbl) + ns - lw(1,nbl) + 1
---
>          memblock(nbl) = lw(64,nbl) + ns - lw(1,nbl) + 1
841c849
<          do ii = 1,63
---
>          do ii = 1,64
850c858
<          nstart = lw(63,nbl)
---
>          nstart = lw(64,nbl)
Index: source/cfl3d/dist/qinter.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/qinter.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
9c9
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
62c62
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
161,166c161,166
<                lxnm2c  = lw(55,nblz)
<                lynm2c  = lw(56,nblz)
<                lznm2c  = lw(57,nblz)
<                ldeltjc = lw(58,nblz) 
<                ldeltkc = lw(59,nblz)
<                ldeltic = lw(60,nblz)
---
>                lxnm2c  = lw(56,nblz)
>                lynm2c  = lw(57,nblz)
>                lznm2c  = lw(58,nblz)
>                ldeltjc = lw(59,nblz) 
>                ldeltkc = lw(60,nblz)
>                ldeltic = lw(61,nblz)
Index: source/cfl3d/dist/qout.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/qout.F,v
retrieving revision 1.4
retrieving revision 1.6
diff -r1.4 -r1.6
20c20
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
91c91
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
511c511,512
<             ibwk = ixwk + jdw*kdw*idw*5
---
>             nset = 5
>             ibwk = ixwk + jdw*kdw*idw*nset
534c535
<      .                     w(lsj),w(lsk),w(lsi),w(lvol))
---
>      .                     w(lsj),w(lsk),w(lsi),w(lvol),nset)
778c779,780
<             ibwk = ixwk + jdw*kdw*idw*5
---
>             nset = 8
>             ibwk = ixwk + jdw*kdw*idw*nset
787c789
<                   write(11,'('' not writing out plot3d files'')')
---
>                   write(11,'('' not writing out prout file'')')
801c803
<      .                     w(lsj),w(lsk),w(lsi),w(lvol))
---
>      .                     w(lsj),w(lsk),w(lsi),w(lvol),nset)
Index: source/cfl3d/dist/resetg.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/resetg.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
14c14
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
67c67
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/dist/resp.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/resp.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
24c24
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
229,230c229,230
<          if (iviscg(nbl,1).gt.2 .or. iviscg(nbl,2).gt.2
<      .      .or. iviscg(nbl,3).gt.2 .and. iadvance(nbl).ge.0) then
---
>          if ((iviscg(nbl,1).gt.2 .or. iviscg(nbl,2).gt.2
>      .      .or. iviscg(nbl,3).gt.2) .and. iadvance(nbl).ge.0) then
792,793c792,793
<             if (iviscg(nbl1,3).gt.1 .or. iviscg(nbl1,2).gt.1
<      .         .or.iviscg(nbl1,1).gt.1) then
---
>             if ((iviscg(nbl1,3).gt.1 .or. iviscg(nbl1,2).gt.1
>      .         .or.iviscg(nbl1,1).gt.1) .and. iadvance(nbl).ge.0) then
862,863c862,863
<          if (iviscg(nbl,1).gt.2 .or. iviscg(nbl,2).gt.2 .or.
<      .       iviscg(nbl,3).gt.2 .and. iadvance(nbl).ge.0) then
---
>          if ((iviscg(nbl,1).gt.2 .or. iviscg(nbl,2).gt.2 .or.
>      .       iviscg(nbl,3).gt.2) .and. iadvance(nbl).ge.0) then
1244c1244
< #ifdef CRAY_TIME then
---
> #ifdef CRAY_TIME
1246c1246
< #   ifdef IBM then
---
> #   ifdef IBM
Index: source/cfl3d/dist/rrest.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/rrest.F,v
retrieving revision 1.4
retrieving revision 1.8
diff -r1.4 -r1.8
6,7d5
< c   ***CGNSstart
< c    .                 myid,myhost,mycomm,nou,bou,nbuf,ibufdim)
10,11c8
<      .                 tj0,tk0,ti0)
< c   ***CGNSend
---
>      .                 tj0,tk0,ti0,qavg)
13c10
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
63c60
< c   ***CGNSstart
---
>       dimension qavg(jdim-1,kdim-1,idim-1,5)
66d62
< c   ***CGNSend
68c64
< c   ***CGNSstart
---
>       common /avgdata/ xnumavg,iteravg
71d66
< c   ***CGNSend
87a83
>       common /igrdtyp/ ip3dgrd,ialph
141a138,139
>       itag_qavg    = itag_ti0     + ioffset
>       itag_xnum    = itag_qavg    + ioffset
145a144
>       jkim5 = 5*jkim
160d158
< c   ***CGNSstart
163c161,165
<       write(11,'('' CGNS read in rrest'')')
---
>       write(11,'('' cgns read in rrest'')')
>       write(11,'(''  ...reading conserved variables and'',
>      +  '' translating to primitive'')')
>       write(11,'(''  (this may result in machine-order differences'',
>      +  '' compared to a non-cgns run)'')')
174c176
<      +  jdim,kdim,wk,nsoluse,irind,jrind,krind,i2d,q,iprim)
---
>      +  jdim,kdim,wk,nsoluse,irind,jrind,krind,i2d,ialph,q,iprim)
190c192
<         write(11,'('' CGNS reading specific BC values'')')
---
>         write(11,'('' cgns reading specific BC values'')')
193,222d194
<       if (iprim .eq. 0) then
< c     convert qj0, qk0, qi0 to primitive (they are in CGNS file as conserved)
<       do m=1,4
<       do i=1,idim1
<         do k=1,kdim1
<           qj0(k,i,2,m)=qj0(k,i,2,m)/qj0(k,i,1,m)
<           qj0(k,i,3,m)=qj0(k,i,3,m)/qj0(k,i,1,m)
<           qj0(k,i,4,m)=qj0(k,i,4,m)/qj0(k,i,1,m)
<           qj0(k,i,5,m)=gm1*(qj0(k,i,5,m)-0.5*qj0(k,i,1,m)*
<      +      (qj0(k,i,2,m)**2+qj0(k,i,3,m)**2+qj0(k,i,4,m)**2))
<         enddo
<         do j=1,jdim1
<           qk0(j,i,2,m)=qk0(j,i,2,m)/qk0(j,i,1,m)
<           qk0(j,i,3,m)=qk0(j,i,3,m)/qk0(j,i,1,m)
<           qk0(j,i,4,m)=qk0(j,i,4,m)/qk0(j,i,1,m)
<           qk0(j,i,5,m)=gm1*(qk0(j,i,5,m)-0.5*qk0(j,i,1,m)*
<      +      (qk0(j,i,2,m)**2+qk0(j,i,3,m)**2+qk0(j,i,4,m)**2))
<         enddo
<       enddo
<       do k=1,kdim1
<         do j=1,jdim1
<           qi0(j,k,2,m)=qi0(j,k,2,m)/qi0(j,k,1,m)
<           qi0(j,k,3,m)=qi0(j,k,3,m)/qi0(j,k,1,m)
<           qi0(j,k,4,m)=qi0(j,k,4,m)/qi0(j,k,1,m)
<           qi0(j,k,5,m)=gm1*(qi0(j,k,5,m)-0.5*qi0(j,k,1,m)*
<      +      (qi0(j,k,2,m)**2+qi0(j,k,3,m)**2+qi0(j,k,4,m)**2))
<         enddo
<       enddo
<       enddo
<       end if
254d225
< c   ***CGNSend
264d234
< c   ***CGNSstart
266d235
< c   ***CGNSend
282d250
< c   ***CGNSstart
284d251
< c   ***CGNSend
326d292
< c   ***CGNSstart
328d293
< c   ***CGNSend
510d474
< c   ***CGNSstart
512d475
< c   ***CGNSend
518d480
< c   ***CGNSstart
520d481
< c   ***CGNSend
688d648
< c   ***CGNSstart
715d674
< c   ***CGNSend
717d675
< c   ***CGNSstart
719d676
< c   ***CGNSend
773d729
< c   ***CGNSstart
775d730
< c   ***CGNSend
778d732
< c   ***CGNSstart
780d733
< c   ***CGNSend
788d740
< c   ***CGNSstart
790d741
< c   ***CGNSend
793d743
< c   ***CGNSstart
795d744
< c   ***CGNSend
845d793
< c   ***CGNSstart
854d801
< c   ***CGNSend
872d818
< c   ***CGNSstart
874d819
< c   ***CGNSend
880d824
< c   ***CGNSstart
882d825
< c   ***CGNSend
892d834
< c   ***CGNSstart
894d835
< c   ***CGNSend
902d842
< c   ***CGNSstart
904d843
< c   ***CGNSend
922d860
< c   ***CGNSstart
924d861
< c   ***CGNSend
928d864
< c   ***CGNSstart
930d865
< c   ***CGNSend
942d876
< c   ***CGNSstart
944d877
< c   ***CGNSend
946d878
< c   ***CGNSstart
948d879
< c   ***CGNSend
975d905
< c   ***CGNSstart
977d906
< c   ***CGNSend
983d911
< c   ***CGNSstart
985d912
< c   ***CGNSend
1041d967
< c   ***CGNSstart
1043d968
< c   ***CGNSend
1050d974
< c   ***CGNSstart
1052d975
< c   ***CGNSend
1193d1115
< c   ***CGNSstart
1195d1116
< c   ***CGNSend
1197d1117
< c   ***CGNSstart
1199d1118
< c   ***CGNSend
1217d1135
< c   ***CGNSstart
1219d1136
< c   ***CGNSend
1223d1139
< c   ***CGNSstart
1225d1140
< c   ***CGNSend
1262d1176
< c   ***CGNSstart
1264d1177
< c   ***CGNSend
1271d1183
< c   ***CGNSstart
1273d1184
< c   ***CGNSend
1301a1213,1257
>       end if
>       if (iteravg .eq. 2) then
>         if (myid.eq.myhost) then
>         read(97,end=1010,err=1010) dum,dum,dum,xnumavg
>         read(97,end=1010,err=1010) ((((qavg(j,k,i,m),
>      +    i=1,idim-1),j=1,jdim-1),k=1,kdim-1),m=1,5)
> c   need to switch y and z if ialph .ne. 0
>         if (ialph .ne. 0) then
>           do i=1,idim-1
>             do j=1,jdim-1
>               do k=1,kdim-1
>                 temp=qavg(j,k,i,4)
>                 qavg(j,k,i,4)=qavg(j,k,i,3)
>                 qavg(j,k,i,3)=-temp
>               enddo
>             enddo
>           enddo
>         end if
>         end if
> #if defined DIST_MPI
> c
>           mytag = itag_qavg + nbl
>           if (myid .eq. myhost) then
>              call MPI_Send(qavg,jkim5,MY_MPI_REAL,
>      .                    nd_dest,mytag,mycomm,ierr)
>           else if (myid .eq. mblk2nd(nbl)) then
>              call MPI_Recv(qavg,jkim5,MY_MPI_REAL,
>      .                     myhost,mytag,mycomm,istat,ierr)
>           end if
>           mytag = itag_xnum + nbl
>           if (myid .eq. myhost) then
>              call MPI_Send(xnumavg,1,MY_MPI_REAL,
>      .                    nd_dest,mytag,mycomm,ierr)
>           else if (myid .eq. mblk2nd(nbl)) then
>              call MPI_Recv(xnumavg,1,MY_MPI_REAL,
>      .                     myhost,mytag,mycomm,istat,ierr)
>           end if
> #endif
>         return
>  1010   continue
>         write(11,'(/,'' stopping... flag iteravg=2, but cannot read'',
>      +   '' running-average Q file, nbl='',i5)') nbl
>         write(11,'('' ... it either does not exist or it is an'',
>      +   '' incorrect file'')')
>         call termn8(myid,-1,ibufdim,nbuf,bou,nou)
Index: source/cfl3d/dist/rrestg.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/rrestg.F,v
retrieving revision 1.2
retrieving revision 1.8
diff -r1.2 -r1.8
15,18c15,16
< c   ***CGNSstart
< c    .                  iaesurf,maxsegdg,wk,nwork)
<      .                  iaesurf,maxsegdg,wk,nwork,idima,jdima,kdima)
< c   ***CGNSend
---
>      .                  iaesurf,maxsegdg,wk,nwork,idima,jdima,kdima,
>      .                  tursav2)
20c18
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
67c65
<       dimension qc0(jdim,kdim,idim-1,5)
---
>       dimension qc0(jdim,kdim,idim-1,5),tursav2(jdim,kdim,idim,4)
97a96
>       common /cfl/ dt0,dtold
111c110
< c   ***CGNSstart
---
>       common /igrdtyp/ ip3dgrd,ialph
114c113,114
< c   ***CGNSend
---
>       common /turbconv/ cflturb,edvislim,iturbprod,nsubturb,nfreeze,
>      .                  iwarneddy,itime2read,itaturb,tur1cut
123c123,124
<       itag_dmdat = itag_qc0   + ioffset
---
>       itag_tursav= itag_qc0   + ioffset
>       itag_dmdat = itag_tursav+ ioffset
132a134
>       itag_dtold = itag_delti + ioffset
146d147
< c   ***CGNSstart
148d148
< c   ***CGNSend
165c165,172
< c   ***CGNSstart
---
> c     itime2read=1=default=YES, read 2nd order time-accurate turb info
> c     itime2read=0=NO, do not read (for use with older CFL3D 2nd-order
> c                  time-accurate restart files, which was missing this info)
>          if (itime2read .ne. 0) then
>          read(2) dtold
>          read(2) ((((tursav2(j,k,i,l),j=1,jdim1),k=1,kdim1),i=1,idim1),
>      .               l=1,2)
>          end if
168c175
<          write(11,'('' reading 2nd order time data from CGNS'',
---
>          write(11,'('' reading 2nd order time data from cgns'',
171c178,179
<      +     jdim,kdim,wk,nsoluse,irind,jrind,krind,i2d,qc0)
---
>      +     jdim,kdim,wk,nsoluse,irind,jrind,krind,i2d,dt,
>      +     ialph,qc0,tursav2,dtold)
174c182,187
< c   ***CGNSend
---
>       if (dtold .ne. dt) then
>         write(11,'('' time step has changed: old='',f12.6,
>      .   '', new='',f12.6)') dtold,dt
>         write(11,'('' ...1st step will be forced to be 1st order'',
>      .   '' in time (to maintain order property)'')')
>       end if
190a204,222
> c        fill in edge values of tursav2 array for safety before passing
> c        the data to the appropriate node
> c
>          do i=1,idim
>             k = kdim
>             do j=1,jdim1
>                tursav2(j,k,i,1) = tur10
>                tursav2(j,k,i,2) = tur20
>                tursav2(j,k,i,3) = 0.
>                tursav2(j,k,i,4) = 0.
>             end do
>             j=jdim
>             do k=1,kdim
>                tursav2(j,k,i,1) = tur10
>                tursav2(j,k,i,2) = tur20
>                tursav2(j,k,i,3) = 0.
>                tursav2(j,k,i,4) = 0.
>             end do
>          end do
205a238,255
>       jki4 = jdim*kdim*idim*4
>       mytag = itag_tursav + nbl
>       if (myid .eq. myhost) then
>          call MPI_Send(tursav2,jki4,MY_MPI_REAL,
>      .                 nd_dest,mytag,mycomm,ierr)
>       else if (myid .eq. mblk2nd(nbl)) then
>          call MPI_Recv(tursav2,jki4,MY_MPI_REAL,
>      .                 myhost,mytag,mycomm,istat,ierr)
>       end if
>       mytag = itag_dtold + nbl
>       nvals=1
>       if (myid .eq. myhost) then
>          call MPI_Send(dtold,nvals,MY_MPI_REAL,
>      .                 nd_dest,mytag,mycomm,ierr)
>       else if (myid .eq. mblk2nd(nbl)) then
>          call MPI_Recv(dtold,nvals,MY_MPI_REAL,
>      .                 myhost,mytag,mycomm,istat,ierr)
>       end if
218d267
< c   ***CGNSstart
220d268
< c   ***CGNSend
222d269
< c   ***CGNSstart
228d274
< c   ***CGNSend
247d292
< c   ***CGNSstart
249d293
< c   ***CGNSend
264d307
< c   ***CGNSstart
266d308
< c   ***CGNSend
310d351
< c   ***CGNSstart
312d352
< c   ***CGNSend
324d363
< c   ***CGNSstart
329c368
<             call rgrdmov(iccg,ibase,igrid,
---
>             call rgrdmov(iccg,ibase,igrid,ialph,
342d380
< c   ***CGNSend
511d548
< c   ***CGNSstart
513d549
< c   ***CGNSend
541d576
< c   ***CGNSstart
545c580
<      .             '' CGNS file'')')
---
>      .             '' cgns file for block '',i4)') nbl
549c584,585
<      .            wk,jdim,kdim,idim,idefrm(nbl),utrnsae(nbl,1),
---
>      .            wk,jdima,kdima,idima,i2d,
>      .            jdim,kdim,idim,ialph,idefrm(nbl),utrnsae(nbl,1),
559c595,596
<      .            wk,jdim,kdim,idim,idefrm(nbl),utrnsae(nbl,1),
---
>      .            wk,jdima,kdima,idima,i2d,
>      .            jdim,kdim,idim,ialph,idefrm(nbl),utrnsae(nbl,1),
570d606
< c   ***CGNSend
Index: source/cfl3d/dist/setslave.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/setslave.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
10c10
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
62c62
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/dist/setup.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/setup.F,v
retrieving revision 1.2
retrieving revision 1.13
diff -r1.2 -r1.13
31c31
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
63c63
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
67d66
< c   ***CGNSstart
69d67
< c   ***CGNSend
135d132
< c   ***CGNSstart
137d133
< c   ***CGNSend
139c135,136
<      .                geom_img,surf_img
---
>      .                geom_img,surf_img,xrotrate_img,yrotrate_img,
>      .                zrotrate_img
147c144
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
161c158
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
168a166,168
>       common /noninertial/ xcentrot,ycentrot,zcentrot,xrotrate,
>      .                     yrotrate,zrotrate,noninflag
>       common /avgdata/ xnumavg,iteravg
171d170
< c   ***CGNSstart
174d172
< c   ***CGNSend
177d174
< c   ***CGNSstart
187d183
< c   ***CGNSend
194a191
>       xnumavg  = 0.
249d245
< c   ***CGNSstart
253c249
<         write(11,'('' inconsistency between CGNS # of zones & input.'',
---
>         write(11,'('' inconsistency between cgns # of zones & input.'',
258d253
< c   ***CGNSend
266d260
< c   ***CGNSstart
271c265
<           write(11,'('' not enough memory for CGNS grid read.'')')
---
>           write(11,'('' not enough memory for cgns grid read.'')')
282d275
< c   ***CGNSend
319a313
>             irr=0
321c315,321
<      .                igeom_img)
---
>      .                igeom_img,irr)
>             if (irr .ne. 0) then
>               write(11,*) ' Stopping... error reading grid...'
>               write(11,*) ' (Common error:  grid not written in same',
>      .        ' precision that CFL3D was compiled)'
>               call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>             end if
356a357
>             irr=0
358c359,365
<      .                igeom_img)
---
>      .                igeom_img,irr)
>             if (irr .ne. 0) then
>               write(11,*) ' Stopping... error reading grid...'
>               write(11,*) ' (Common error:  grid not written in same',
>      .        ' precision that CFL3D was compiled)'
>               call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>             end if
360d366
< c   ***CGNSstart
362d367
< c   ***CGNSend
491,493d495
< c              the following mpi call passes all the deltas in one
< c              message; requires contiguous storge of the deltas
< c
495d496
< c              nvals   = (jdim*kdim+jdim*idim+kdim*idim)*3*2
1473a1475,1481
> c        call the noninertial initization to speed convergence
>          if (noninflag.gt.0) then
>            call initnonin(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
>      .                    w(lqi0),w(ltj0),w(ltk0),w(lti0),w(lvol),
>      .                    w(lvolj0),w(lvolk0),w(lvoli0),
>      .                    w(lx),w(ly),w(lz))
>          end if
1485a1494,1499
>             if (noninflag.gt.0) then
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),201)
>   201          format(35h  correcting initial conditions for,
>      .                28h NONINERTIAL reference frame)
>             end if
1490a1505,1510
>             if (noninflag.gt.0) then
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),211)
>   211          format(37h    correcting initial conditions for,
>      .                28h NONINERTIAL reference frame)
>             end if
1494a1515,1521
> c        call the noninertial initization to speed convergence
>          if (noninflag.gt.0) then
>            call initnonin(nbl,jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),
>      .                    w(lqi0),w(ltj0),w(ltk0),w(lti0),w(lvol),
>      .                    w(lvolj0),w(lvolk0),w(lvoli0),
>      .                    w(lx),w(ly),w(lz))
>          endif
1605,1606c1632,1634
<                   nnn = jdim*kdim*idim*3
<                   mytag = 1
---
> c
>                   nnn = jdim*kdim*idim
>                   mytag = itag_x
1614a1643,1665
> c
>                   nnn = jdim*kdim*idim
>                   mytag = itag_y
>                   nd_srce = mblk2nd(nbl)
>                   if (myid.eq.mblk2nd(nbl)) then
>                      call MPI_Send (w(ly), nnn, MY_MPI_REAL,
>      .                              myhost, mytag, mycomm, ierr)
>                   else if (myid.eq.myhost) then
>                      call MPI_Recv (w(ly), nnn, MY_MPI_REAL,
>      .                              nd_srce, mytag, mycomm, istat, ierr)
>                   end if
> c
>                   nnn = jdim*kdim*idim
>                   mytag = itag_z
>                   nd_srce = mblk2nd(nbl)
>                   if (myid.eq.mblk2nd(nbl)) then
>                      call MPI_Send (w(lz), nnn, MY_MPI_REAL,
>      .                              myhost, mytag, mycomm, ierr)
>                   else if (myid.eq.myhost) then
>                      call MPI_Recv (w(lz), nnn, MY_MPI_REAL,
>      .                              nd_srce, mytag, mycomm, istat, ierr)
>                   end if
> c
1689,1691c1740,1742
<                         lxmdjc = lw(51,nbl)
<                         lxmdkc = lw(52,nbl)
<                         lxmdic = lw(53,nbl)
---
>                         lxmdjc = lw(52,nbl)
>                         lxmdkc = lw(53,nbl)
>                         lxmdic = lw(54,nbl)
1731a1783,1805
>          if (iteravg .eq. 2) then
>          if (myid .eq. myhost) then
>            read(97,end=1011,err=1011) ngx
>            if (ngx .ne. ngrid) goto 1011
>            read(97,end=1011,err=1011) (itest(igrid),jtest(igrid),
>      .       ktest(igrid),igrid=1,ngx)
>            do igrid=1,ngrid
>              if (itest(igrid) .ne. idimg(nblg(igrid)+mseq-1)-1 .or. 
>      .           jtest(igrid) .ne. jdimg(nblg(igrid)+mseq-1)-1 .or.
>      .           ktest(igrid) .ne. kdimg(nblg(igrid)+mseq-1)-1) 
>      .           goto 1011
>            enddo
>            goto 1012
>  1011      continue
>            write(11,'(/,'' stopping... flag iteravg=2, but cannot'',
>      .      '' read running-average Q file'')')
>            write(11,'('' ... it either does not exist or it is an'',
>      .      '' incorrect file'')')
>            call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>  1012      continue
>          end if
>          end if
> c
1740d1813
< c   ***CGNSstart
1747d1819
< c   ***CGNSend
1755c1827,1839
< c   ***CGNSstart
---
> c
>             if (iteravg .eq. 1) then
>               nou(1) = min(nou(1)+1,ibufdim)
>               write(bou(nou(1),1),811) nbl
>   811         format(35h running-average to be started from,
>      .          18h scratch for block,i4)
>             end if
>             if (iteravg .eq. 2) then
>               nou(1) = min(nou(1)+1,ibufdim)
>               write(bou(nou(1),1),812) nbl
>   812         format(39h reading running-average file for block,i4)
>             end if
> c
1760c1844
<      .             '' CGNS Q read.'')')
---
>      .             '' cgns Q read.'')')
1771d1854
< c   ***CGNSend
1780,1781d1862
< c   ***CGNSstart
< c    .                 nou,bou,nbuf,ibufdim)
1784,1785c1865
<      .                 w(ltj0),w(ltk0),w(lti0))
< c   ***CGNSend
---
>      .                 w(ltj0),w(ltk0),w(lti0),w(lqavg))
1820,1826c1900,1903
<             iflagg = 0
< c   ***CGNSstart
<       if (icgns .ne. 1) then
< c   ***CGNSend
<             read(2,end=8988) iflagg
< c   ***CGNSstart
<       else
---
>            iflagg = 0
>            if (icgns .ne. 1) then
>              read(2,end=8988) iflagg
>            else
1828,1830c1905,1907
<       if (irest.gt.0) then
<       call getiflagg(iccg,ibase,nsoluse,iflagg)
<       end if
---
>              if (irest.gt.0) then
>                call getiflagg(iccg,ibase,nsoluse,iflagg)
>              end if
1832,1834c1909,1910
<       end if
< c   ***CGNSend
<  8988       continue
---
>            end if
>  8988      continue
1836c1912
< c           set iflagg = 0 if steady state (dt < 0)
---
> c          set iflagg = 0 if steady state (dt < 0)
1838c1914
<             if (real(dt) .lt. 0.) iflagg = 0
---
>            if (real(dt) .lt. 0.) iflagg = 0
1847,1852c1923,1926
< c   ***CGNSstart
<       if (icgns .ne. 1) then
< c   ***CGNSend
<          read(2,end=8989) iflagg
< c   ***CGNSstart
<       else
---
>          iflagg=0
>          if (icgns .ne. 1) then
>            read(2,end=8989) iflagg
>          else
1854,1856c1928,1930
<       if (irest.gt.0) then
<       call getiflagg(iccg,ibase,nsoluse,iflagg)
<       end if
---
>            if (irest.gt.0) then
>              call getiflagg(iccg,ibase,nsoluse,iflagg)
>            end if
1858,1859c1932
<       end if
< c   ***CGNSend
---
>          end if
1863a1937
>          if (iflagg .eq. 0) go to 8989
1878d1951
< c   ***CGNSstart
1885d1957
< c   ***CGNSend
1889d1960
< c   ***CGNSstart
1892c1963
<              write(11,'('' not enough memory for CGNS '',
---
>              write(11,'('' not enough memory for cgns '',
1903d1973
< c   ***CGNSend
1919,1922c1989,1990
< c   ***CGNSstart
< c    .              iaesurf,maxsegdg,wk,nwork)
<      .              iaesurf,maxsegdg,wk,nwork,idima,jdima,kdima)
< c   ***CGNSend
---
>      .              iaesurf,maxsegdg,wk,nwork,idima,jdima,kdima,
>      .              w(lxib2))
1931a2000
>                   nou(1) = min(nou(1)+1,ibufdim)
1933a2003
>                   nou(1) = min(nou(1)+1,ibufdim)
1961d2030
< c   ***CGNSstart
1968d2036
< c   ***CGNSend
1971d2038
< c   ***CGNSstart
1974c2041
<              write(11,'('' not enough memory for CGNS '',
---
>              write(11,'('' not enough memory for cgns '',
1985d2051
< c   ***CGNSend
2003,2006c2069,2070
< c   ***CGNSstart
< c    .                 iaesurf,maxsegdg,wk,nwork)
<      .                 iaesurf,maxsegdg,wk,nwork,idima,jdima,kdima)
< c   ***CGNSend
---
>      .                 iaesurf,maxsegdg,wk,nwork,idima,jdima,kdima,
>      .                 w(lxib2))
2063c2127
<                  write(bou(nou(1),1),'(''           qc0 data saved'',
---
>                  write(bou(nou(1),1),'(''           qc0 data saved '',
2078d2141
< c   ***CGNSstart
2080d2142
< c   ***CGNSend
2104d2165
< c   ***CGNSstart
2106,2107c2167,2183
<                write(11,'('' cgns not working for deforming yet'')')
<                call termn8(myid,-1,ibufdim,nbuf,bou,nou)
---
> #if defined CGNS
>                maxnum=2*nmds*naesrf
>                maxnum2=ntt*3*nmds*naesrf
>                if ((maxnum+maxnum2) .gt. nwork) then
>                  write(11,'('' not enough room in wk for'',
>      .             '' writing data in raeromode'')')
>                  call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>                end if
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),'('' reading generalized force/'',
>      .         ''displacement data from cgns file for'')')
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),'(''    all aeroelastic surfaces'')')
>                call raeromode(iccg,ibase,ncycmax,nmds,maxaes,
>      .         ntt,naesrf,wk,maxnum,wk2,maxnum2,
>      .         timekeep,xxn,gforcn,gforcnm,aehist)
> #endif
2109d2184
< c   ***CGNSend
2125d2199
< c   ***CGNSstart
2127d2200
< c   ***CGNSend
2129d2201
< c   ***CGNSstart
2140d2211
< c   ***CGNSend
Index: source/cfl3d/dist/sizer.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/sizer.F,v
retrieving revision 1.3
retrieving revision 1.9
diff -r1.3 -r1.9
12c12
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
56c56
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
61a62
>       integer stats
63,67d63
<       dimension bcfilei(maxbl0,maxseg0,2),bcfilej(maxbl0,maxseg0,2),
<      .          bcfilek(maxbl0,maxseg0,2)
<       dimension mglevg(maxbl0),nemgl(maxbl0),ipl3dtmp(11*nplots0)
<       dimension ifrom(msub10),xif1(msub10),etf1(msub10),xif2(msub10),
<      .          etf2(msub10)
69,223c65,241
<       dimension memblock(maxbl0),iv(maxbl0),icsinfo(maxcs0,9)
<       dimension nblfine(maxbl0)
<       dimension lw(65,maxbl0),lw2(43,maxbl0)
<       dimension ltot(maxbl0)
<       dimension iwrk(maxbl0,3)
<       dimension jjmax1(nsub10),kkmax1(nsub10)
<       dimension iiint1(nsub10),iiint2(nsub10)
<       dimension n14(maxbl0)
<       dimension mblk2nd(maxbl0)
<       dimension mem_req_node(maxnode0),no_of_points(maxnode0)
<       dimension dx(intmx0,msub10),dy(intmx0,msub10),
<      .          dz(intmx0,msub10),dthetx(intmx0,msub10),
<      .          dthety(intmx0,msub10),dthetz(intmx0,msub10)
<       dimension inpr(nplots0,11)
<       dimension inpl3d(nplots0,11)
<       dimension lig(maxbl0),lbg(maxbl0)
<       dimension ibpntsg(maxbl0,4),iipntsg(maxbl0)
<       dimension lwdat(maxbl0,maxseg0,6)
<       dimension nblk(2,mxbli0),limblk(2,6,mxbli0),
<      .          isva(2,2,mxbli0),nblon(mxbli0)
<       dimension iovrlp(maxbl0)
<       dimension rkap0g(maxbl0,3),levelg(maxbl0),igridg(maxbl0),
<      .          iflimg(maxbl0,3),ifdsg(maxbl0,3),iviscg(maxbl0,3),
<      .          jdimg(maxbl0),kdimg(maxbl0),idimg(maxbl0),
<      .          idiagg(maxbl0,3),nblcg(maxbl0),idegg(maxbl0,3),
<      .          jsg(maxbl0),ksg(maxbl0),isg(maxbl0),jeg(maxbl0),
<      .          keg(maxbl0),ieg(maxbl0),mit(5,maxbl0),
<      .          ilamlog(maxbl0),ilamhig(maxbl0),jlamlog(maxbl0),
<      .          jlamhig(maxbl0),klamlog(maxbl0),klamhig(maxbl0),
<      .          iwfg(maxbl0,3)
<       dimension utrans(maxbl0),vtrans(maxbl0),wtrans(maxbl0),
<      .          omegax(maxbl0),omegay(maxbl0),omegaz(maxbl0),
<      .          xorig(maxbl0),yorig(maxbl0),zorig(maxbl0),
<      .          dxmx(maxbl0),dymx(maxbl0),dzmx(maxbl0),
<      .          dthxmx(maxbl0),dthymx(maxbl0),dthzmx(maxbl0),
<      .          thetax(maxbl0),thetay(maxbl0),thetaz(maxbl0),
<      .          rfreqt(maxbl0),rfreqr(maxbl0),xorig0(maxbl0),
<      .          yorig0(maxbl0),zorig0(maxbl0),time2(maxbl0),
<      .          thetaxl(maxbl0),thetayl(maxbl0),thetazl(maxbl0),
<      .          itrans(maxbl0),irotat(maxbl0),idefrm(maxbl0)
<       dimension bcvali(maxbl0,maxseg0,7,2),bcvalj(maxbl0,maxseg0,7,2),
<      .          bcvalk(maxbl0,maxseg0,7,2),nbci0(maxbl0),
<      .          nbcidim(maxbl0),nbcj0(maxbl0),nbcjdim(maxbl0),
<      .          nbck0(maxbl0),nbckdim(maxbl0),
<      .          ibcinfo(maxbl0,maxseg0,7,2),
<      .          jbcinfo(maxbl0,maxseg0,7,2),
<      .          kbcinfo(maxbl0,maxseg0,7,2)
<       dimension ncgg(maxgr0),nblg(maxgr0),iemg(maxgr0),
<      .          inewgg(maxgr0)
<       dimension iadvance(maxbl0),iforce(maxbl0)
<       dimension iindx(intmx0,6*msub10+9),iindex(intmax0,2*nsub10+9),
<      .          llimit(intmx0),iitmax(intmx0),mmcxie(intmx0),
<      .          mmceta(intmx0),ncheck(maxbl0),iifit(intmx0),
<      .          mblkpt(mxxe0),iic0(intmx0),iiorph(intmx0),
<      .          iitoss(intmx0),ifiner(intmx0)
<       dimension isav_pat(intmax0,17),isav_pat_b(intmax0,nsub10,6)
<       dimension isav_dpat(intmx0,17),
<      .          isav_dpat_b(intmx0,msub10,6)
<       dimension isav_blk(2*mxbli0,17)
<       dimension isav_prd(lbcprd0,12)
<       dimension isav_emb(lbcemb0,12)
<       dimension utrnsae(maxbl0,maxsegdg0),vtrnsae(maxbl0,maxsegdg0),
<      .          wtrnsae(maxbl0,maxsegdg0),omgxae(maxbl0,maxsegdg0),
<      .          omgyae(maxbl0,maxsegdg0),omgzae(maxbl0,maxsegdg0),
<      .          xorgae(maxbl0,maxsegdg0),yorgae(maxbl0,maxsegdg0),
<      .          zorgae(maxbl0,maxsegdg0),thtxae(maxbl0,maxsegdg0),
<      .          thtyae(maxbl0,maxsegdg0),thtzae(maxbl0,maxsegdg0),
<      .          rfrqtae(maxbl0,maxsegdg0),rfrqrae(maxbl0,maxsegdg0)
<       dimension xorgae0(maxbl0,maxsegdg0),yorgae0(maxbl0,maxsegdg0),
<      .          zorgae0(maxbl0,maxsegdg0),icouple(maxbl0,maxsegdg0)
<       dimension icsi(maxbl0,maxsegdg0),icsf(maxbl0,maxsegdg0),
<      .          jcsi(maxbl0,maxsegdg0),jcsf(maxbl0,maxsegdg0),
<      .          kcsi(maxbl0,maxsegdg0),kcsf(maxbl0,maxsegdg0)
<       dimension nsegdfrm(maxbl0),idfrmseg(maxbl0,maxsegdg0),
<      .          iaesurf(maxbl0,maxsegdg0)
<       dimension freq(nmds0,maxaes0),gmass(nmds0,maxaes0),
<      .          gf0(2*nmds0,maxaes0),damp(nmds0,maxaes0),
<      .          x0(2*nmds0,maxaes0),perturb(nmds0,maxaes0,4)
<       dimension aesrfdat(5,maxaes0)
<       dimension iskip(maxbl0),jskip(maxbl0),kskip(maxbl0)
< c
<       pointer (ip_bcfilei,bcfilei),(ip_bcfilej,bcfilej),
<      .        (ip_bcfilek,bcfilek)
<       pointer (ip_ifrom,ifrom),(ip_xif1,xif1),(ip_etf1,etf1),
<      .        (ip_xif2,xif2),(ip_etf2,etf2)
<       pointer (ip_icsinfo,icsinfo),(ip_iwrk,iwrk)
<       pointer (ip_jjmax1,jjmax1),(ip_kkmax1,kkmax1),(ip_iiint1,iiint1),
<      .        (ip_iiint2,iiint2),(ip_mglevg,mglevg),(ip_nemgl,nemgl),
<      .        (ip_ipl3dtmp,ipl3dtmp)
<       pointer (ip_mem_req_node,mem_req_node),(ip_nblfine,nblfine)
<       pointer (ip_no_of_points,no_of_points),(ip_memblock,memblock)
<       pointer (ip_lwdat,lwdat),(ip_iv,iv)
<       pointer (ip_lw,lw),(ip_lw2,lw2)
<       pointer (ip_nblk,nblk),(ip_limblk,limblk),
<      .        (ip_isva,isva),(ip_nblon,nblon)
<       pointer (ip_lig,lig),(ip_lbg,lbg),(ip_iovrlp,iovrlp)
<       pointer (ip_ibpntsg,ibpntsg),(ip_iipntsg,iipntsg)
<       pointer (ip_rkap0g,rkap0g),(ip_levelg,levelg),(ip_igridg,igridg),
<      .        (ip_iflimg,iflimg),(ip_ifdsg,ifdsg),(ip_iviscg,iviscg),
<      .        (ip_jdimg,jdimg),(ip_kdimg,kdimg),(ip_idimg,idimg),
<      .        (ip_idiagg,idiagg),(ip_nblcg,nblcg),(ip_idegg,idegg),
<      .        (ip_jsg,jsg),(ip_ksg,ksg),(ip_isg,isg),(ip_jeg,jeg),
<      .        (ip_keg,keg),(ip_ieg,ieg),(ip_mit,mit),
<      .        (ip_ilamlog,ilamlog),(ip_ilamhig,ilamhig),
<      .        (ip_jlamlog,jlamlog),(ip_jlamhig,jlamhig),
<      .        (ip_klamlog,klamlog),(ip_klamhig,klamhig),(ip_iwfg,iwfg)
<       pointer (ip_utrans,utrans),(ip_vtrans,vtrans),(ip_wtrans,wtrans),
<      .        (ip_omegax,omegax),(ip_omegay,omegay),(ip_omegaz,omegaz),
<      .        (ip_xorig,xorig),(ip_yorig,yorig),(ip_zorig,zorig),
<      .        (ip_dxmx,dxmx),(ip_dymx,dymx),
<      .        (ip_dzmx,dzmx),(ip_dthxmx,dthxmx),(ip_dthymx,dthymx),
<      .        (ip_dthzmx,dthzmx),(ip_thetax,thetax),(ip_thetay,thetay),
<      .        (ip_thetaz,thetaz),(ip_rfreqt,rfreqt),
<      .        (ip_rfreqr,rfreqr),(ip_xorig0,xorig0),(ip_yorig0,yorig0),
<      .        (ip_zorig0,zorig0),(ip_time2,time2),(ip_thetaxl,thetaxl),
<      .        (ip_thetayl,thetayl),(ip_thetazl,thetazl),
<      .        (ip_itrans,itrans),(ip_irotat,irotat),(ip_idefrm,idefrm)
<       pointer (ip_bcvali,bcvali),(ip_bcvalj,bcvalj),
<      .        (ip_bcvalk,bcvalk),(ip_nbci0,nbci0),
<      .        (ip_nbcidim,nbcidim),(ip_nbcj0,nbcj0),
<      .        (ip_nbcjdim,nbcjdim),(ip_nbck0,nbck0),
<      .        (ip_nbckdim,nbckdim),(ip_ibcinfo,ibcinfo),
<      .        (ip_jbcinfo,jbcinfo),(ip_kbcinfo,kbcinfo)
<       pointer (ip_ncgg,ncgg),(ip_nblg,nblg),(ip_iemg,iemg),
<      .        (ip_inewgg,inewgg)
<       pointer (ip_inpl3d,inpl3d),(ip_inpr,inpr)
<       pointer (ip_iadvance,iadvance),(ip_iforce,iforce)
<       pointer (ip_iindx,iindx),(ip_iindex,iindex),
<      .        (ip_llimit,llimit),(ip_iitmax,iitmax),(ip_mmcxie,mmcxie),
<      .        (ip_mmceta,mmceta),(ip_ncheck,ncheck),(ip_iifit,iifit),
<      .        (ip_mblkpt,mblkpt),(ip_iic0,iic0),(ip_iiorph,iiorph),
<      .        (ip_iitoss,iitoss),(ip_ifiner,ifiner)
<       pointer (ip_dx,dx),(ip_dy,dy),(ip_dz,dz),
<      .        (ip_dthetx,dthetx),(ip_dthety,dthety),
<      .        (ip_dthetz,dthetz)
<       pointer (ip_isav_blk,isav_blk)
<       pointer (ip_isav_prd,isav_prd)
<       pointer (ip_isav_pat,isav_pat),(ip_isav_pat_b,isav_pat_b)
<       pointer (ip_isav_dpat,isav_dpat),(ip_isav_dpat_b,isav_dpat_b)
<       pointer (ip_isav_emb,isav_emb)
<       pointer (ip_mblk2nd,mblk2nd),(ip_n14,n14),(ip_ltot,ltot)
<       pointer (ip_aesrfdat,aesrfdat),(ip_utrnsae,utrnsae),
<      .        (ip_vtrnsae,vtrnsae),(ip_wtrnsae,wtrnsae),
<      .        (ip_omgxae,omgxae),(ip_omgyae,omgyae),(ip_omgzae,omgzae),
<      .        (ip_xorgae,xorgae),(ip_yorgae,yorgae),(ip_zorgae,zorgae),
<      .        (ip_xorgae0,xorgae0),(ip_yorgae0,yorgae0),
<      .        (ip_zorgae0,zorgae0),(ip_icouple,icouple),
<      .        (ip_thtxae,thtxae),(ip_thtyae,thtyae),(ip_thtzae,thtzae),
<      .        (ip_rfrqtae,rfrqtae),(ip_rfrqrae,rfrqrae),(ip_icsi,icsi),
<      .        (ip_icsf,icsf),(ip_jcsi,jcsi),(ip_jcsf,jcsf),
<      .        (ip_kcsi,kcsi),(ip_kcsf,kcsf),(ip_freq,freq),
<      .        (ip_gmass,gmass),(ip_damp,damp),(ip_x0,x0),(ip_gf0,gf0),
<      .        (ip_perturb,perturb),(ip_iskip,iskip),(ip_jskip,jskip),
<      .        (ip_kskip,kskip),(ip_nsegdfrm,nsegdfrm),
<      .        (ip_idfrmseg,idfrmseg),(ip_iaesurf,iaesurf)
---
> c
>       allocatable :: aesrfdat(:,:)
>       allocatable :: bcfilei(:,:,:)
>       allocatable :: bcfilej(:,:,:)
>       allocatable :: bcfilek(:,:,:)
>       allocatable :: bcvali(:,:,:,:)
>       allocatable :: bcvalj(:,:,:,:)
>       allocatable :: bcvalk(:,:,:,:)
>       allocatable :: damp(:,:)
>       allocatable :: dthetx(:,:)
>       allocatable :: dthety(:,:)
>       allocatable :: dthetz(:,:)
>       allocatable :: dthxmx(:)
>       allocatable :: dthymx(:)
>       allocatable :: dthzmx(:)
>       allocatable :: dx(:,:)
>       allocatable :: dxmx(:)
>       allocatable :: dy(:,:)
>       allocatable :: dymx(:)
>       allocatable :: dz(:,:)
>       allocatable :: dzmx(:)
>       allocatable :: etf1(:)
>       allocatable :: etf2(:)
>       allocatable :: freq(:,:)
>       allocatable :: gf0(:,:)
>       allocatable :: gmass(:,:)
>       allocatable :: iadvance(:)
>       allocatable :: iaesurf(:,:)
>       allocatable :: ibcinfo(:,:,:,:)
>       allocatable :: ibpntsg(:,:)
>       allocatable :: icouple(:,:)
>       allocatable :: icsf(:,:)
>       allocatable :: icsi(:,:)
>       allocatable :: icsinfo(:,:)
>       allocatable :: idefrm(:)
>       allocatable :: idegg(:,:)
>       allocatable :: idfrmseg(:,:)
>       allocatable :: idiagg(:,:)
>       allocatable :: idimg(:)
>       allocatable :: ieg(:)
>       allocatable :: iemg(:)
>       allocatable :: ifdsg(:,:)
>       allocatable :: ifiner(:)
>       allocatable :: iflimg(:,:)
>       allocatable :: iforce(:)
>       allocatable :: ifrom(:)
>       allocatable :: igridg(:)
>       allocatable :: iic0(:)
>       allocatable :: iifit(:)
>       allocatable :: iiint1(:)
>       allocatable :: iiint2(:)
>       allocatable :: iindex(:,:)
>       allocatable :: iindx(:,:)
>       allocatable :: iiorph(:)
>       allocatable :: iipntsg(:)
>       allocatable :: iitmax(:)
>       allocatable :: iitoss(:)
>       allocatable :: ilamhig(:)
>       allocatable :: ilamlog(:)
>       allocatable :: inewgg(:)
>       allocatable :: inpl3d(:,:)
>       allocatable :: inpr(:,:)
>       allocatable :: iovrlp(:)
>       allocatable :: ipl3dtmp(:)
>       allocatable :: irotat(:)
>       allocatable :: isav_blk(:,:)
>       allocatable :: isav_dpat(:,:)
>       allocatable :: isav_dpat_b(:,:,:)
>       allocatable :: isav_emb(:,:)
>       allocatable :: isav_pat(:,:)
>       allocatable :: isav_pat_b(:,:,:)
>       allocatable :: isav_prd(:,:)
>       allocatable :: isg(:)
>       allocatable :: iskip(:)
>       allocatable :: isva(:,:,:)
>       allocatable :: itrans(:)
>       allocatable :: iv(:)
>       allocatable :: iviscg(:,:)
>       allocatable :: iwfg(:,:)
>       allocatable :: iwrk(:,:)
>       allocatable :: jbcinfo(:,:,:,:)
>       allocatable :: jcsf(:,:)
>       allocatable :: jcsi(:,:)
>       allocatable :: jdimg(:)
>       allocatable :: jeg(:)
>       allocatable :: jjmax1(:)
>       allocatable :: jlamhig(:)
>       allocatable :: jlamlog(:)
>       allocatable :: jsg(:)
>       allocatable :: jskip(:)
>       allocatable :: kbcinfo(:,:,:,:)
>       allocatable :: kcsf(:,:)
>       allocatable :: kcsi(:,:)
>       allocatable :: kdimg(:)
>       allocatable :: keg(:)
>       allocatable :: kkmax1(:)
>       allocatable :: klamhig(:)
>       allocatable :: klamlog(:)
>       allocatable :: ksg(:)
>       allocatable :: kskip(:)
>       allocatable :: lbg(:)
>       allocatable :: levelg(:)
>       allocatable :: lig(:)
>       allocatable :: limblk(:,:,:)
>       allocatable :: llimit(:)
>       allocatable :: ltot(:)
>       allocatable :: lw(:,:)
>       allocatable :: lw2(:,:)
>       allocatable :: lwdat(:,:,:)
>       allocatable :: mblk2nd(:)
>       allocatable :: mblkpt(:)
>       allocatable :: mem_req_node(:)
>       allocatable :: memblock(:)
>       allocatable :: mglevg(:)
>       allocatable :: mit(:,:)
>       allocatable :: mmceta(:)
>       allocatable :: mmcxie(:)
>       allocatable :: n14(:)
>       allocatable :: nbci0(:)
>       allocatable :: nbcidim(:)
>       allocatable :: nbcj0(:)
>       allocatable :: nbcjdim(:)
>       allocatable :: nbck0(:)
>       allocatable :: nbckdim(:)
>       allocatable :: nblcg(:)
>       allocatable :: nblfine(:)
>       allocatable :: nblg(:)
>       allocatable :: nblk(:,:)
>       allocatable :: nblon(:)
>       allocatable :: ncgg(:)
>       allocatable :: ncheck(:)
>       allocatable :: nemgl(:)
>       allocatable :: no_of_points(:)
>       allocatable :: nsegdfrm(:)
>       allocatable :: omegax(:)
>       allocatable :: omegay(:)
>       allocatable :: omegaz(:)
>       allocatable :: omgxae(:,:)
>       allocatable :: omgyae(:,:)
>       allocatable :: omgzae(:,:)
>       allocatable :: perturb(:,:,:)
>       allocatable :: rfreqr(:)
>       allocatable :: rfreqt(:)
>       allocatable :: rfrqrae(:,:)
>       allocatable :: rfrqtae(:,:)
>       allocatable :: rkap0g(:,:)
>       allocatable :: thetax(:)
>       allocatable :: thetaxl(:)
>       allocatable :: thetay(:)
>       allocatable :: thetayl(:)
>       allocatable :: thetaz(:)
>       allocatable :: thetazl(:)
>       allocatable :: thtxae(:,:)
>       allocatable :: thtyae(:,:)
>       allocatable :: thtzae(:,:)
>       allocatable :: time2(:)
>       allocatable :: utrans(:)
>       allocatable :: utrnsae(:,:)
>       allocatable :: vtrans(:)
>       allocatable :: vtrnsae(:,:)
>       allocatable :: wtrans(:)
>       allocatable :: wtrnsae(:,:)
>       allocatable :: x0(:,:)
>       allocatable :: xif1(:)
>       allocatable :: xif2(:)
>       allocatable :: xorgae(:,:)
>       allocatable :: xorgae0(:,:)
>       allocatable :: xorig(:)
>       allocatable :: xorig0(:)
>       allocatable :: yorgae(:,:)
>       allocatable :: yorgae0(:,:)
>       allocatable :: yorig(:)
>       allocatable :: yorig0(:)
>       allocatable :: zorgae(:,:)
>       allocatable :: zorgae0(:,:)
>       allocatable :: zorig(:)
>       allocatable :: zorig0(:)
240c258
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
256c274
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
266,441c284,635
<       call umalloc(ip_ltot,maxbl0,1,icall,memuse)
<       call umalloc(ip_jjmax1,nsub10,1,icall,memuse)
<       call umalloc(ip_kkmax1,nsub10,1,icall,memuse)
<       call umalloc(ip_iiint1,nsub10,1,icall,memuse)
<       call umalloc(ip_iiint2,nsub10,1,icall,memuse)
<       call umalloc(ip_n14,maxbl0,1,icall,memuse)
<       call umalloc(ip_iwrk,maxbl0*3,1,icall,memuse)
<       call umalloc(ip_icsinfo,maxcs0*9,1,icall,memuse)
<       call umalloc(ip_iv,maxbl0,1,icall,memuse)
<       call umalloc(ip_memblock,maxbl0,1,icall,memuse)
<       call umalloc(ip_lwdat,maxbl0*maxseg0*6,1,icall,memuse)
<       call umalloc(ip_nblfine,maxbl0,1,icall,memuse)
<       call umalloc(ip_mem_req_node,maxnode0,1,icall,memuse)
<       call umalloc(ip_no_of_points,maxnode0,1,icall,memuse)
<       call umalloc(ip_lw,65*maxbl0,1,icall,memuse)
<       call umalloc(ip_lw2,43*maxbl0,1,icall,memuse)
<       call umalloc(ip_nblk,2*mxbli0,1,icall,memuse)
<       call umalloc(ip_limblk,12*mxbli0,1,icall,memuse)
<       call umalloc(ip_isva,4*mxbli0,1,icall,memuse)
<       call umalloc(ip_nblon,mxbli0,1,icall,memuse)
<       call umalloc(ip_lig,maxbl0,1,icall,memuse)
<       call umalloc(ip_lbg,maxbl0,1,icall,memuse)
<       call umalloc(ip_iovrlp,maxbl0,1,icall,memuse)
<       call umalloc(ip_ibpntsg,4*maxbl0,1,icall,memuse)
<       call umalloc(ip_iipntsg,maxbl0,1,icall,memuse)
<       call umalloc(ip_rkap0g,3*maxbl0,0,icall,memuse)
<       call umalloc(ip_levelg,maxbl0,1,icall,memuse)
<       call umalloc(ip_igridg,maxbl0,1,icall,memuse)
<       call umalloc(ip_iflimg,3*maxbl0,1,icall,memuse)
<       call umalloc(ip_ifdsg,3*maxbl0,1,icall,memuse)
<       call umalloc(ip_iviscg,3*maxbl0,1,icall,memuse)
<       call umalloc(ip_jdimg,maxbl0,1,icall,memuse)
<       call umalloc(ip_kdimg,maxbl0,1,icall,memuse)
<       call umalloc(ip_idimg,maxbl0,1,icall,memuse)
<       call umalloc(ip_idiagg,3*maxbl0,1,icall,memuse)
<       call umalloc(ip_nblcg,maxbl0,1,icall,memuse)
<       call umalloc(ip_idegg,3*maxbl0,1,icall,memuse)
<       call umalloc(ip_jsg,maxbl0,1,icall,memuse)
<       call umalloc(ip_ksg,maxbl0,1,icall,memuse)
<       call umalloc(ip_isg,maxbl0,1,icall,memuse)
<       call umalloc(ip_jeg,maxbl0,1,icall,memuse)
<       call umalloc(ip_keg,maxbl0,1,icall,memuse)
<       call umalloc(ip_ieg,maxbl0,1,icall,memuse)
<       call umalloc(ip_mit,5*maxbl0,1,icall,memuse)
<       call umalloc(ip_jlamlog,maxbl0,1,icall,memuse)
<       call umalloc(ip_klamlog,maxbl0,1,icall,memuse)
<       call umalloc(ip_ilamlog,maxbl0,1,icall,memuse)
<       call umalloc(ip_jlamhig,maxbl0,1,icall,memuse)
<       call umalloc(ip_klamhig,maxbl0,1,icall,memuse)
<       call umalloc(ip_ilamhig,maxbl0,1,icall,memuse)
<       call umalloc(ip_iwfg,3*maxbl0,1,icall,memuse)
<       call umalloc(ip_utrans,maxbl0,0,icall,memuse)
<       call umalloc(ip_vtrans,maxbl0,0,icall,memuse)
<       call umalloc(ip_wtrans,maxbl0,0,icall,memuse)
<       call umalloc(ip_omegax,maxbl0,0,icall,memuse)
<       call umalloc(ip_omegay,maxbl0,0,icall,memuse)
<       call umalloc(ip_omegaz,maxbl0,0,icall,memuse)
<       call umalloc(ip_xorig,maxbl0,0,icall,memuse)
<       call umalloc(ip_yorig,maxbl0,0,icall,memuse)
<       call umalloc(ip_zorig,maxbl0,0,icall,memuse)
<       call umalloc(ip_dxmx,maxbl0,0,icall,memuse)
<       call umalloc(ip_dymx,maxbl0,0,icall,memuse)
<       call umalloc(ip_dzmx,maxbl0,0,icall,memuse)
<       call umalloc(ip_dthxmx,maxbl0,0,icall,memuse)
<       call umalloc(ip_dthymx,maxbl0,0,icall,memuse)
<       call umalloc(ip_dthzmx,maxbl0,0,icall,memuse)
<       call umalloc(ip_thetax,maxbl0,0,icall,memuse)
<       call umalloc(ip_thetay,maxbl0,0,icall,memuse)
<       call umalloc(ip_thetaz,maxbl0,0,icall,memuse)
<       call umalloc(ip_rfreqt,maxbl0,0,icall,memuse)
<       call umalloc(ip_rfreqr,maxbl0,0,icall,memuse)
<       call umalloc(ip_xorig0,maxbl0,0,icall,memuse)
<       call umalloc(ip_yorig0,maxbl0,0,icall,memuse)
<       call umalloc(ip_zorig0,maxbl0,0,icall,memuse)
<       call umalloc(ip_time2,maxbl0,0,icall,memuse)
<       call umalloc(ip_thetaxl,maxbl0,0,icall,memuse)
<       call umalloc(ip_thetayl,maxbl0,0,icall,memuse)
<       call umalloc(ip_thetazl,maxbl0,0,icall,memuse)
<       call umalloc(ip_itrans,maxbl0,1,icall,memuse)
<       call umalloc(ip_irotat,maxbl0,1,icall,memuse)
<       call umalloc(ip_idefrm,maxbl0,1,icall,memuse) 
<       call umalloc(ip_bcvali,14*maxseg0*maxbl0,0,icall,memuse)
<       call umalloc(ip_bcvalj,14*maxseg0*maxbl0,0,icall,memuse)
<       call umalloc(ip_bcvalk,14*maxseg0*maxbl0,0,icall,memuse)
<       call umalloc(ip_nbci0,maxbl0,1,icall,memuse)
<       call umalloc(ip_nbcj0,maxbl0,1,icall,memuse)
<       call umalloc(ip_nbck0,maxbl0,1,icall,memuse)
<       call umalloc(ip_nbcidim,maxbl0,1,icall,memuse)
<       call umalloc(ip_nbcjdim,maxbl0,1,icall,memuse)
<       call umalloc(ip_nbckdim,maxbl0,1,icall,memuse)
<       call umalloc(ip_ibcinfo,14*maxseg0*maxbl0,1,icall,memuse)
<       call umalloc(ip_jbcinfo,14*maxseg0*maxbl0,1,icall,memuse)
<       call umalloc(ip_kbcinfo,14*maxseg0*maxbl0,1,icall,memuse)
<       call umalloc(ip_bcfilei,2*maxseg0*maxbl0,1,icall,memuse)
<       call umalloc(ip_bcfilej,2*maxseg0*maxbl0,1,icall,memuse)
<       call umalloc(ip_bcfilek,2*maxseg0*maxbl0,1,icall,memuse)
<       call umalloc(ip_ncgg,maxgr0,1,icall,memuse)
<       call umalloc(ip_nblg,maxgr0,1,icall,memuse)
<       call umalloc(ip_iemg,maxgr0,1,icall,memuse)
<       call umalloc(ip_inewgg,maxgr0,1,icall,memuse)
<       call umalloc(ip_inpl3d,11*nplots0,1,icall,memuse)
<       call umalloc(ip_inpr,11*nplots0,1,icall,memuse)
<       call umalloc(ip_iadvance,maxbl0,1,icall,memuse)
<       call umalloc(ip_iforce,maxbl0,1,icall,memuse)
<       call umalloc(ip_iindex,intmax0*(6*nsub10+9),1,icall,memuse)
<       call umalloc(ip_iindx,intmx0*(6*msub10+9),1,icall,memuse)
<       call umalloc(ip_llimit,intmx0,1,icall,memuse)
<       call umalloc(ip_iitmax,intmx0,1,icall,memuse)
<       call umalloc(ip_mmcxie,intmx0,1,icall,memuse)
<       call umalloc(ip_mmceta,intmx0,1,icall,memuse)
<       call umalloc(ip_ncheck,maxbl0,1,icall,memuse)
<       call umalloc(ip_iifit,intmx0,1,icall,memuse)
<       call umalloc(ip_mblkpt,mxxe0,1,icall,memuse)
<       call umalloc(ip_iic0,intmx0,1,icall,memuse)
<       call umalloc(ip_iiorph,intmx0,1,icall,memuse)
<       call umalloc(ip_iitoss,intmx0,1,icall,memuse)
<       call umalloc(ip_ifiner,intmx0,1,icall,memuse)
<       call umalloc(ip_dx,intmx0*msub10,0,icall,memuse)
<       call umalloc(ip_dy,intmx0*msub10,0,icall,memuse)
<       call umalloc(ip_dz,intmx0*msub10,0,icall,memuse)
<       call umalloc(ip_dthetx,intmx0*msub10,0,icall,memuse)
<       call umalloc(ip_dthety,intmx0*msub10,0,icall,memuse)
<       call umalloc(ip_dthetz,intmx0*msub10,0,icall,memuse)
<       call umalloc(ip_isav_blk,34*mxbli0,1,icall,memuse)
<       call umalloc(ip_isav_prd,12*lbcprd0,1,icall,memuse)
<       call umalloc(ip_isav_pat,17*intmax0,1,icall,memuse)
<       call umalloc(ip_isav_pat_b,6*intmax0*nsub10,1,icall,memuse)
<       call umalloc(ip_isav_dpat,17*intmx0,1,icall,memuse)
<       call umalloc(ip_isav_dpat_b,6*intmx0*msub10,1,icall,memuse)
<       call umalloc(ip_isav_emb,12*lbcemb0,1,icall,memuse)
<       call umalloc(ip_mblk2nd,maxbl0,1,icall,memuse)
<       call umalloc(ip_mglevg,maxbl0,1,icall,memuse)
<       call umalloc(ip_nemgl,maxbl0,1,icall,memuse)
<       call umalloc(ip_ipl3dtmp,11*nplots0,1,icall,memuse)
<       call umalloc(ip_ifrom,msub10,1,icall,memuse)
<       call umalloc(ip_xif1,msub10,1,icall,memuse)
<       call umalloc(ip_etf1,msub10,1,icall,memuse)
<       call umalloc(ip_xif2,msub10,1,icall,memuse)
<       call umalloc(ip_etf2,msub10,1,icall,memuse)
<       call umalloc(ip_utrnsae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_vtrnsae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_wtrnsae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_omgxae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_omgyae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_omgzae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_xorgae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_yorgae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_zorgae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_xorgae0,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_yorgae0,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_zorgae0,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_icouple,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_thtxae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_thtyae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_thtzae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_rfrqtae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_rfrqrae,maxbl0*maxsegdg0,0,icall,memuse)
<       call umalloc(ip_icsi,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_icsf,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_jcsi,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_jcsf,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_kcsi,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_kcsf,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_idfrmseg,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_iaesurf,maxbl0*maxsegdg0,1,icall,memuse)
<       call umalloc(ip_nsegdfrm,maxbl0,1,icall,memuse)
<       call umalloc(ip_freq,nmds0*maxaes0,0,icall,memuse)
<       call umalloc(ip_gmass,nmds0*maxaes0,0,icall,memuse)
<       call umalloc(ip_x0,2*nmds0*maxaes0,0,icall,memuse)
<       call umalloc(ip_gf0,2*nmds0*maxaes0,0,icall,memuse)
<       call umalloc(ip_damp,nmds0*maxaes0,0,icall,memuse)
<       call umalloc(ip_perturb,4*nmds0*maxaes0,0,icall,memuse)
<       call umalloc(ip_aesrfdat,5*maxaes0,0,icall,memuse)
<       call umalloc(ip_iskip,maxbl0,1,icall,memuse)
<       call umalloc(ip_jskip,maxbl0,1,icall,memuse)
<       call umalloc(ip_kskip,maxbl0,1,icall,memuse)
---
>       allocate( aesrfdat(5,maxaes0), stat=stats )
>       call umalloc(5*maxaes0,0,'aesrfdat',memuse,stats)
>       allocate( bcfilei(maxbl0,maxseg0,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*2,1,'bcfilei',memuse,stats)
>       allocate( bcfilej(maxbl0,maxseg0,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*2,1,'bcfilej',memuse,stats)
>       allocate( bcfilek(maxbl0,maxseg0,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*2,1,'bcfilek',memuse,stats)
>       allocate( bcvali(maxbl0,maxseg0,7,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*7*2,0,'bcvali',memuse,stats)
>       allocate( bcvalj(maxbl0,maxseg0,7,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*7*2,0,'bcvalj',memuse,stats)
>       allocate( bcvalk(maxbl0,maxseg0,7,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*7*2,0,'bcvalk',memuse,stats)
>       allocate( damp(nmds0,maxaes0), stat=stats )
>       call umalloc(nmds0*maxaes0,0,'damp',memuse,stats)
>       allocate( dthetx(intmx0,msub10), stat=stats )
>       call umalloc(intmx0*msub10,0,'dthetx',memuse,stats)
>       allocate( dthety(intmx0,msub10), stat=stats )
>       call umalloc(intmx0*msub10,0,'dthety',memuse,stats)
>       allocate( dthetz(intmx0,msub10), stat=stats )
>       call umalloc(intmx0*msub10,0,'dthetz',memuse,stats)
>       allocate( dthxmx(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'dthxmx',memuse,stats)
>       allocate( dthymx(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'dthymx',memuse,stats)
>       allocate( dthzmx(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'dthzmx',memuse,stats)
>       allocate( dx(intmx0,msub10), stat=stats )
>       call umalloc(intmx0*msub10,0,'dx',memuse,stats)
>       allocate( dxmx(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'dxmx',memuse,stats)
>       allocate( dy(intmx0,msub10), stat=stats )
>       call umalloc(intmx0*msub10,0,'dy',memuse,stats)
>       allocate( dymx(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'dymx',memuse,stats)
>       allocate( dz(intmx0,msub10), stat=stats )
>       call umalloc(intmx0*msub10,0,'dz',memuse,stats)
>       allocate( dzmx(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'dzmx',memuse,stats)
>       allocate( etf1(msub10), stat=stats )
>       call umalloc(msub10,1,'etf1',memuse,stats)
>       allocate( etf2(msub10), stat=stats )
>       call umalloc(msub10,1,'etf2',memuse,stats)
>       allocate( freq(nmds0,maxaes0), stat=stats )
>       call umalloc(nmds0*maxaes0,0,'freq',memuse,stats)
>       allocate( gf0(2*nmds0,maxaes0), stat=stats )
>       call umalloc(2*nmds0*maxaes0,0,'gf0',memuse,stats)
>       allocate( gmass(nmds0,maxaes0), stat=stats )
>       call umalloc(nmds0*maxaes0,0,'gmass',memuse,stats)
>       allocate( iadvance(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'iadvance',memuse,stats)
>       allocate( iaesurf(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'iaesurf',memuse,stats)
>       allocate( ibcinfo(maxbl0,maxseg0,7,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*7*2,1,'ibcinfo',memuse,stats)
>       allocate( ibpntsg(maxbl0,4), stat=stats )
>       call umalloc(maxbl0*4,1,'ibpntsg',memuse,stats)
>       allocate( icouple(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'icouple',memuse,stats)
>       allocate( icsf(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'icsf',memuse,stats)
>       allocate( icsi(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'icsi',memuse,stats)
>       allocate( icsinfo(maxcs0,9), stat=stats )
>       call umalloc(maxcs0*9,1,'icsinfo',memuse,stats)
>       allocate( idefrm(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'idefrm',memuse,stats)
>       allocate( idegg(maxbl0,3), stat=stats )
>       call umalloc(maxbl0*3,1,'idegg',memuse,stats)
>       allocate( idfrmseg(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'idfrmseg',memuse,stats)
>       allocate( idiagg(maxbl0,3), stat=stats )
>       call umalloc(maxbl0*3,1,'idiagg',memuse,stats)
>       allocate( idimg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'idimg',memuse,stats)
>       allocate( ieg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'ieg',memuse,stats)
>       allocate( iemg(maxgr0), stat=stats )
>       call umalloc(maxgr0,1,'iemg',memuse,stats)
>       allocate( ifdsg(maxbl0,3), stat=stats )
>       call umalloc(maxbl0*3,1,'ifdsg',memuse,stats)
>       allocate( ifiner(intmx0), stat=stats )
>       call umalloc(intmx0,1,'ifiner',memuse,stats)
>       allocate( iflimg(maxbl0,3), stat=stats )
>       call umalloc(maxbl0*3,1,'iflimg',memuse,stats)
>       allocate( iforce(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'iforce',memuse,stats)
>       allocate( ifrom(msub10), stat=stats )
>       call umalloc(msub10,1,'ifrom',memuse,stats)
>       allocate( igridg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'igridg',memuse,stats)
>       allocate( iic0(intmx0), stat=stats )
>       call umalloc(intmx0,1,'iic0',memuse,stats)
>       allocate( iifit(intmx0), stat=stats )
>       call umalloc(intmx0,1,'iifit',memuse,stats)
>       allocate( iiint1(nsub10), stat=stats )
>       call umalloc(nsub10,1,'iiint1',memuse,stats)
>       allocate( iiint2(nsub10), stat=stats )
>       call umalloc(nsub10,1,'iiint2',memuse,stats)
>       allocate( iindex(intmax0,6*nsub10+9), stat=stats )
>       call umalloc(intmax0*(6*nsub10+9),1,'iindex',memuse,stats)
>       allocate( iindx(intmx0,6*msub10+9), stat=stats )
>       call umalloc(intmx0*(6*msub10+9),1,'iindx',memuse,stats)
>       allocate( iiorph(intmx0), stat=stats )
>       call umalloc(intmx0,1,'iiorph',memuse,stats)
>       allocate( iipntsg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'iipntsg',memuse,stats)
>       allocate( iitmax(intmx0), stat=stats )
>       call umalloc(intmx0,1,'iitmax',memuse,stats)
>       allocate( iitoss(intmx0), stat=stats )
>       call umalloc(intmx0,1,'iitoss',memuse,stats)
>       allocate( ilamhig(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'ilamhig',memuse,stats)
>       allocate( ilamlog(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'ilamlog',memuse,stats)
>       allocate( inewgg(maxgr0), stat=stats )
>       call umalloc(maxgr0,1,'inewgg',memuse,stats)
>       allocate( inpl3d(nplots0,11), stat=stats )
>       call umalloc(nplots0*11,1,'inpl3d',memuse,stats)
>       allocate( inpr(nplots0,11), stat=stats )
>       call umalloc(nplots0*11,1,'inpr',memuse,stats)
>       allocate( iovrlp(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'iovrlp',memuse,stats)
>       allocate( ipl3dtmp(11*nplots0), stat=stats )
>       call umalloc(11*nplots0,1,'ipl3dtmp',memuse,stats)
>       allocate( irotat(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'irotat',memuse,stats)
>       allocate( isav_blk(2*mxbli0,17), stat=stats )
>       call umalloc(2*mxbli0*17,1,'isav_blk',memuse,stats)
>       allocate( isav_dpat(intmx0,17), stat=stats )
>       call umalloc(intmx0*17,1,'isav_dpat',memuse,stats)
>       allocate( isav_dpat_b(intmx0,msub10,6), stat=stats )
>       call umalloc(intmx0*msub10*6,1,'isav_dpat_b',memuse,stats)
>       allocate( isav_emb(lbcemb0,12), stat=stats )
>       call umalloc(lbcemb0*12,1,'isav_emb',memuse,stats)
>       allocate( isav_pat(intmax0,17), stat=stats )
>       call umalloc(intmax0*17,1,'isav_pat',memuse,stats)
>       allocate( isav_pat_b(intmax0,nsub10,6), stat=stats )
>       call umalloc(intmax0*nsub10*6,1,'isav_pat_b',memuse,stats)
>       allocate( isav_prd(lbcprd0,12), stat=stats )
>       call umalloc(lbcprd0*12,1,'isav_prd',memuse,stats)
>       allocate( isg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'isg',memuse,stats)
>       allocate( iskip(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'iskip',memuse,stats)
>       allocate( isva(2,2,mxbli0), stat=stats )
>       call umalloc(2*2*mxbli0,1,'isva',memuse,stats)
>       allocate( itrans(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'itrans',memuse,stats)
>       allocate( iv(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'iv',memuse,stats)
>       allocate( iviscg(maxbl0,3), stat=stats )
>       call umalloc(maxbl0*3,1,'iviscg',memuse,stats)
>       allocate( iwfg(maxbl0,3), stat=stats )
>       call umalloc(maxbl0*3,1,'iwfg',memuse,stats)
>       allocate( iwrk(maxbl0,3), stat=stats )
>       call umalloc(maxbl0*3,1,'iwrk',memuse,stats)
>       allocate( jbcinfo(maxbl0,maxseg0,7,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*7*2,1,'jbcinfo',memuse,stats)
>       allocate( jcsf(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'jcsf',memuse,stats)
>       allocate( jcsi(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'jcsi',memuse,stats)
>       allocate( jdimg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'jdimg',memuse,stats)
>       allocate( jeg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'jeg',memuse,stats)
>       allocate( jjmax1(nsub10), stat=stats )
>       call umalloc(nsub10,1,'jjmax1',memuse,stats)
>       allocate( jlamhig(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'jlamhig',memuse,stats)
>       allocate( jlamlog(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'jlamlog',memuse,stats)
>       allocate( jsg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'jsg',memuse,stats)
>       allocate( jskip(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'jskip',memuse,stats)
>       allocate( kbcinfo(maxbl0,maxseg0,7,2), stat=stats )
>       call umalloc(maxbl0*maxseg0*7*2,1,'kbcinfo',memuse,stats)
>       allocate( kcsf(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'kcsf',memuse,stats)
>       allocate( kcsi(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,1,'kcsi',memuse,stats)
>       allocate( kdimg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'kdimg',memuse,stats)
>       allocate( keg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'keg',memuse,stats)
>       allocate( kkmax1(nsub10), stat=stats )
>       call umalloc(nsub10,1,'kkmax1',memuse,stats)
>       allocate( klamhig(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'klamhig',memuse,stats)
>       allocate( klamlog(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'klamlog',memuse,stats)
>       allocate( ksg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'ksg',memuse,stats)
>       allocate( kskip(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'kskip',memuse,stats)
>       allocate( lbg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'lbg',memuse,stats)
>       allocate( levelg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'levelg',memuse,stats)
>       allocate( lig(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'lig',memuse,stats)
>       allocate( limblk(2,6,mxbli0), stat=stats )
>       call umalloc(2*6*mxbli0,1,'limblk',memuse,stats)
>       allocate( llimit(intmx0), stat=stats )
>       call umalloc(intmx0,1,'llimit',memuse,stats)
>       allocate( ltot(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'ltot',memuse,stats)
>       allocate( lw(65,maxbl0), stat=stats )
>       call umalloc(65*maxbl0,1,'lw',memuse,stats)
>       allocate( lw2(43,maxbl0), stat=stats )
>       call umalloc(43*maxbl0,1,'lw2',memuse,stats)
>       allocate( lwdat(maxbl0,maxseg0,6), stat=stats )
>       call umalloc(maxbl0*maxseg0*6,1,'lwdat',memuse,stats)
>       allocate( mblk2nd(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'mblk2nd',memuse,stats)
>       allocate( mblkpt(mxxe0), stat=stats )
>       call umalloc(mxxe0,1,'mblkpt',memuse,stats)
>       allocate( mem_req_node(maxnode0), stat=stats )
>       call umalloc(maxnode0,1,'mem_req_node',memuse,stats)
>       allocate( memblock(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'memblock',memuse,stats)
>       allocate( mglevg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'mglevg',memuse,stats)
>       allocate( mit(5,maxbl0), stat=stats )
>       call umalloc(5*maxbl0,1,'mit',memuse,stats)
>       allocate( mmceta(intmx0), stat=stats )
>       call umalloc(intmx0,1,'mmceta',memuse,stats)
>       allocate( mmcxie(intmx0), stat=stats )
>       call umalloc(intmx0,1,'mmcxie',memuse,stats)
>       allocate( n14(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'n14',memuse,stats)
>       allocate( nbci0(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nbci0',memuse,stats)
>       allocate( nbcidim(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nbcidim',memuse,stats)
>       allocate( nbcj0(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nbcj0',memuse,stats)
>       allocate( nbcjdim(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nbcjdim',memuse,stats)
>       allocate( nbck0(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nbck0',memuse,stats)
>       allocate( nbckdim(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nbckdim',memuse,stats)
>       allocate( nblcg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nblcg',memuse,stats)
>       allocate( nblfine(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nblfine',memuse,stats)
>       allocate( nblg(maxgr0), stat=stats )
>       call umalloc(maxgr0,1,'nblg',memuse,stats)
>       allocate( nblk(2,mxbli0), stat=stats )
>       call umalloc(2*mxbli0,1,'nblk',memuse,stats)
>       allocate( nblon(mxbli0), stat=stats )
>       call umalloc(mxbli0,1,'nblon',memuse,stats)
>       allocate( ncgg(maxgr0), stat=stats )
>       call umalloc(maxgr0,1,'ncgg',memuse,stats)
>       allocate( ncheck(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'ncheck',memuse,stats)
>       allocate( nemgl(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nemgl',memuse,stats)
>       allocate( no_of_points(maxnode0), stat=stats )
>       call umalloc(maxnode0,1,'no_of_points',memuse,stats)
>       allocate( nsegdfrm(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nsegdfrm',memuse,stats)
>       allocate( omegax(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'omegax',memuse,stats)
>       allocate( omegay(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'omegay',memuse,stats)
>       allocate( omegaz(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'omegaz',memuse,stats)
>       allocate( omgxae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'omgxae',memuse,stats)
>       allocate( omgyae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'omgyae',memuse,stats)
>       allocate( omgzae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'omgzae',memuse,stats)
>       allocate( perturb(nmds0,maxaes0,4), stat=stats )
>       call umalloc(nmds0*maxaes0*4,0,'perturb',memuse,stats)
>       allocate( rfreqr(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'rfreqr',memuse,stats)
>       allocate( rfreqt(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'rfreqt',memuse,stats)
>       allocate( rfrqrae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'rfrqrae',memuse,stats)
>       allocate( rfrqtae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'rfrqtae',memuse,stats)
>       allocate( rkap0g(maxbl0,3), stat=stats )
>       call umalloc(maxbl0*3,0,'rkap0g',memuse,stats)
>       allocate( thetax(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'thetax',memuse,stats)
>       allocate( thetaxl(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'thetaxl',memuse,stats)
>       allocate( thetay(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'thetay',memuse,stats)
>       allocate( thetayl(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'thetayl',memuse,stats)
>       allocate( thetaz(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'thetaz',memuse,stats)
>       allocate( thetazl(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'thetazl',memuse,stats)
>       allocate( thtxae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'thtxae',memuse,stats)
>       allocate( thtyae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'thtyae',memuse,stats)
>       allocate( thtzae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'thtzae',memuse,stats)
>       allocate( time2(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'time2',memuse,stats)
>       allocate( utrans(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'utrans',memuse,stats)
>       allocate( utrnsae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'utrnsae',memuse,stats)
>       allocate( vtrans(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'vtrans',memuse,stats)
>       allocate( vtrnsae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'vtrnsae',memuse,stats)
>       allocate( wtrans(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'wtrans',memuse,stats)
>       allocate( wtrnsae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'wtrnsae',memuse,stats)
>       allocate( x0(2*nmds0,maxaes0), stat=stats )
>       call umalloc(2*nmds0*maxaes0,0,'x0',memuse,stats)
>       allocate( xif1(msub10), stat=stats )
>       call umalloc(msub10,1,'xif1',memuse,stats)
>       allocate( xif2(msub10), stat=stats )
>       call umalloc(msub10,1,'xif2',memuse,stats)
>       allocate( xorgae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'xorgae',memuse,stats)
>       allocate( xorgae0(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'xorgae0',memuse,stats)
>       allocate( xorig(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'xorig',memuse,stats)
>       allocate( xorig0(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'xorig0',memuse,stats)
>       allocate( yorgae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'yorgae',memuse,stats)
>       allocate( yorgae0(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'yorgae0',memuse,stats)
>       allocate( yorig(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'yorig',memuse,stats)
>       allocate( yorig0(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'yorig0',memuse,stats)
>       allocate( zorgae(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'zorgae',memuse,stats)
>       allocate( zorgae0(maxbl0,maxsegdg0), stat=stats )
>       call umalloc(maxbl0*maxsegdg0,0,'zorgae0',memuse,stats)
>       allocate( zorig(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'zorig',memuse,stats)
>       allocate( zorig0(maxbl0), stat=stats )
>       call umalloc(maxbl0,0,'zorig0',memuse,stats)
519c713
<  9990 format(2(2h *),43h   VERSION 6.0 :  Computational Fluids Lab,,
---
>  9990 format(2(2h *),43h   VERSION 6.X :  Computational Fluids Lab,,
522c716
<      .3x,2(2h *),/2(2h *),18x,33hRelease Date:    August  8, 2001.,
---
>      .3x,2(2h *),/2(2h *),18x,33hRelease Date:       MMM DD, YYYY.,
692c886
<          do ii=1,63
---
>          do ii=1,64
1485c1679
<             itemp = jdw*kdw*idw*14 + jdim*kdim*idim*2
---
>             itemp = jdw*kdw*idw*17 + jdim*kdim*idim*2
2030c2224
<       needi_trn = 53*lmaxbl        + 117      + 9*lmaxbl*lmxsegdg
---
>       needi_trn = 53*lmaxbl        + 118      + 9*lmaxbl*lmxsegdg
2554,2729c2748,2923
<          call ufree(ip_ltot)
<          call ufree(ip_jjmax1)
<          call ufree(ip_kkmax1)
<          call ufree(ip_iiint1)
<          call ufree(ip_iiint2)    
<          call ufree(ip_n14)
<          call ufree(ip_iwrk)
<          call ufree(ip_icsinfo)
<          call ufree(ip_iv)
<          call ufree(ip_memblock)
<          call ufree(ip_lwdat)
<          call ufree(ip_nblfine)
<          call ufree(ip_mem_req_node)
<          call ufree(ip_no_of_points)
<          call ufree(ip_lw)
<          call ufree(ip_lw2)
<          call ufree(ip_nblk)
<          call ufree(ip_limblk)
<          call ufree(ip_isva)
<          call ufree(ip_nblon)
<          call ufree(ip_lig)
<          call ufree(ip_lbg)
<          call ufree(ip_iovrlp)
<          call ufree(ip_ibpntsg)
<          call ufree(ip_iipntsg)
<          call ufree(ip_rkap0g)
<          call ufree(ip_levelg)
<          call ufree(ip_igridg)
<          call ufree(ip_iflimg)
<          call ufree(ip_ifdsg)
<          call ufree(ip_iviscg)
<          call ufree(ip_jdimg)
<          call ufree(ip_kdimg)
<          call ufree(ip_idimg)
<          call ufree(ip_idiagg)
<          call ufree(ip_nblcg)
<          call ufree(ip_idegg)
<          call ufree(ip_jsg)
<          call ufree(ip_ksg)
<          call ufree(ip_isg)
<          call ufree(ip_jeg)
<          call ufree(ip_keg)
<          call ufree(ip_ieg)
<          call ufree(ip_mit)
<          call ufree(ip_jlamlog)
<          call ufree(ip_klamlog)
<          call ufree(ip_ilamlog)
<          call ufree(ip_jlamhig)
<          call ufree(ip_klamhig)
<          call ufree(ip_ilamhig)
<          call ufree(ip_iwfg)
<          call ufree(ip_utrans)
<          call ufree(ip_vtrans)
<          call ufree(ip_wtrans)
<          call ufree(ip_omegax)
<          call ufree(ip_omegay)
<          call ufree(ip_omegaz)
<          call ufree(ip_xorig)
<          call ufree(ip_yorig)
<          call ufree(ip_zorig)
<          call ufree(ip_dxmx)
<          call ufree(ip_dymx)
<          call ufree(ip_dzmx)
<          call ufree(ip_dthxmx)
<          call ufree(ip_dthymx)
<          call ufree(ip_dthzmx)
<          call ufree(ip_thetax)
<          call ufree(ip_thetay)
<          call ufree(ip_thetaz)
<          call ufree(ip_rfreqt)
<          call ufree(ip_rfreqr)
<          call ufree(ip_xorig0)
<          call ufree(ip_yorig0)
<          call ufree(ip_zorig0)
<          call ufree(ip_time2)
<          call ufree(ip_thetaxl)
<          call ufree(ip_thetayl)
<          call ufree(ip_thetazl)
<          call ufree(ip_itrans)
<          call ufree(ip_irotat)
<          call ufree(ip_idefrm)
<          call ufree(ip_bcvali)
<          call ufree(ip_bcvalj)
<          call ufree(ip_bcvalk)
<          call ufree(ip_nbci0)
<          call ufree(ip_nbcj0)
<          call ufree(ip_nbck0)
<          call ufree(ip_nbcidim)
<          call ufree(ip_nbcjdim)
<          call ufree(ip_nbckdim)
<          call ufree(ip_ibcinfo)
<          call ufree(ip_jbcinfo)
<          call ufree(ip_kbcinfo)
<          call ufree(ip_bcfilei)
<          call ufree(ip_bcfilej)
<          call ufree(ip_bcfilek)
<          call ufree(ip_ncgg)
<          call ufree(ip_nblg)
<          call ufree(ip_iemg)
<          call ufree(ip_inewgg)
<          call ufree(ip_inpl3d)
<          call ufree(ip_inpr)
<          call ufree(ip_iadvance)
<          call ufree(ip_iforce)
<          call ufree(ip_iindex)
<          call ufree(ip_iindx)
<          call ufree(ip_llimit)
<          call ufree(ip_iitmax)
<          call ufree(ip_mmcxie)
<          call ufree(ip_mmceta)
<          call ufree(ip_ncheck)
<          call ufree(ip_iifit)
<          call ufree(ip_mblkpt)
<          call ufree(ip_iic0)
<          call ufree(ip_iiorph)
<          call ufree(ip_iitoss)
<          call ufree(ip_ifiner)
<          call ufree(ip_dx)
<          call ufree(ip_dy)
<          call ufree(ip_dz)
<          call ufree(ip_dthetx)
<          call ufree(ip_dthety)
<          call ufree(ip_dthetz)
<          call ufree(ip_isav_blk)
<          call ufree(ip_isav_prd)
<          call ufree(ip_isav_pat)
<          call ufree(ip_isav_pat_b)
<          call ufree(ip_isav_dpat)
<          call ufree(ip_isav_dpat_b)
<          call ufree(ip_isav_emb)
<          call ufree(ip_mblk2nd)
<          call ufree(ip_mglevg)
<          call ufree(ip_nemgl)
<          call ufree(ip_ipl3dtmp)
<          call ufree(ip_ifrom)
<          call ufree(ip_xif1)
<          call ufree(ip_etf1)
<          call ufree(ip_xif2)
<          call ufree(ip_etf2)
<          call ufree(ip_utrnsae)
<          call ufree(ip_vtrnsae)
<          call ufree(ip_wtrnsae)
<          call ufree(ip_omgxae)
<          call ufree(ip_omgyae)
<          call ufree(ip_omgzae)
<          call ufree(ip_xorgae)
<          call ufree(ip_yorgae)
<          call ufree(ip_zorgae)
<          call ufree(ip_xorgae0)
<          call ufree(ip_yorgae0)
<          call ufree(ip_zorgae0)
<          call ufree(ip_icouple)
<          call ufree(ip_thtxae)
<          call ufree(ip_thtyae)
<          call ufree(ip_thtzae)
<          call ufree(ip_rfrqtae)
<          call ufree(ip_rfrqrae)
<          call ufree(ip_icsi)
<          call ufree(ip_icsf)
<          call ufree(ip_jcsi)
<          call ufree(ip_jcsf)
<          call ufree(ip_kcsi)
<          call ufree(ip_kcsf)
<          call ufree(ip_idfrmseg)
<          call ufree(ip_iaesurf)
<          call ufree(ip_nsegdfrm)
<          call ufree(ip_freq)
<          call ufree(ip_gmass)
<          call ufree(ip_x0)
<          call ufree(ip_gf0)
<          call ufree(ip_damp)
<          call ufree(ip_perturb)
<          call ufree(ip_aesrfdat)
<          call ufree(ip_iskip)
<          call ufree(ip_jskip)
<          call ufree(ip_kskip)
---
>          deallocate(ltot)
>          deallocate(jjmax1)
>          deallocate(kkmax1)
>          deallocate(iiint1)
>          deallocate(iiint2)    
>          deallocate(n14)
>          deallocate(iwrk)
>          deallocate(icsinfo)
>          deallocate(iv)
>          deallocate(memblock)
>          deallocate(lwdat)
>          deallocate(nblfine)
>          deallocate(mem_req_node)
>          deallocate(no_of_points)
>          deallocate(lw)
>          deallocate(lw2)
>          deallocate(nblk)
>          deallocate(limblk)
>          deallocate(isva)
>          deallocate(nblon)
>          deallocate(lig)
>          deallocate(lbg)
>          deallocate(iovrlp)
>          deallocate(ibpntsg)
>          deallocate(iipntsg)
>          deallocate(rkap0g)
>          deallocate(levelg)
>          deallocate(igridg)
>          deallocate(iflimg)
>          deallocate(ifdsg)
>          deallocate(iviscg)
>          deallocate(jdimg)
>          deallocate(kdimg)
>          deallocate(idimg)
>          deallocate(idiagg)
>          deallocate(nblcg)
>          deallocate(idegg)
>          deallocate(jsg)
>          deallocate(ksg)
>          deallocate(isg)
>          deallocate(jeg)
>          deallocate(keg)
>          deallocate(ieg)
>          deallocate(mit)
>          deallocate(jlamlog)
>          deallocate(klamlog)
>          deallocate(ilamlog)
>          deallocate(jlamhig)
>          deallocate(klamhig)
>          deallocate(ilamhig)
>          deallocate(iwfg)
>          deallocate(utrans)
>          deallocate(vtrans)
>          deallocate(wtrans)
>          deallocate(omegax)
>          deallocate(omegay)
>          deallocate(omegaz)
>          deallocate(xorig)
>          deallocate(yorig)
>          deallocate(zorig)
>          deallocate(dxmx)
>          deallocate(dymx)
>          deallocate(dzmx)
>          deallocate(dthxmx)
>          deallocate(dthymx)
>          deallocate(dthzmx)
>          deallocate(thetax)
>          deallocate(thetay)
>          deallocate(thetaz)
>          deallocate(rfreqt)
>          deallocate(rfreqr)
>          deallocate(xorig0)
>          deallocate(yorig0)
>          deallocate(zorig0)
>          deallocate(time2)
>          deallocate(thetaxl)
>          deallocate(thetayl)
>          deallocate(thetazl)
>          deallocate(itrans)
>          deallocate(irotat)
>          deallocate(idefrm)
>          deallocate(bcvali)
>          deallocate(bcvalj)
>          deallocate(bcvalk)
>          deallocate(nbci0)
>          deallocate(nbcj0)
>          deallocate(nbck0)
>          deallocate(nbcidim)
>          deallocate(nbcjdim)
>          deallocate(nbckdim)
>          deallocate(ibcinfo)
>          deallocate(jbcinfo)
>          deallocate(kbcinfo)
>          deallocate(bcfilei)
>          deallocate(bcfilej)
>          deallocate(bcfilek)
>          deallocate(ncgg)
>          deallocate(nblg)
>          deallocate(iemg)
>          deallocate(inewgg)
>          deallocate(inpl3d)
>          deallocate(inpr)
>          deallocate(iadvance)
>          deallocate(iforce)
>          deallocate(iindex)
>          deallocate(iindx)
>          deallocate(llimit)
>          deallocate(iitmax)
>          deallocate(mmcxie)
>          deallocate(mmceta)
>          deallocate(ncheck)
>          deallocate(iifit)
>          deallocate(mblkpt)
>          deallocate(iic0)
>          deallocate(iiorph)
>          deallocate(iitoss)
>          deallocate(ifiner)
>          deallocate(dx)
>          deallocate(dy)
>          deallocate(dz)
>          deallocate(dthetx)
>          deallocate(dthety)
>          deallocate(dthetz)
>          deallocate(isav_blk)
>          deallocate(isav_prd)
>          deallocate(isav_pat)
>          deallocate(isav_pat_b)
>          deallocate(isav_dpat)
>          deallocate(isav_dpat_b)
>          deallocate(isav_emb)
>          deallocate(mblk2nd)
>          deallocate(mglevg)
>          deallocate(nemgl)
>          deallocate(ipl3dtmp)
>          deallocate(ifrom)
>          deallocate(xif1)
>          deallocate(etf1)
>          deallocate(xif2)
>          deallocate(etf2)
>          deallocate(utrnsae)
>          deallocate(vtrnsae)
>          deallocate(wtrnsae)
>          deallocate(omgxae)
>          deallocate(omgyae)
>          deallocate(omgzae)
>          deallocate(xorgae)
>          deallocate(yorgae)
>          deallocate(zorgae)
>          deallocate(xorgae0)
>          deallocate(yorgae0)
>          deallocate(zorgae0)
>          deallocate(icouple)
>          deallocate(thtxae)
>          deallocate(thtyae)
>          deallocate(thtzae)
>          deallocate(rfrqtae)
>          deallocate(rfrqrae)
>          deallocate(icsi)
>          deallocate(icsf)
>          deallocate(jcsi)
>          deallocate(jcsf)
>          deallocate(kcsi)
>          deallocate(kcsf)
>          deallocate(idfrmseg)
>          deallocate(iaesurf)
>          deallocate(nsegdfrm)
>          deallocate(freq)
>          deallocate(gmass)
>          deallocate(x0)
>          deallocate(gf0)
>          deallocate(damp)
>          deallocate(perturb)
>          deallocate(aesrfdat)
>          deallocate(iskip)
>          deallocate(jskip)
>          deallocate(kskip)
Index: source/cfl3d/dist/termn8.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/termn8.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
109c109
< #ifdef CRAY_TIME then
---
> #ifdef CRAY_TIME
111c111
< #   ifdef IBM then
---
> #   ifdef IBM
124a125,126
>       call flush_(96)
>       call flush_(97)
139a142,143
>       call flush(96)
>       call flush(97)
156a161,162
>          close(96)
>          close(97)
Index: source/cfl3d/dist/trnsfr_vals.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/trnsfr_vals.F,v
retrieving revision 1.3
retrieving revision 1.11
diff -r1.3 -r1.11
29c29
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
70c70
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
124c124,125
<      .                geom_img,surf_img
---
>      .                geom_img,surf_img,xrotrate_img,yrotrate_img,
>      .                zrotrate_img
125a127,129
>       common /des/ cdes,ides
>       common /cfl/ dt0,dtold
>       common /avgdata/ xnumavg,iteravg
164c168
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
167c171
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
173a178,179
>       common /noninertial/ xcentrot,ycentrot,zcentrot,xrotrate,
>      .                     yrotrate,zrotrate,noninflag
174a181,182
>       common /ivals/ p0,rho0,c0,u0,v0,w0,et0,h0,pt0,rhot0,qiv(5),
>      .        tur10,tur20
279a288
>          work(nlast+42) = dtold
281,283c290,292
<             work(nlast+41+j) = epsssc(j)
<             work(nlast+44+j) = epsssr(j)
<             work(nlast+47+j) = rkap0(j)
---
>             work(nlast+42+j) = epsssc(j)
>             work(nlast+45+j) = epsssr(j)
>             work(nlast+48+j) = rkap0(j)
285,286c294,295
<          work(nlast+51) = beta1
<          nlast = nlast + 51
---
>          work(nlast+52) = beta1
>          nlast = nlast + 52
378a388,405
>          work(nlast+39) = xcentrot
>          work(nlast+40) = ycentrot
>          work(nlast+41) = zcentrot
>          work(nlast+42) = xrotrate
>          work(nlast+43) = yrotrate
>          work(nlast+44) = zrotrate
>          work(nlast+45) = noninflag
>          work(nlast+46) = xrotrate_img
>          work(nlast+47) = yrotrate_img
>          work(nlast+48) = zrotrate_img
>          work(nlast+49) = itime2read
>          work(nlast+50) = itaturb
>          work(nlast+51) = ides
>          work(nlast+52) = cdes
>          work(nlast+53) = iteravg
>          work(nlast+54) = tur10
>          work(nlast+55) = tur20
>          work(nlast+56) = tur1cut
382c409
<       nvals = 30*maxbl + 42*maxbl*maxseg   + 51   + 11*nmds*maxaes
---
>       nvals = 30*maxbl + 42*maxbl*maxseg   + 52   + 11*nmds*maxaes
493a521
>          dtold    = work(nlast+42)
495,497c523,525
<             epsssc(j) = work(nlast+41+j)
<             epsssr(j) = work(nlast+44+j)
<             rkap0(j)  = work(nlast+47+j)
---
>             epsssc(j) = work(nlast+42+j)
>             epsssr(j) = work(nlast+45+j)
>             rkap0(j)  = work(nlast+48+j)
499,500c527,528
<          beta1    = work(nlast+51)
<          nlast = nlast + 51
---
>          beta1    = work(nlast+52)
>          nlast = nlast + 52
593c621,638
< 
---
>          xcentrot  = work(nlast+39)
>          ycentrot  = work(nlast+40)
>          zcentrot  = work(nlast+41)
>          xrotrate  = work(nlast+42)
>          yrotrate  = work(nlast+43)
>          zrotrate  = work(nlast+44)
>          noninflag = int(work(nlast+45))
>          xrotrate_img = work(nlast+46)
>          yrotrate_img = work(nlast+47)
>          zrotrate_img = work(nlast+48)
>          itime2read=int(work(nlast+49))
>          itaturb   =int(work(nlast+50))
>          ides      = int(work(nlast+51))
>          cdes      = work(nlast+52)
>          iteravg   = int(work(nlast+53))
>          tur10     = work(nlast+54)
>          tur20     = work(nlast+55)
>          tur1cut   = work(nlast+56)
Index: source/cfl3d/dist/updatedg.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/updatedg.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
16c16
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
102c102
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
257a258,319
>                  ist = icsi(nbl,is)
>                  ifn = icsf(nbl,is)
>                  jst = jcsi(nbl,is)
>                  jfn = jcsf(nbl,is)
>                  kst = kcsi(nbl,is)
>                  kfn = kcsf(nbl,is)
> c
> c              Are multiple segments defined. If yes increment start/end
> c              indices to eliminate doubling of displacement
> c
>                  if (jst .eq. jfn) then
>                   if(is.gt.1) then
>                    do is1 = 1,is-1
>                     if(jcsi(nbl,is1).eq.jst.and.jcsf(nbl,is1).
>      .                 eq.jst) then
>                      if(kcsf(nbl,is1).eq.kst) then
>                       kst = kst+1
>                      else if(kcsi(nbl,is1).eq.kfn) then
>                       kfn = kfn-1
>                      else if(icsf(nbl,is1).eq.ist) then
>                       ist = ist+1
>                      else if(icsi(nbl,is1).eq.ifn) then
>                       ifn = ifn-1
>                      end if
>                     end if
>                    enddo
>                   end if
>                  else if (kst .eq. kfn) then
>                   if(is.gt.1) then
>                    do is1 = 1,is-1
>                     if(kcsi(nbl,is1).eq.kst.and.kcsf(nbl,is1).
>      .                 eq.kst) then
>                      if(icsf(nbl,is1).eq.ist) then
>                       ist = ist+1
>                      else if(icsi(nbl,is1).eq.ifn) then
>                       ifn = ifn-1
>                      else if(jcsf(nbl,is1).eq.jst) then
>                       jst = jst+1
>                      else if(jcsi(nbl,is1).eq.jfn) then
>                       jfn = jfn-1
>                      end if
>                     end if
>                    enddo
>                   end if
>                  else if (ist .eq. ifn) then
>                   if(is.gt.1) then
>                    do is1 = 1,is-1
>                     if(icsi(nbl,is1).eq.ist.and.icsf(nbl,is1).
>      .                 eq.ist) then
>                      if(kcsf(nbl,is1).eq.kst) then
>                       kst = kst+1
>                      else if(kcsi(nbl,is1).eq.kfn) then
>                       kfn = kfn-1
>                      else if(jcsf(nbl,is1).eq.jst) then
>                       jst = jst+1
>                      else if(jcsi(nbl,is1).eq.jfn) then
>                       jfn = jfn-1
>                      end if
>                     end if
>                    enddo
>                   end if
>                  end if
279a342,403
>                  ist = icsi(nbl,is)
>                  ifn = icsf(nbl,is)
>                  jst = jcsi(nbl,is)
>                  jfn = jcsf(nbl,is)
>                  kst = kcsi(nbl,is)
>                  kfn = kcsf(nbl,is)
> c
> c              Are multiple segments defined. If yes increment start/end
> c              indices to eliminate doubling of displacement
> c
>                  if (jst .eq. jfn) then
>                   if(is.gt.1) then
>                    do is1 = 1,is-1
>                     if(jcsi(nbl,is1).eq.jst.and.jcsf(nbl,is1).
>      .                 eq.jst) then
>                      if(kcsf(nbl,is1).eq.kst) then
>                       kst = kst+1
>                      else if(kcsi(nbl,is1).eq.kfn) then
>                       kfn = kfn-1
>                      else if(icsf(nbl,is1).eq.ist) then
>                       ist = ist+1
>                      else if(icsi(nbl,is1).eq.ifn) then
>                       ifn = ifn-1
>                      end if
>                     end if
>                    enddo
>                   end if
>                  else if (kst .eq. kfn) then
>                   if(is.gt.1) then
>                    do is1 = 1,is-1
>                     if(kcsi(nbl,is1).eq.kst.and.kcsf(nbl,is1).
>      .                 eq.kst) then
>                      if(icsf(nbl,is1).eq.ist) then
>                       ist = ist+1
>                      else if(icsi(nbl,is1).eq.ifn) then
>                       ifn = ifn-1
>                      else if(jcsf(nbl,is1).eq.jst) then
>                       jst = jst+1
>                      else if(jcsi(nbl,is1).eq.jfn) then
>                       jfn = jfn-1
>                      end if
>                     end if
>                    enddo
>                   end if
>                 else if (ist .eq. ifn) then
>                   if(is.gt.1) then
>                    do is1 = 1,is-1
>                     if(icsi(nbl,is1).eq.ist.and.icsf(nbl,is1).
>      .                 eq.ist) then
>                      if(kcsf(nbl,is1).eq.kst) then
>                       kst = kst+1
>                      else if(kcsi(nbl,is1).eq.kfn) then
>                       kfn = kfn-1
>                      else if(jcsf(nbl,is1).eq.jst) then
>                       jst = jst+1
>                      else if(jcsi(nbl,is1).eq.jfn) then
>                       jfn = jfn-1
>                      end if
>                     end if
>                    enddo
>                   end if
>                  end if
Index: source/cfl3d/dist/updateg.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/updateg.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
12c12
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
69c69
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/dist/usrint.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/usrint.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
35c35
< #ifdef CRAY_TIME then
---
> #ifdef CRAY_TIME
37c37
< #   ifdef IBM then
---
> #   ifdef IBM
Index: source/cfl3d/dist/wrest.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/wrest.F,v
retrieving revision 1.3
retrieving revision 1.10
diff -r1.3 -r1.10
6,7d5
< c   ***CGNSstart
< c    .                 myid,myhost,mycomm,mblk2nd)
11,12c9
<      .                 nou,bou,nbuf,ibufdim)
< c   ***CGNSend
---
>      .                 nou,bou,nbuf,ibufdim,qavg,x,y,z)
14c11
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
61c58,59
< c   ***CGNSstart
---
>       dimension qavg(jdim-1,kdim-1,idim-1,5),x(jdim,kdim,idim),
>      .          y(jdim,kdim,idim),z(jdim,kdim,idim)
69d66
< c   ***CGNSend
80,81c77
<      .                  iwarneddy
< c   ***CGNSstart
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
90c86
< c   ***CGNSend
---
>       common /avgdata/ xnumavg,iteravg
112c108,109
<       itag_vi0   = itag_qk0   + ioffset
---
>       itag_blank = itag_qk0   + ioffset
>       itag_vi0   = itag_blank + ioffset
117a115
>       itag_qavg  = itag_tk0   + ioffset
138a137
>       jkim5 = jkim*5
160d158
< c   ***CGNSstart
168d165
< c   ***CGNSend
185d181
< c   ***CGNSstart
187d182
< c   ***CGNSend
204d198
< c   ***CGNSstart
236d229
< c   ***CGNSend
268a262,273
>       if ((icgns .eq. 1 .and. iover .eq. 1) .or. 
>      .    (iteravg .eq. 1 .or. iteravg .eq. 2)) then
>          if (myid .eq. mblk2nd(nbl)) then
>             mytag = itag_blank + nbl
>             call MPI_Send(blank,jki,MY_MPI_REAL,
>      .                    myhost,mytag,mycomm,ierr)
>          else if (myid .eq. myhost) then
>             mytag = itag_blank + nbl
>             call MPI_Recv(blank,jki,MY_MPI_REAL,
>      .                    nd_srce,mytag,mycomm,istat,ierr)
>          end if
>       end if
273d277
< c   ***CGNSstart
275d278
< c   ***CGNSend
281d283
< c   ***CGNSstart
284c286,296
<       write(11,'('' CGNS write in wrest'')')
---
>       write(11,'('' cgns write in wrest'')')
>       if (iwghost .ne. 0) then
>         write(11,'('' cgns writing specific BC values (primitive)'')')
>         call writebcs(iccg,ibase,igrid,idim,jdim,kdim,qj0,qk0,qi0,
>      +    vj0,vk0,vi0,tj0,tk0,ti0,i2d)
>       else
> c       need to delete CFL3DBoundaryValues node if it exists
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,'end')
>         call cg_delete_node_f('CFL3DBoundaryValues',ier)
>       end if
>       write(11,'(''  ...writing conserved q variables'')')
296c308
<         do m=1,4
---
>         do m=1,3,2
313c325
<       do m=1,4
---
>       do m=1,3,2
325,357c337
<      +  jdim,kdim,wk,q,qj0,qk0,qi0,bcj,bck,bci,i2d,nsoluse)
< c     write overset holes
<       if (iover .eq. 1) then
< c     first, find out how many holes
<         n=0
<         do k=1,kdim-1
<         do j=1,jdim-1
<         do i=1,idim-1
<           if(blank(j,k,i) .eq. 0.) then
<             n=n+1
<           end if
<         enddo
<         enddo
<         enddo
<         npnts=n
<         if (npnts .gt. 0) then
<         if (iwork .lt. npnts*3) then
<           write(11,'('' not enough memory for CGNS blank'',
<      +      '' write.'')')
<           write(11,'('' iwork in iwk='',i6,''.  Needed = '',i6)')
<      +      iwork,npnts*3
<           call termn8(myid,-1,ibufdim,nbuf,bou,nou)
<         end if
<         call writeblnk(iccg,ibase,igrid,idim,jdim,kdim,npnts,iwk,
<      .                     blank)
<         end if
<       end if
<       call writeziter(iccg,ibase,igrid)
<       if (iwghost .ne. 0) then
<         write(11,'('' CGNS writing specific BC values'')')
<         call writebcs(iccg,ibase,igrid,idim,jdim,kdim,qj0,qk0,qi0,
<      +    vj0,vk0,vi0,tj0,tk0,ti0,i2d)
<       end if
---
>      +  jdim,kdim,wk,q,qj0,qk0,qi0,bcj,bck,bci,i2d,ialph,nsoluse)
369c349
<         do m=1,4
---
>         do m=1,3,2
386c366
<       do m=1,4
---
>       do m=1,3,2
396a377,403
> c     write overset holes
>       if (iover .eq. 1) then
> c     first, find out how many holes
>         n=0
>         do k=1,kdim-1
>         do j=1,jdim-1
>         do i=1,idim-1
>           if(blank(j,k,i) .eq. 0.) then
>             n=n+1
>           end if
>         enddo
>         enddo
>         enddo
>         npnts=n
>         if (npnts .gt. 0) then
>         if (iwork .lt. npnts*3) then
>           write(11,'('' not enough memory for cgns blank'',
>      +      '' write.'')')
>           write(11,'('' iwork in iwk='',i6,''.  Needed = '',i6)')
>      +      iwork,npnts*3
>           call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>         end if
>         call writeblnk(iccg,ibase,igrid,idim,jdim,kdim,npnts,iwk,
>      .                     blank)
>         end if
>       end if
>       call writeziter(iccg,ibase,igrid)
406c413
<         call writetime(iccg,ibase,time,ntt)
---
>         call writetime(iccg,ibase,time,ntt,dt)
410d416
< c   ***CGNSend
414d419
< c   ***CGNSstart
416d420
< c   ***CGNSend
419,424d422
< c   ***CGNSstart
< c     do n=1,ntt
< c       if(real(rmstr1(n)) .le. 0.) rmstr1(n)=1.
< c       if(real(rmstr2(n)) .le. 0.) rmstr2(n)=1.
< c     enddo
< c   ***CGNSend
429d426
< c   ***CGNSstart
431d427
< c   ***CGNSend
496d491
< c   ***CGNSstart
498d492
< c   ***CGNSend
506d499
< c   ***CGNSstart
508d500
< c   ***CGNSend
562d553
< c   ***CGNSstart
564d554
< c   ***CGNSend
574d563
< c   ***CGNSstart
576d564
< c   ***CGNSend
596d583
< c   ***CGNSstart
598d584
< c   ***CGNSend
600d585
< c   ***CGNSstart
602d586
< c   ***CGNSend
627d610
< c   ***CGNSstart
629d611
< c   ***CGNSend
631d612
< c   ***CGNSstart
633d613
< c   ***CGNSend
651d630
< c   ***CGNSstart
653d631
< c   ***CGNSend
655d632
< c   ***CGNSstart
657d633
< c   ***CGNSend
675d650
< c   ***CGNSstart
677d651
< c   ***CGNSend
679d652
< c   ***CGNSstart
681d653
< c   ***CGNSend
704d675
< c   ***CGNSstart
706d676
< c   ***CGNSend
708d677
< c   ***CGNSstart
710d678
< c   ***CGNSend
713d680
< c   ***CGNSstart
724c691,793
< c   ***CGNSend
---
>       if (iteravg .eq. 1 .or. iteravg .eq. 2) then
> c
> #if defined DIST_MPI
> c
>          if (myid .eq. mblk2nd(nbl)) then
>             mytag = itag_cmuv + nbl
>             call MPI_Send(x,jki,MY_MPI_REAL,
>      .                    myhost,mytag,mycomm,ierr)
>          else if (myid .eq. myhost) then
>             mytag = itag_cmuv + nbl
>             call MPI_Recv(x,jki,MY_MPI_REAL,
>      .                    nd_srce,mytag,mycomm,istat,ierr)
>          end if
> c
>          if (myid .eq. mblk2nd(nbl)) then
>             mytag = itag_cmuv + nbl
>             call MPI_Send(y,jki,MY_MPI_REAL,
>      .                    myhost,mytag,mycomm,ierr)
>          else if (myid .eq. myhost) then
>             mytag = itag_cmuv + nbl
>             call MPI_Recv(y,jki,MY_MPI_REAL,
>      .                    nd_srce,mytag,mycomm,istat,ierr)
>          end if
> c
>          if (myid .eq. mblk2nd(nbl)) then
>             mytag = itag_cmuv + nbl
>             call MPI_Send(z,jki,MY_MPI_REAL,
>      .                    myhost,mytag,mycomm,ierr)
>          else if (myid .eq. myhost) then
>             mytag = itag_cmuv + nbl
>             call MPI_Recv(z,jki,MY_MPI_REAL,
>      .                    nd_srce,mytag,mycomm,istat,ierr)
>          end if
> c
>          if (myid .eq. mblk2nd(nbl)) then
>             mytag = itag_qavg + nbl
>             call MPI_Send(qavg,jkim5,MY_MPI_REAL,
>      .                    myhost,mytag,mycomm,ierr)
>          else if (myid .eq. myhost) then
>             mytag = itag_qavg + nbl
>             call MPI_Recv(qavg,jkim5,MY_MPI_REAL,
>      .                    nd_srce,mytag,mycomm,istat,ierr)
>          end if
> c
> #endif
> c
> c   write cell-centered plot3d files of current grid and averaged q's
>         if (myid .eq. myhost) then
>         if (ialph .eq. 0) then
>         write(96)   (((0.125*(x(j  ,k  ,i  )+x(j+1,k  ,i  )+
>      +                        x(j  ,k+1,i  )+x(j  ,k  ,i+1)+
>      +                        x(j+1,k+1,i  )+x(j+1,k  ,i+1)+
>      +                        x(j  ,k+1,i+1)+x(j+1,k+1,i+1)),
>      +                        i=1,idim-1),j=1,jdim-1),k=1,kdim-1),
>      +              (((0.125*(y(j  ,k  ,i  )+y(j+1,k  ,i  )+
>      +                        y(j  ,k+1,i  )+y(j  ,k  ,i+1)+
>      +                        y(j+1,k+1,i  )+y(j+1,k  ,i+1)+
>      +                        y(j  ,k+1,i+1)+y(j+1,k+1,i+1)),
>      +                        i=1,idim-1),j=1,jdim-1),k=1,kdim-1),
>      +              (((0.125*(z(j  ,k  ,i  )+z(j+1,k  ,i  )+
>      +                        z(j  ,k+1,i  )+z(j  ,k  ,i+1)+
>      +                        z(j+1,k+1,i  )+z(j+1,k  ,i+1)+
>      +                        z(j  ,k+1,i+1)+z(j+1,k+1,i+1)),
>      +                        i=1,idim-1),j=1,jdim-1),k=1,kdim-1),
>      +              (((int(blank(j,k,i)),
>      +                        i=1,idim-1),j=1,jdim-1),k=1,kdim-1)
>         else
>         write(96)   (((0.125*(x(j  ,k  ,i  )+x(j+1,k  ,i  )+
>      +                        x(j  ,k+1,i  )+x(j  ,k  ,i+1)+
>      +                        x(j+1,k+1,i  )+x(j+1,k  ,i+1)+
>      +                        x(j  ,k+1,i+1)+x(j+1,k+1,i+1)),
>      +                        i=1,idim-1),j=1,jdim-1),k=1,kdim-1),
>      +              (((0.125*(z(j  ,k  ,i  )+z(j+1,k  ,i  )+
>      +                        z(j  ,k+1,i  )+z(j  ,k  ,i+1)+
>      +                        z(j+1,k+1,i  )+z(j+1,k  ,i+1)+
>      +                        z(j  ,k+1,i+1)+z(j+1,k+1,i+1)),
>      +                        i=1,idim-1),j=1,jdim-1),k=1,kdim-1),
>      +              (((-0.125*(y(j  ,k  ,i  )+y(j+1,k  ,i  )+
>      +                        y(j  ,k+1,i  )+y(j  ,k  ,i+1)+
>      +                        y(j+1,k+1,i  )+y(j+1,k  ,i+1)+
>      +                        y(j  ,k+1,i+1)+y(j+1,k+1,i+1)),
>      +                        i=1,idim-1),j=1,jdim-1),k=1,kdim-1),
>      +              (((int(blank(j,k,i)),
>      +                        i=1,idim-1),j=1,jdim-1),k=1,kdim-1)
>         end if
> c   need to switch y and z if ialph .ne. 0
>         if (ialph .ne. 0) then
>           do i=1,idim-1
>             do j=1,jdim-1
>               do k=1,kdim-1
>                 temp=qavg(j,k,i,3)
>                 qavg(j,k,i,3)=qavg(j,k,i,4)
>                 qavg(j,k,i,4)=-temp
>               enddo
>             enddo
>           enddo
>         end if
> c   xnumavg is used to store the number of averaged iterations so far
>         write(97) xmach,alpha,reue,xnumavg
>         write(97) ((((qavg(j,k,i,m),i=1,idim-1),j=1,jdim-1),
>      +    k=1,kdim-1),m=1,5) 
>         end if
>       end if
Index: source/cfl3d/dist/wrestg.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/wrestg.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
14,17c14
< c   ***CGNSstart
< c    .                  wk,nwork)
<      .                  wk,nwork,idima,jdima,kdima,igrid)
< c   ***CGNSend
---
>      .                  wk,nwork,idima,jdima,kdima,igrid,tursav2)
19c16
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
53c50
<       dimension qc0(jdim,kdim,idim-1,5)
---
>       dimension qc0(jdim,kdim,idim-1,5),tursav2(jdim,kdim,idim,4)
95c92
< c   ***CGNSstart
---
>       common /igrdtyp/ ip3dgrd,ialph
98d94
< c   ***CGNSend
111c107,108
<       itag_dmdat = itag_qc0   + ioffset
---
>       itag_tursav= itag_qc0   + ioffset
>       itag_dmdat = itag_tursav+ ioffset
141a139,147
>          jki4 = jdim*kdim*idim*4
>          mytag = itag_tursav + nbl
>          if (myid .eq. mblk2nd(nbl)) then
>             call MPI_Send(tursav2,jki4,MY_MPI_REAL,
>      .                    myhost,mytag,mycomm,ierr)
>          else if (myid .eq. myhost) then
>             call MPI_Recv(tursav2,jki4,MY_MPI_REAL,
>      .                    nd_srce,mytag,mycomm,istat,ierr)
>          end if
145d150
< c   ***CGNSstart
147d151
< c   ***CGNSend
155c159,163
< c   ***CGNSstart
---
>             write(2) dt
> c   only need to store old values of turb quantities (j,k,i,1) and
> c   (j,k,i,2), NOT the deltaQ's = (j,k,i,3) and (j,k,i,4):
>             write(2) ((((tursav2(j,k,i,l),j=1,jdim1),k=1,kdim1),
>      .                   i=1,idim1),l=1,2)
158c166
<          write(11,'('' writing 2nd order time data to CGNS file,'',
---
>          write(11,'('' writing 2nd order time data to cgns file,'',
161c169
<      +                jdim,kdim,wk,qc0,nsoluse,i2d)
---
>      +                jdim,kdim,wk,qc0,tursav2,nsoluse,i2d,ialph)
164d171
< c   ***CGNSend
174d180
< c   ***CGNSstart
176d181
< c   ***CGNSend
178d182
< c   ***CGNSstart
180d183
< c   ***CGNSend
186d188
< c   ***CGNSstart
188d189
< c   ***CGNSend
194d194
< c   ***CGNSstart
196d195
< c   ***CGNSend
236d234
< c   ***CGNSstart
238d235
< c   ***CGNSend
251d247
< c   ***CGNSstart
254c250
<               write(11,'('' writing dynamic mesh data to CGNS file,'',
---
>               write(11,'('' writing dynamic mesh data to cgns file,'',
269c265
<      .                  dthzmxmc,time2(nbl),time2mc,dt)
---
>      .                  dthzmxmc,time2(nbl),time2mc,dt,ialph)
272d267
< c   ***CGNSend
338d332
< c   ***CGNSstart
340d333
< c   ***CGNSend
373d365
< c   ***CGNSstart
376c368
<                 write(11,'('' writing deforming mesh data to CGNS'',
---
>                 write(11,'('' writing deforming mesh data to cgns'',
386,387c378,379
<      .            jcsf(nbl,1),kcsi(nbl,1),kcsf(nbl,1),jdim,kdim,idim,
<      .            x,y,z,xnm2,ynm2,znm2,wk)
---
>      .            jcsf(nbl,1),kcsi(nbl,1),kcsf(nbl,1),jdima,kdima,idima,
>      .            jdim,kdim,idim,x,y,z,xnm2,ynm2,znm2,wk,ialph,i2d)
396,397c388,389
<      .            jcsf(nbl,1),kcsi(nbl,1),kcsf(nbl,1),jdim,kdim,idim,
<      .            x,y,z,x,y,z,wk)
---
>      .            jcsf(nbl,1),kcsi(nbl,1),kcsf(nbl,1),jdima,kdima,idima,
>      .            jdim,kdim,idim,x,y,z,x,y,z,wk,ialph,i2d)
401d392
< c   ***CGNSend
Index: source/cfl3d/dist/yplusout.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/dist/yplusout.F,v
retrieving revision 1.4
retrieving revision 1.8
diff -r1.4 -r1.8
10c10
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
46c46
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
60c60
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
408a409,411
>             if (real(ypavt) .gt. 2.5) then
>                write(11,114)
>             end if
459a463,469
>   114 format(/,1x,'WARNING: avg y+ is > 2.5.  It is recommended that',
>      .         1x,'you revise the grid',
>      .       /,1x,'to have smaller min spacing at walls.  (If you',
>      .         1x,'are employing WALL FUNCTIONS,',
>      .       /,1x,'large avg y+ values are acceptable, but wall',
>      .         1x,'functions are ad hoc',
>      .       /,1x,'and not recommended for general use.)')
Index: source/cfl3d/libs/aesurf.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/aesurf.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
59a60,79
> c              Are multiple segments defined. If yes increment start/end
> c              indices to eliminate doubling of displacement
> c
>                if(is.gt.1) then
>                 do is1 = 1,is-1
>                  if(jcsi(nbl,is1).eq.jcsi(nbl,is).and.jcsf(nbl,is1).eq.
>      .              jcsi(nbl,is)) then
>                     if(kcsf(nbl,is1).eq.kst) then
>                       kst = kst+1
>                     else if(kcsi(nbl,is1).eq.kfn) then
>                       kfn = kfn-1
>                     else if(icsf(nbl,is1).eq.ist) then
>                       ist = ist+1
>                     else if(icsi(nbl,is1).eq.ifn) then
>                       ifn = ifn-1
>                     end if
>                  end if
>                 enddo
>                end if
> c
103a124,143
> c              Are multiple segments defined. If yes increment start/end
> c              indices to eliminate doubling of displacement
> c
>                if(is.gt.1) then
>                 do is1 = 1,is-1
>                  if(kcsi(nbl,is1).eq.kcsi(nbl,is).and.kcsf(nbl,is1).eq.
>      .              kcsi(nbl,is)) then
>                     if(icsf(nbl,is1).eq.ist) then
>                       ist = ist+1
>                     else if(icsi(nbl,is1).eq.ifn) then
>                       ifn = ifn-1
>                     else if(jcsf(nbl,is1).eq.jst) then
>                       jst = jst+1
>                     else if(jcsi(nbl,is1).eq.jfn) then
>                       jfn = jfn-1
>                     end if
>                  end if
>                 enddo
>                end if
> c
146a187,206
> c
> c              Are multiple segments defined. If yes increment start/end
> c              indices to eliminate doubling of displacement
> c
>                if(is.gt.1) then
>                 do is1 = 1,is-1
>                  if(icsi(nbl,is1).eq.icsi(nbl,is).and.icsf(nbl,is1).eq.
>      .              icsi(nbl,is)) then
>                     if(kcsf(nbl,is1).eq.kst) then
>                       kst = kst+1
>                     else if(kcsi(nbl,is1).eq.kfn) then
>                       kfn = kfn-1
>                     else if(jcsf(nbl,is1).eq.jst) then
>                       jst = jst+1
>                     else if(jcsi(nbl,is1).eq.jfn) then
>                       jfn = jfn-1
>                     end if
>                  end if
>                 enddo
>                end if
Index: source/cfl3d/libs/barth3d.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/barth3d.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
34c34,35
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
>       common /unst/ time,cfltau,ntstep,ita,iunst
55c56
<       dimension tursav2(jdim,kdim,idim,2)
---
>       dimension tursav2(jdim,kdim,idim,4)
78a80,102
>       phi=0.
>       if (real(dt) .gt. 0.) then
>         if (abs(ita) .eq. 2) then
>           phi=0.5
>         else
>           phi=0.
>         end if
> c   revert to old way (always 1st order for turb model) if itaturb=0
>         if (itaturb .eq. 0) then
>           phi=0.
>           if (isklton .gt. 0) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),'(''   turb model is 1st'',
>      +       '' order in time'')')
>           end if
>         else
>           if (isklton .gt. 0) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),'(''   turb model is same'',
>      +       '' order in time as mean flow eqns'')')
>           end if
>         end if
>       end if
189a214,216
> c tursav2(j,k,i,1) and (j,k,i,2) are turb quantities
> c tursav2(j,k,i,3) and (j,k,i,4) are Delta turb quantities
> c (in BB, only (j,k,i,1) and (j,k,i,3) are used)
190a218,239
>       if (abs(ita) .eq. 2) then
> c     if tursav2 at 1st point is zero, then we know that we do not have
> c     2nd order data from the restart; no choice but to set
> c     tursav2(j,k,i,3)=deltaQ=0 for 1st iteration
>         if (real(tursav2(1,1,1,1)) .eq. 0.) then
>         do i=1,idim-1
>           do k=1,kdim-1
>             do j=1,jdim-1
>               tursav2(j,k,i,3)=0.
>             enddo
>           enddo
>         enddo
>         else
>         do i=1,idim-1
>           do k=1,kdim-1
>             do j=1,jdim-1
>               tursav2(j,k,i,3)=tursav(j,k,i,1)-tursav2(j,k,i,1)
>             enddo
>           enddo
>         enddo
>         end if
>       end if
849c898
<               cy(j,k)=cy(j,k)*fact+1.0
---
>               cy(j,k)=cy(j,k)*fact+1.0*(1.+phi)
855c904,905
<                 fy(j,k)=fy(j,k)+tursav2(j,k,i,1)-turre(j,k,i)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(tursav2(j,k,i,1)-turre(j,k,i))
>      +                 +phi*tursav2(j,k,i,3)
921c971
<               cy(j,k)=cy(j,k)*fact+1.0
---
>               cy(j,k)=cy(j,k)*fact+1.0*(1.+phi)
927c977,978
<                 fy(j,k)=fy(j,k)+tursav2(j,k,i,1)-turre(j,k,i)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(tursav2(j,k,i,1)-turre(j,k,i))
>      +                 +phi*tursav2(j,k,i,3)
992c1043
<               cy(j,k)=cy(j,k)*fact+1.0
---
>               cy(j,k)=cy(j,k)*fact+1.0*(1.+phi)
998c1049,1050
<                 fy(j,k)=fy(j,k)+tursav2(j,k,i,1)-turre(j,k,i)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(tursav2(j,k,i,1)-turre(j,k,i))
>      +                 +phi*tursav2(j,k,i,3)
1082c1134
<               cx(k,j)=cx(k,j)*fact+1.0
---
>               cx(k,j)=cx(k,j)*fact+1.0*(1.+phi)
1084c1136
<               fx(k,j)=vist3d(j,k,i)
---
>               fx(k,j)=vist3d(j,k,i)*(1.+phi)
1149c1201
<               cx(k,j)=cx(k,j)*fact+1.0
---
>               cx(k,j)=cx(k,j)*fact+1.0*(1.+phi)
1151c1203
<               fx(k,j)=vist3d(j,k,i)
---
>               fx(k,j)=vist3d(j,k,i)*(1.+phi)
1215c1267
<               cx(k,j)=cx(k,j)*fact+1.0
---
>               cx(k,j)=cx(k,j)*fact+1.0*(1.+phi)
1217c1269
<               fx(k,j)=vist3d(j,k,i)
---
>               fx(k,j)=vist3d(j,k,i)*(1.+phi)
1301c1353
<                 cz(k,i)=cz(k,i)*fact+1.0
---
>                 cz(k,i)=cz(k,i)*fact+1.0*(1.+phi)
1303c1355
<                 fz(k,i)=vist3d(j,k,i)
---
>                 fz(k,i)=vist3d(j,k,i)*(1.+phi)
1368c1420
<                 cz(k,i)=cz(k,i)*fact+1.0
---
>                 cz(k,i)=cz(k,i)*fact+1.0*(1.+phi)
1370c1422
<                 fz(k,i)=vist3d(j,k,i)
---
>                 fz(k,i)=vist3d(j,k,i)*(1.+phi)
1434c1486
<                 cz(k,i)=cz(k,i)*fact+1.0
---
>                 cz(k,i)=cz(k,i)*fact+1.0*(1.+phi)
1436c1488
<                 fz(k,i)=vist3d(j,k,i)
---
>                 fz(k,i)=vist3d(j,k,i)*(1.+phi)
Index: source/cfl3d/libs/bc.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/bc.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
53c53
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
55a56,57
>       common /noninertial/ xcentrot,ycentrot,zcentrot,xrotrate,
>      .                     yrotrate,zrotrate,noninflag
128a131,135
> c      bc2008 - specify rho, u, v, and w; extrapolate p from the interior.
> c      bc2009 - nozzle total BCs: set ndata =4 and specify
> c               total pressure ratio (Ptotal/pinf), total temperature ratio
> c               (Ttotal/tinf), and flow directions (alpe and betae, in degrees)
> c               at the inlet; pressure is extrapolated from the interior.
352a360,368
> c     noninertial boundary conditions
>       if (ibcinfo(nbl,nseg,1,1).eq.1000.and.noninflag.gt.0) then
>         call bcnonin(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  w(lxtbj),w(lxtbk),w(lxtbi),w(latbj),w(latbk),w(latbi),
>      .  ista,iend,jsta,jend,ksta,kend,1,w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),iuns,nou,bou,nbuf,ibufdim,
>      .  w(lx),w(ly),w(lz),nbl)
>       endif
455a472,479
>       if (ibcinfo(nbl,nseg,1,1).eq.2009)
>      .  call bc2009(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  ista,iend,jsta,jend,ksta,kend,1,
>      .  w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),mdim,ndim,w(ldata),filname,iuns,
>      .  nou,bou,nbuf,ibufdim,myid)
> c
526a551,559
> c     noninertial boundary conditions
>       if (ibcinfo(nbl,nseg,1,2).eq.1000.and.noninflag.gt.0) then
>         call bcnonin(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  w(lxtbj),w(lxtbk),w(lxtbi),w(latbj),w(latbk),w(latbi),
>      .  ista,iend,jsta,jend,ksta,kend,2,w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),iuns,nou,bou,nbuf,ibufdim,
>      .  w(lx),w(ly),w(lz),nbl)
>       endif
629a663,670
>       if (ibcinfo(nbl,nseg,1,2).eq.2009)
>      .  call bc2009(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  ista,iend,jsta,jend,ksta,kend,2,
>      .  w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),mdim,ndim,w(ldata),filname,iuns,
>      .  nou,bou,nbuf,ibufdim,myid)
> c
700a742,750
> c     noninertial boundary conditions
>       if (jbcinfo(nbl,nseg,1,1).eq.1000.and.noninflag.gt.0) then
>         call bcnonin(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  w(lxtbj),w(lxtbk),w(lxtbi),w(latbj),w(latbk),w(latbi),
>      .  ista,iend,jsta,jend,ksta,kend,3,w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),iuns,nou,bou,nbuf,ibufdim,
>      .  w(lx),w(ly),w(lz),nbl)
>       endif
803a854,861
>       if (jbcinfo(nbl,nseg,1,1).eq.2009)
>      .  call bc2009(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  ista,iend,jsta,jend,ksta,kend,3,
>      .  w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),mdim,ndim,w(ldata),filname,iuns,
>      .  nou,bou,nbuf,ibufdim,myid)
> c
874a933,941
> c     noninertial boundary conditions
>       if (jbcinfo(nbl,nseg,1,2).eq.1000.and.noninflag.gt.0) then
>         call bcnonin(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  w(lxtbj),w(lxtbk),w(lxtbi),w(latbj),w(latbk),w(latbi),
>      .  ista,iend,jsta,jend,ksta,kend,4,w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),iuns,nou,bou,nbuf,ibufdim,
>      .  w(lx),w(ly),w(lz),nbl)
>       endif
977a1045,1052
>       if (jbcinfo(nbl,nseg,1,2).eq.2009)
>      .  call bc2009(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  ista,iend,jsta,jend,ksta,kend,4,
>      .  w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),mdim,ndim,w(ldata),filname,iuns,
>      .  nou,bou,nbuf,ibufdim,myid)
> c
1048a1124,1132
> c     noninertial boundary conditions
>       if (kbcinfo(nbl,nseg,1,1).eq.1000.and.noninflag.gt.0) then
>         call bcnonin(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  w(lxtbj),w(lxtbk),w(lxtbi),w(latbj),w(latbk),w(latbi),
>      .  ista,iend,jsta,jend,ksta,kend,5,w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),iuns,nou,bou,nbuf,ibufdim,
>      .  w(lx),w(ly),w(lz),nbl)
>       endif
1151a1236,1243
>       if (kbcinfo(nbl,nseg,1,1).eq.2009)
>      .  call bc2009(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  ista,iend,jsta,jend,ksta,kend,5,
>      .  w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),mdim,ndim,w(ldata),filname,iuns,
>      .  nou,bou,nbuf,ibufdim,myid)
> c
1222a1315,1323
> c     noninertial boundary conditions
>       if (kbcinfo(nbl,nseg,1,2).eq.1000.and.noninflag.gt.0) then
>         call bcnonin(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  w(lxtbj),w(lxtbk),w(lxtbi),w(latbj),w(latbk),w(latbi),
>      .  ista,iend,jsta,jend,ksta,kend,6,w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),iuns,nou,bou,nbuf,ibufdim,
>      .  w(lx),w(ly),w(lz),nbl)
>       endif
1321a1423,1430
>      .  w(lxib),w(ltj0),w(ltk0),w(lti0),
>      .  w(lvis),w(lvj0),w(lvk0),w(lvi0),mdim,ndim,w(ldata),filname,iuns,
>      .  nou,bou,nbuf,ibufdim,myid)
> c
>       if (kbcinfo(nbl,nseg,1,2).eq.2009)
>      .  call bc2009(jdim,kdim,idim,w(lq),w(lqj0),w(lqk0),w(lqi0),
>      .  w(lsj),w(lsk),w(lsi),w(lbcj),w(lbck),w(lbci),
>      .  ista,iend,jsta,jend,ksta,kend,6,
Index: source/cfl3d/libs/bc2006.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/bc2006.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
249c249
<             ie   = iend - 1
---
>             ie   = iend
341c341
<             ke   = kend - 1
---
>             ke   = kend
543c543
<             ie   = iend - 1
---
>             ie   = iend
635c635
<             ke   = kend - 1
---
>             ke   = kend
836c836
<             ie   = iend - 1
---
>             ie   = iend
928c928
<             je   = jend - 1
---
>             je   = jend
1130c1130
<             ie   = iend - 1
---
>             ie   = iend
1222c1222
<             je   = jend - 1
---
>             je   = jend
1425c1425
<             je   = jend - 1
---
>             je   = jend
1517c1517
<             ke   = kend - 1
---
>             ke   = kend
1719c1719
<             je   = jend - 1
---
>             je   = jend
1811c1811
<             ke   = kend - 1
---
>             ke   = kend
Index: source/cfl3d/libs/bc2007.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/bc2007.F,v
retrieving revision 1.4
retrieving revision 1.5
diff -r1.4 -r1.5
7c7
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
415c415
<             write(bou(nou(1),1),1003)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1003)ista,iend,jsta,jend
562c562
<             write(bou(nou(1),1),1004)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1004)ista,iend,jsta,jend
709c709
<             write(bou(nou(1),1),1005)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1005)jsta,jend,ksta,kend
856c856
<             write(bou(nou(1),1),1006)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1006)jsta,jend,ksta,kend
Index: source/cfl3d/libs/bc2008.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/bc2008.F,v
retrieving revision 1.4
retrieving revision 1.5
diff -r1.4 -r1.5
7c7
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
395c395
<             write(bou(nou(1),1),1003)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1003)ista,iend,jsta,jend
535c535
<             write(bou(nou(1),1),1004)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1004)ista,iend,jsta,jend
675c675
<             write(bou(nou(1),1),1005)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1005)jsta,jend,ksta,kend
815c815
<             write(bou(nou(1),1),1006)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1006)jsta,jend,ksta,kend
Index: source/cfl3d/libs/bc_info.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/bc_info.F,v
retrieving revision 1.2
retrieving revision 1.7
diff -r1.2 -r1.7
12c12
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
53c53
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
148a149,153
>       if (ibcinfo(nbl,nseg,1,1).eq.2009)
>      .  call out2009(jdim,kdim,idim,ista,iend,jsta,jend,ksta,kend,1,
>      .  nou,bou,nbuf,ibufdim,mdim,ndim,w(ldata),filname,myid,mblk2nd,
>      .  maxbl)
> c
279a285,289
>       if (ibcinfo(nbl,nseg,1,2).eq.2009)
>      .  call out2009(jdim,kdim,idim,ista,iend,jsta,jend,ksta,kend,2,
>      .  nou,bou,nbuf,ibufdim,mdim,ndim,w(ldata),filname,myid,mblk2nd,
>      .  maxbl)
> c
409a420,424
>       if (jbcinfo(nbl,nseg,1,1).eq.2009)
>      .  call out2009(jdim,kdim,idim,ista,iend,jsta,jend,ksta,kend,3,
>      .  nou,bou,nbuf,ibufdim,mdim,ndim,w(ldata),filname,myid,mblk2nd,
>      .  maxbl)
> c
539a555,559
>       if (jbcinfo(nbl,nseg,1,2).eq.2009)
>      .  call out2009(jdim,kdim,idim,ista,iend,jsta,jend,ksta,kend,4,
>      .  nou,bou,nbuf,ibufdim,mdim,ndim,w(ldata),filname,myid,mblk2nd,
>      .  maxbl)
> c
669a690,694
>       if (kbcinfo(nbl,nseg,1,1).eq.2009)
>      .  call out2009(jdim,kdim,idim,ista,iend,jsta,jend,ksta,kend,5,
>      .  nou,bou,nbuf,ibufdim,mdim,ndim,w(ldata),filname,myid,mblk2nd,
>      .  maxbl)
> c
799a825,829
>       if (kbcinfo(nbl,nseg,1,2).eq.2009)
>      .  call out2009(jdim,kdim,idim,ista,iend,jsta,jend,ksta,kend,6,
>      .  nou,bou,nbuf,ibufdim,mdim,ndim,w(ldata),filname,myid,mblk2nd,
>      .  maxbl)
> c
1460a1491,1493
>       common /noninertial/ xcentrot,ycentrot,zcentrot,xrotrate,
>      .                     yrotrate,zrotrate,noninflag
> c
1463a1497,1500
>       if (noninflag .gt. 0) then
>          nou(1) = min(nou(1)+1,ibufdim)
>          write(bou(nou(1),1),2001) ista,iend,ksta,kend
>       end if
1468a1506,1509
>       if (noninflag .gt. 0) then
>          nou(1) = min(nou(1)+1,ibufdim)
>          write(bou(nou(1),1),2002) ista,iend,ksta,kend
>       end if
1473a1515,1518
>       if (noninflag .gt. 0) then
>          nou(1) = min(nou(1)+1,ibufdim)
>          write(bou(nou(1),1),2003) ista,iend,jsta,jend
>       end if
1478a1524,1527
>       if (noninflag .gt. 0) then
>          nou(1) = min(nou(1)+1,ibufdim)
>          write(bou(nou(1),1),2004) ista,iend,jsta,jend
>       end if
1483a1533,1536
>       if (noninflag .gt. 0) then
>          nou(1) = min(nou(1)+1,ibufdim)
>          write(bou(nou(1),1),2005) jsta,jend,ksta,kend
>       end if
1488a1542,1545
>       if (noninflag .gt. 0) then
>          nou(1) = min(nou(1)+1,ibufdim)
>          write(bou(nou(1),1),2006) jsta,jend,ksta,kend
>       end if
1503a1561,1573
>  2001 format(' ','  j=   1  NONINERTIAL freestream         type 1000',
>      .       '  i=',i3,',',i3,'  k=',i3,',',i3)
>  2002 format(' ','  j=jdim  NONINERTIAL freestream         type 1000',
>      .       '  i=',i3,',',i3,'  k=',i3,',',i3)
>  2003 format(' ','  k=   1  NONINERTIAL freestream         type 1000',
>      .       '  i=',i3,',',i3,'  j=',i3,',',i3)
>  2004 format(' ','  k=kdim  NONINERTIAL freestream         type 1000',
>      .       '  i=',i3,',',i3,'  j=',i3,',',i3)
>  2005 format(' ','  i=   1  NONINERTIAL freestream         type 1000',
>      .       '  j=',i3,',',i3,'  k=',i3,',',i3)
>  2006 format(' ','  i=idim  NONINERTIAL freestream         type 1000',
>      .       '  j=',i3,',',i3,'  k=',i3,',',i3)
> c
4696c4766
<             write(bou(nou(1),1),1003)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1003)ista,iend,jsta,jend
4777c4847
<             write(bou(nou(1),1),1004)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1004)ista,iend,jsta,jend
4858c4928
<             write(bou(nou(1),1),1005)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1005)jsta,jend,ksta,kend
4939c5009
<             write(bou(nou(1),1),1006)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1006)jsta,jend,ksta,kend
5031a5102,5111
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
5051,5055c5131,5134
<             u1   = bcdata(1,1,1,1)
<             v1   = bcdata(1,1,1,2)
<             w1   = bcdata(1,1,1,3)
<             t1   = bcdata(1,1,1,4)
<             t2   = bcdata(1,1,1,5)
---
>             rho1  = bcdata(1,1,1,1)
>             u1    = bcdata(1,1,1,2)
>             v1    = bcdata(1,1,1,3)
>             w1    = bcdata(1,1,1,4)
5059c5138
<             write(bou(nou(1),1),1007) real(u1)
---
>             write(bou(nou(1),1),1008) real(rho1)
5061c5140
<             write(bou(nou(1),1),1008) real(v1)
---
>             write(bou(nou(1),1),1009) real(u1)
5063c5142
<             write(bou(nou(1),1),1009) real(w1)
---
>             write(bou(nou(1),1),1010) real(v1)
5065,5067c5144,5154
<             write(bou(nou(1),1),1010) real(t1)
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),1011) real(t2)
---
>             write(bou(nou(1),1),1011) real(w1)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
5070c5157
<             write(bou(nou(1),1),2001)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1001)ista,iend,ksta,kend
5072c5159
<             write(bou(nou(1),1),2007)
---
>             write(bou(nou(1),1),1012)
5074c5161
<             write(bou(nou(1),1),2008)filname
---
>             write(bou(nou(1),1),1013) filname
5080a5168,5177
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
5100,5104c5197,5200
<             u1   = bcdata(1,1,1,1)
<             v1   = bcdata(1,1,1,2)
<             w1   = bcdata(1,1,1,3)
<             t1   = bcdata(1,1,1,4)
<             t2   = bcdata(1,1,1,5)
---
>             rho1  = bcdata(1,1,1,1)
>             u1    = bcdata(1,1,1,2)
>             v1    = bcdata(1,1,1,3)
>             w1    = bcdata(1,1,1,4)
5108,5110c5204
<             write(bou(nou(1),1),1007) real(u1)
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),1008) real(v1)
---
>             write(bou(nou(1),1),1008) real(rho1)
5112c5206
<             write(bou(nou(1),1),1009) real(w1)
---
>             write(bou(nou(1),1),1009) real(u1)
5114c5208
<             write(bou(nou(1),1),1010) real(t1)
---
>             write(bou(nou(1),1),1010) real(v1)
5116c5210,5220
<             write(bou(nou(1),1),1011) real(t2)
---
>             write(bou(nou(1),1),1011) real(w1)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
5119c5223
<             write(bou(nou(1),1),2002)ista,iend,ksta,kend
---
>             write(bou(nou(1),1),1002)ista,iend,ksta,kend
5121c5225
<             write(bou(nou(1),1),2007)
---
>             write(bou(nou(1),1),1012)
5123c5227
<             write(bou(nou(1),1),2008)filname
---
>             write(bou(nou(1),1),1013) filname
5129a5234,5243
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
5149,5153c5263,5266
<             u1   = bcdata(1,1,1,1)
<             v1   = bcdata(1,1,1,2)
<             w1   = bcdata(1,1,1,3)
<             t1   = bcdata(1,1,1,4)
<             t2   = bcdata(1,1,1,5)
---
>             rho1  = bcdata(1,1,1,1)
>             u1    = bcdata(1,1,1,2)
>             v1    = bcdata(1,1,1,3)
>             w1    = bcdata(1,1,1,4)
5155,5157c5268
<             write(bou(nou(1),1),1003)ista,iend,ksta,kend
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),1007) real(u1)
---
>             write(bou(nou(1),1),1003)ista,iend,jsta,jend
5159c5270
<             write(bou(nou(1),1),1008) real(v1)
---
>             write(bou(nou(1),1),1008) real(rho1)
5161c5272
<             write(bou(nou(1),1),1009) real(w1)
---
>             write(bou(nou(1),1),1009) real(u1)
5163c5274
<             write(bou(nou(1),1),1010) real(t1)
---
>             write(bou(nou(1),1),1010) real(v1)
5165c5276,5286
<             write(bou(nou(1),1),1011) real(t2)
---
>             write(bou(nou(1),1),1011) real(w1)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
5168c5289
<             write(bou(nou(1),1),2003)ista,iend,jsta,jend
---
>             write(bou(nou(1),1),1003)ista,iend,jsta,jend
5170c5291
<             write(bou(nou(1),1),2007)
---
>             write(bou(nou(1),1),1012)
5172c5293
<             write(bou(nou(1),1),2008)filname
---
>             write(bou(nou(1),1),1013) filname
5178a5300,5309
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
5198,5202c5329,5332
<             u1   = bcdata(1,1,1,1)
<             v1   = bcdata(1,1,1,2)
<             w1   = bcdata(1,1,1,3)
<             t1   = bcdata(1,1,1,4)
<             t2   = bcdata(1,1,1,5)
---
>             rho1  = bcdata(1,1,1,1)
>             u1    = bcdata(1,1,1,2)
>             v1    = bcdata(1,1,1,3)
>             w1    = bcdata(1,1,1,4)
5204,5206c5334
<             write(bou(nou(1),1),1004)ista,iend,ksta,kend
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),1007) real(u1)
---
>             write(bou(nou(1),1),1004)ista,iend,jsta,jend
5208c5336
<             write(bou(nou(1),1),1008) real(v1)
---
>             write(bou(nou(1),1),1008) real(rho1)
5210c5338
<             write(bou(nou(1),1),1009) real(w1)
---
>             write(bou(nou(1),1),1009) real(u1)
5212c5340
<             write(bou(nou(1),1),1010) real(t1)
---
>             write(bou(nou(1),1),1010) real(v1)
5214c5342,5352
<             write(bou(nou(1),1),1011) real(t2)
---
>             write(bou(nou(1),1),1011) real(w1)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
5217c5355
<             write(bou(nou(1),1),2004)ista,iend,jsta,jend
---
>             write(bou(nou(1),1),1004)ista,iend,jsta,jend
5219c5357
<             write(bou(nou(1),1),2007)
---
>             write(bou(nou(1),1),1012)
5221c5359
<             write(bou(nou(1),1),2008)filname
---
>             write(bou(nou(1),1),1013) filname
5227a5366,5375
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
5247,5251c5395,5398
<             u1   = bcdata(1,1,1,1)
<             v1   = bcdata(1,1,1,2)
<             w1   = bcdata(1,1,1,3)
<             t1   = bcdata(1,1,1,4)
<             t2   = bcdata(1,1,1,5)
---
>             rho1  = bcdata(1,1,1,1)
>             u1    = bcdata(1,1,1,2)
>             v1    = bcdata(1,1,1,3)
>             w1    = bcdata(1,1,1,4)
5253,5255c5400
<             write(bou(nou(1),1),1005)ista,iend,ksta,kend
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),1007) real(u1)
---
>             write(bou(nou(1),1),1005)jsta,jend,ksta,kend
5257c5402
<             write(bou(nou(1),1),1008) real(v1)
---
>             write(bou(nou(1),1),1008) real(rho1)
5259c5404
<             write(bou(nou(1),1),1009) real(w1)
---
>             write(bou(nou(1),1),1009) real(u1)
5261c5406
<             write(bou(nou(1),1),1010) real(t1)
---
>             write(bou(nou(1),1),1010) real(v1)
5263c5408,5418
<             write(bou(nou(1),1),1011) real(t2)
---
>             write(bou(nou(1),1),1011) real(w1)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
5266c5421
<             write(bou(nou(1),1),2005)jsta,jend,ksta,kend
---
>             write(bou(nou(1),1),1005)jsta,jend,ksta,kend
5268c5423
<             write(bou(nou(1),1),2007)
---
>             write(bou(nou(1),1),1012)
5270c5425
<             write(bou(nou(1),1),2008)filname
---
>             write(bou(nou(1),1),1013) filname
5276a5432,5441
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
5296,5300c5461,5464
<             u1   = bcdata(1,1,1,1)
<             v1   = bcdata(1,1,1,2)
<             w1   = bcdata(1,1,1,3)
<             t1   = bcdata(1,1,1,4)
<             t2   = bcdata(1,1,1,5)
---
>             rho1  = bcdata(1,1,1,1)
>             u1    = bcdata(1,1,1,2)
>             v1    = bcdata(1,1,1,3)
>             w1    = bcdata(1,1,1,4)
5302,5304c5466
<             write(bou(nou(1),1),1006)ista,iend,ksta,kend
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),1007) real(u1)
---
>             write(bou(nou(1),1),1006)jsta,jend,ksta,kend
5306c5468
<             write(bou(nou(1),1),1008) real(v1)
---
>             write(bou(nou(1),1),1008) real(rho1)
5308c5470
<             write(bou(nou(1),1),1009) real(w1)
---
>             write(bou(nou(1),1),1009) real(u1)
5310c5472
<             write(bou(nou(1),1),1010) real(t1)
---
>             write(bou(nou(1),1),1010) real(v1)
5312c5474,5484
<             write(bou(nou(1),1),1011) real(t2)
---
>             write(bou(nou(1),1),1011) real(w1)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
5315c5487
<             write(bou(nou(1),1),2006)jsta,jend,ksta,kend
---
>             write(bou(nou(1),1),1006)jsta,jend,ksta,kend
5317c5489
<             write(bou(nou(1),1),2007)
---
>             write(bou(nou(1),1),1012)
5319c5491
<             write(bou(nou(1),1),2008)filname
---
>             write(bou(nou(1),1),1013) filname
5324c5496
<  1001 format(' ','  j=   1  set vel and turb quantities    type 2008',
---
>  1001 format(' ','  j=   1  set rho,u,v,w, extrapolate p   type 2008',
5326c5498
<  1002 format(' ','  j=jdim  set vel and turb quantities    type 2008',
---
>  1002 format(' ','  j=jdim  set rho,u,v,w, extrapolate p   type 2008',
5328c5500
<  1003 format(' ','  k=   1  set vel and turb quantities    type 2008',
---
>  1003 format(' ','  k=   1  set rho,u,v,w, extrapolate p   type 2008',
5330c5502
<  1004 format(' ','  k=kdim  set vel and turb quantities    type 2008',
---
>  1004 format(' ','  k=kdim  set rho,u,v,w, extrapolate p   type 2008',
5332c5504
<  1005 format(' ','  i=   1  set vel and turb quantities    type 2008',
---
>  1005 format(' ','  i=   1  set rho,u,v,w, extrapolate p   type 2008',
5334c5506
<  1006 format(' ','  i=idim  set vel and turb quantities    type 2008',
---
>  1006 format(' ','  i=idim  set rho,u,v,w, extrapolate p   type 2008',
5336,5340c5508,5515
<  1007 format(11x,'u/ainf           = ',f8.4)
<  1008 format(11x,'v/ainf           = ',f8.4)
<  1009 format(11x,'w/ainf           = ',f8.4)
<  1010 format(11x,'turb1 (nondim)   = ',e12.4)
<  1011 format(11x,'turb2 (nondim)   = ',e12.4)
---
>  1008 format(11x,'rho/rhoinf     = ',f8.4)
>  1009 format(11x,'u/ainf         = ',f8.4)
>  1010 format(11x,'v/ainf         = ',f8.4)
>  1011 format(11x,'w/ainf         = ',f8.4)
>  1012 format(11x,'inflow data set from file:')
>  1013 format('           ',a60)
>  1014 format(11x,'turb1 (nondim) = ',e12.4)
>  1015 format(11x,'turb2 (nondim) = ',e12.4)
5342,5355d5516
<  2001 format(' ','  j=   1  set rho,u,v,w, extrapolate p   type 2008',
<      .       '  i=',i3,',',i3,'  k=',i3,',',i3)
<  2002 format(' ','  j=jdim  set rho,u,v,w, extrapolate p   type 2008',
<      .       '  i=',i3,',',i3,'  k=',i3,',',i3)
<  2003 format(' ','  k=   1  set rho,u,v,w, extrapolate p   type 2008',
<      .       '  i=',i3,',',i3,'  j=',i3,',',i3)
<  2004 format(' ','  k=kdim  set rho,u,v,w, extrapolate p   type 2008',
<      .       '  i=',i3,',',i3,'  j=',i3,',',i3)
<  2005 format(' ','  i=   1  set rho,u,v,w, extrapolate p   type 2008',
<      .       '  j=',i3,',',i3,'  k=',i3,',',i3)
<  2006 format(' ','  i=idim  set rho,u,v,w, extrapolate p   type 2008',
<      .       '  j=',i3,',',i3,'  k=',i3,',',i3)
<  2007 format(11x,'variables set from file:')
<  2008 format('           ',a60)
5356a5518,6016
>       end
>       subroutine out2009(jdim,kdim,idim,ista,iend,jsta,jend,ksta,kend,
>      .                  nface,nou,bou,nbuf,ibufdim,mdim,ndim,bcdata,
>      .                  filname,myid,mblk2nd,maxbl)
> c
> #   ifdef CMPLX
>       implicit complex(a-h,o-z)
> #   endif
> c
>       character*120 bou(ibufdim,nbuf)
>       character*80 filname
> c
>       dimension nou(nbuf)
>       dimension bcdata(mdim,ndim,2,7),mblk2nd(maxbl)
> c
>       common /maxiv/ ivmx
> c
>       jend1 = jend-1
>       kend1 = kend-1
>       iend1 = iend-1
> c
>       if (nface.eq.3) then
> c
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
> c        check that the required auxiliary data has been set
>          iflg = 0
>          do 1 l=1,4
>          do 1 ipp=1,2
>          do 1 i=ista,iend1
>          ii = i-ista+1
>          do 1 k=ksta,kend1
>          kk = k-ksta+1
>          if (real(bcdata(kk,ii,ipp,l)) .lt. -1.e10) iflg = 1
>    1     continue
>          if (iflg.eq.1) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  Stopping in bc2009:'
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  nozzle total BC data incorrectly',
>      .      ' set '
>             call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>          end if
>          if (itrflg1.gt.0 .or. itrflg2.gt.0) then
>             if (ivmx.gt.5 .and. itrflg1*itrflg2.eq.0) then
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  stopping in bc2009...must',
>      .         ' set both turbulence'
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  quantities for 2-eq turb.',
>      .         ' models...only one is set'
>                call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>             end if
>          end if
>          if (filname.eq.'null') then
>             pte   = bcdata(1,1,1,1)
>             tte   = bcdata(1,1,1,2)
>             alpe  = bcdata(1,1,1,3)
>             betae = bcdata(1,1,1,4)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1001)ista,iend,ksta,kend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1008) real(pte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1009) real(tte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1010) real(alpe)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1011) real(betae)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
>          else
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1001)ista,iend,ksta,kend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1012)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1013) filname
>          end if
>       end if
> c
>       if (nface.eq.4) then
> c
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
> c        check that the required auxiliary data has been set
>          iflg = 0
>          do 2 l=1,4
>          do 2 ipp=1,2
>          do 2 i=ista,iend1
>          ii = i-ista+1
>          do 2 k=ksta,kend1
>          kk = k-ksta+1
>          if (real(bcdata(kk,ii,ipp,l)) .lt. -1.e10) iflg = 1
>    2     continue
>          if (iflg.eq.1) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  Stopping in bc2009:'
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  nozzle total BC data incorrectly',
>      .      ' set '
>             call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>          end if
>          if (itrflg1.gt.0 .or. itrflg2.gt.0) then
>             if (ivmx.gt.5 .and. itrflg1*itrflg2.eq.0) then
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  stopping in bc2009...must',
>      .         ' set both turbulence'
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  quantities for 2-eq turb.',
>      .         ' models...only one is set'
>                call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>             end if
>          end if
>          if (filname.eq.'null') then
>             pte   = bcdata(1,1,1,1)
>             tte   = bcdata(1,1,1,2)
>             alpe  = bcdata(1,1,1,3)
>             betae = bcdata(1,1,1,4)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1002)ista,iend,ksta,kend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1008) real(pte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1009) real(tte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1010) real(alpe)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1011) real(betae)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
>          else
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1002)ista,iend,ksta,kend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1012)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1013) filname
>          end if
>       end if
> c
>       if (nface.eq.5) then
> c
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
> c        check that the required auxiliary data has been set
>          iflg = 0
>          do 3 l=1,4
>          do 3 ipp=1,2
>          do 3 i=ista,iend1
>          ii = i-ista+1
>          do 3 j=jsta,jend1
>          jj = j-jsta+1
>          if (real(bcdata(jj,ii,ipp,l)) .lt. -1.e10) iflg = 1
>    3     continue
>          if (iflg.eq.1) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  Stopping in bc2009:'
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  nozzle total BC data incorrectly',
>      .      ' set '
>             call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>          end if
>          if (itrflg1.gt.0 .or. itrflg2.gt.0) then
>             if (ivmx.gt.5 .and. itrflg1*itrflg2.eq.0) then
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  stopping in bc2009...must',
>      .         ' set both turbulence'
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  quantities for 2-eq turb.',
>      .         ' models...only one is set'
>                call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>             end if
>          end if
>          if (filname.eq.'null') then
>             pte   = bcdata(1,1,1,1)
>             tte   = bcdata(1,1,1,2)
>             alpe  = bcdata(1,1,1,3)
>             betae = bcdata(1,1,1,4)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1003)ista,iend,jsta,jend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1008) real(pte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1009) real(tte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1010) real(alpe)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1011) real(betae)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
>          else
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1003)ista,iend,jsta,jend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1012)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1013) filname
>          end if
>       end if
> c
>       if (nface.eq.6) then
> c
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
> c        check that the required auxiliary data has been set
>          iflg = 0
>          do 4 l=1,4
>          do 4 ipp=1,2
>          do 4 i=ista,iend1
>          ii = i-ista+1
>          do 4 j=jsta,jend1
>          jj = j-jsta+1
>          if (real(bcdata(jj,ii,ipp,l)) .lt. -1.e10) iflg = 1
>    4     continue
>          if (iflg.eq.1) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  Stopping in bc2009:'
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  nozzle total BC data incorrectly',
>      .      ' set '
>             call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>          end if
>          if (itrflg1.gt.0 .or. itrflg2.gt.0) then
>             if (ivmx.gt.5 .and. itrflg1*itrflg2.eq.0) then
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  stopping in bc2009...must',
>      .         ' set both turbulence'
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  quantities for 2-eq turb.',
>      .         ' models...only one is set'
>                call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>             end if
>          end if
>          if (filname.eq.'null') then
>             pte   = bcdata(1,1,1,1)
>             tte   = bcdata(1,1,1,2)
>             alpe  = bcdata(1,1,1,3)
>             betae = bcdata(1,1,1,4)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1004)ista,iend,jsta,jend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1008) real(pte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1009) real(tte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1010) real(alpe)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1011) real(betae)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
>          else
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1004)ista,iend,jsta,jend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1012)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1013) filname
>          end if
>       end if
> c
>       if (nface.eq.1) then
> c
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
> c        check that the required auxiliary data has been set
>          iflg = 0
>          do 5 l=1,4
>          do 5 ipp=1,2
>          do 5 j=jsta,jend1
>          jj = j-jsta+1
>          do 5 k=ksta,kend1
>          kk = k-ksta+1
>          if (real(bcdata(jj,kk,ipp,l)) .lt. -1.e10) iflg = 1
>    5     continue
>          if (iflg.eq.1) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  Stopping in bc2009:'
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  nozzle total BC data incorrectly',
>      .      ' set'
>             call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>          end if
>          if (itrflg1.gt.0 .or. itrflg2.gt.0) then
>             if (ivmx.gt.5 .and. itrflg1*itrflg2.eq.0) then
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  stopping in bc2009...must',
>      .         ' set both turbulence'
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  quantities for 2-eq turb.',
>      .         ' models...only one is set'
>                call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>             end if
>          end if
>          if (filname.eq.'null') then
>             pte   = bcdata(1,1,1,1)
>             tte   = bcdata(1,1,1,2)
>             alpe  = bcdata(1,1,1,3)
>             betae = bcdata(1,1,1,4)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1005)jsta,jend,ksta,kend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1008) real(pte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1009) real(tte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1010) real(alpe)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1011) real(betae)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
>          else
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1005)jsta,jend,ksta,kend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1012)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1013) filname
>          end if
>       end if
> c
>       if (nface.eq.2) then
> c
> c        check to see if turbulence data is input (itrflg1/2 = 1) or
> c        if freestream values are to be used (itrflg1/2 = 0); the check
> c        assumes if the first point has been set, all points have been
> c
>          ipp     = 1
>          itrflg1 = 0
>          itrflg2 = 0
>          if (real(bcdata(1,1,ipp,5)) .ge. 0.) itrflg1 = 1
>          if (real(bcdata(1,1,ipp,6)) .ge. 0.) itrflg2 = 1
> c
> c        check that the required auxiliary data has been set
>          iflg = 0
>          do 6 l=1,4
>          do 6 ipp=1,2
>          do 6 j=jsta,jend1
>          jj = j-jsta+1
>          do 6 k=ksta,kend1
>          kk = k-ksta+1
>          if (real(bcdata(jj,kk,ipp,l)) .lt. -1.e10) iflg = 1
>    6     continue
>          if (iflg.eq.1) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  Stopping in bc2009:'
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),*)'  nozzle total BC data incorrectly',
>      .      ' set'
>             call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>          end if
>          if (itrflg1.gt.0 .or. itrflg2.gt.0) then
>             if (ivmx.gt.5 .and. itrflg1*itrflg2.eq.0) then
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  stopping in bc2009...must',
>      .         ' set both turbulence'
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),*)'  quantities for 2-eq turb.',
>      .         ' models...only one is set'
>                call termn8(myid,-1,ibufdim,nbuf,bou,nou)
>             end if
>          end if
>          if (filname.eq.'null') then
>             pte   = bcdata(1,1,1,1)
>             tte   = bcdata(1,1,1,2)
>             alpe  = bcdata(1,1,1,3)
>             betae = bcdata(1,1,1,4)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1006)jsta,jend,ksta,kend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1008) real(pte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1009) real(tte)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1010) real(alpe)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1011) real(betae)
>             if (itrflg1.gt.0) then
>                t1 = bcdata(1,1,1,5)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1014) real(t1)
>             end if
>             if (itrflg2.gt.0) then
>                t2 = bcdata(1,1,1,6)
>                nou(1) = min(nou(1)+1,ibufdim)
>                write(bou(nou(1),1),1015) real(t2)
>             end if
>          else
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1006)jsta,jend,ksta,kend
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1012)
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),1013) filname
>          end if
>       end if
> c
>  1001 format(' ','  j=   1  nozzle total BC                type 2009',
>      .       '  i=',i3,',',i3,'  k=',i3,',',i3)
>  1002 format(' ','  j=jdim  nozzle total BC                type 2009',
>      .       '  i=',i3,',',i3,'  k=',i3,',',i3)
>  1003 format(' ','  k=   1  nozzle total BC                type 2009',
>      .       '  i=',i3,',',i3,'  j=',i3,',',i3)
>  1004 format(' ','  k=kdim  nozzle total BC                type 2009',
>      .       '  i=',i3,',',i3,'  j=',i3,',',i3)
>  1005 format(' ','  i=   1  nozzle total BC                type 2009',
>      .       '  j=',i3,',',i3,'  k=',i3,',',i3)
>  1006 format(' ','  i=idim  nozzle total BC                type 2009',
>      .       '  j=',i3,',',i3,'  k=',i3,',',i3)
>  1008 format(11x,'Pt/Pinf        = ',f8.4)
>  1009 format(11x,'Tt/Tinf        = ',f8.4)
>  1010 format(11x,'alphe          = ',f8.4)
>  1011 format(11x,'betae          = ',f8.4)
>  1012 format(11x,'inflow data set from file:')
>  1013 format('           ',a60)
>  1014 format(11x,'turb1 (nondim) = ',e12.4)
>  1015 format(11x,'turb2 (nondim) = ',e12.4)
> c
>       return
Index: source/cfl3d/libs/bc_xmera.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/bc_xmera.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
5c5
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
31c31
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/libs/blnkfr.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/blnkfr.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
4c4
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
17a18
>       real blnkval
Index: source/cfl3d/libs/blomax.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/blomax.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
74c74
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
Index: source/cfl3d/libs/ccomplex.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/ccomplex.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
5c5
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18a19,21
> #ifdef CRAY_TIME
>       ccvmgt = merge(a,b,c)
> #else
23a27
> #endif
Index: source/cfl3d/libs/cgnstools.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/cgnstools.F,v
retrieving revision 1.3
retrieving revision 1.10
diff -r1.3 -r1.10
2c2
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
55c55
<       write(11,'('' CGNS read solution of name:  '',a32)') solname
---
>       write(11,'('' cgns read solution of name:  '',a32)') solname
202c202
<       call reorderg(idim,jdim,kdim,wk,x)
---
>       call reorderg(1,1,idim,jdim,kdim,idim,jdim,kdim,wk,x)
214c214
<         call reorderg(idim,jdim,kdim,wk,y)
---
>         call reorderg(1,1,idim,jdim,kdim,idim,jdim,kdim,wk,y)
216c216
<         call reorderg(idim,jdim,kdim,wk,z)
---
>         call reorderg(1,1,idim,jdim,kdim,idim,jdim,kdim,wk,z)
229c229
<         call reorderg(idim,jdim,kdim,wk,z)
---
>         call reorderg(1,1,idim,jdim,kdim,idim,jdim,kdim,wk,z)
231,238c231
<         do i=1,idim
<         do j=1,jdim
<         do k=1,kdim
<           wk(i,j,k)=-wk(i,j,k)
<         enddo
<         enddo
<         enddo
<         call reorderg(idim,jdim,kdim,wk,y)
---
>         call reorderg(1,1,idim,jdim,kdim,idim,jdim,kdim,-wk,y)
268c261
<         write(66,'('' Error opening CGNS file'')')
---
>         write(66,'('' Error opening cgns file'')')
279,280c272,273
<         write(66,'('' Error attempting to find CGNSBase_t node'')')
<         write(66,'('' Make sure the CGNS file is written correctly'',
---
>         write(66,'('' Error attempting to find Base node'')')
>         write(66,'('' Make sure the cgns file is written correctly'',
330a324,325
>       write(11,'(/,'' Accessing cgns database... (must'',
>      +  '' be linked to API Version 2.2 or later)'')')
333c328
<         write(11,'('' Error opening CGNS file'')')
---
>         write(11,'('' Error opening cgns file'')')
338c333,341
<       write(11,'(/,'' Opening CGNS database '',a32)') cgnsdesired
---
>       write(11,'(/,'' Opening cgns database '',a32)') cgnsdesired
>       write(11,'(''   Note: if restarting from a cgns file created'',
>      +  '' prior to early 2002, then'')')
>       write(11,'(''   it will not work if the old case was (1) second'',
>      +  '' order time accurate,'')')
>       write(11,'(''   (2) moving or deforming grid, or (3) ialph>0.'',
>      +  ''  In all of these cases,'')')
>       write(11,'(''   changes have been made in how variables are'',
>      +  '' stored in cgns.'',/)')
343c346
<       write(11,'('' Found ''i5,'' base(s) in CGNS file: '',a32)') 
---
>       write(11,'('' Found ''i5,'' base(s) in cgns file: '',a32)') 
367a371
>           if (ier .ne. 0) call cg_error_exit_f
417c421
<         write(11,'('' Error opening CGNS file'')')
---
>         write(11,'('' Error opening cgns file'')')
422d425
<       write(11,'(/,'' Opening CGNS database '',a32)') cgnsdesired
427,428d429
<       write(11,'('' Found ''i5,'' base(s) in CGNS file: '',a32)') 
<      +  nbases,cgnsdesired
451a453
>           if (ier .ne. 0) call cg_error_exit_f
468,469d469
<       write(11,'('' Found ''i5,'' zone(s) in basename: '',a32)') nzones,
<      +  basedesired
475c475
<      +  jdim,kdim,wk,q,qj0,qk0,qi0,bcj,bck,bci,i2d,nsoluse)
---
>      +  jdim,kdim,wk,q,qj0,qk0,qi0,bcj,bck,bci,i2d,ialph,nsoluse)
514c514,516
< c                          and k- directions)
---
> c                          and k- directions) (integer)
> c      ialph............parameter in CFL3D for determining whether y
> c                       or z is "up" (integer)
528c530
<       character*32 solname,name
---
>       character*32 solname
538c540
<       write(11,'('' CGNS writing to <<FlowSolution>> node'')')
---
>       write(11,'('' cgns writing to <<FlowSolution>> node'')')
569d570
<       name='Information'
571a573
>       if (ier .ne. 0) call cg_error_exit_f
609a612
>       if (ialph .eq. 0) then
611a615,618
>       else
>       call reordsln(nfac,i2d,idima,jdima,kdima,idim,jdim,kdim,
>      +  q,bci,bcj,bck,qi0,qj0,qk0,5,4,0,wk)
>       end if
621a629
>       if (ialph .eq. 0) then
623a632,635
>       else
>       call reordsln(nfac,i2d,idima,jdima,kdima,idim,jdim,kdim,
>      +  -q,bci,bcj,bck,-qi0,-qj0,-qk0,5,3,0,wk)
>       end if
649c661
<      +  jdim,kdim,wk,nsoluse,irind,jrind,krind,i2d,q,iprim)
---
>      +  jdim,kdim,wk,nsoluse,irind,jrind,krind,i2d,ialph,q,iprim)
679c691,693
< c      i2d..............0 if 3-D, 1 if 2-D
---
> c      i2d..............0 if 3-D, 1 if 2-D (integer)
> c      ialph............parameter in CFL3D for determining whether y
> c                       or z is "up" (integer)
791a806
>       if (ier .ne. 0) call cg_error_exit_f
792a808
>       if (ier .ne. 0) call cg_error_exit_f
795a812
>         if (ier .ne. 0) call cg_error_exit_f
808a826,828
>           if (text .eq.
>      +     'Every-16th-cell solution (3 levels down)' .and.
>      +     nfac .ne. 8) istop=5
860a881,887
>       if (m .eq. 3 .and. ialph .ne. 0) then
>       call reorderq(idima,jdima,kdima,idim,jdim,kdim,nfac,
>      +    nfaci,wk,irind,jrind,krind,q(1,1,1,4))
>       else if (m .eq. 4 .and. ialph .ne. 0) then
>       call reorderq(idima,jdima,kdima,idim,jdim,kdim,nfac,
>      +    nfaci,-wk,irind,jrind,krind,q(1,1,1,3))
>       else
862a890
>       end if
990c1018
< c                       only in j- and k- directions)
---
> c                       only in j- and k- directions) (integer)
1034c1062
<          write(11,'(''   writing vist3d data to CGNS file'',
---
>          write(11,'(''   writing vist3d data to cgns file'',
1143c1171
<      .              '' to CGNS file'',
---
>      .              '' to cgns file'',
1172c1200
<      .              '' to CGNS file'',
---
>      .              '' to cgns file'',
1211c1239
<      .              '' to CGNS file'',
---
>      .              '' to cgns file'',
1312c1340
< c      i2d..............0 if 3-D, 1 if 2-D
---
> c      i2d..............0 if 3-D, 1 if 2-D (integer)
1677c1705
<             write(11,'('' Error.  CGNS 1-to-1 zonename not'',
---
>             write(11,'('' Error, cgns 1-to-1 zonename not'',
2325a2354
>       dimension idimvec(4)
2370a2400
>         if (ier .ne. 0) call cg_error_exit_f
2717,2719c2747
<       dimension ideg(3)
< c
<       integer idata(6)
---
>       dimension ideg(3),idata(6),units(5)
2770c2798
<       call cg_model_write_f('GasModel_t',Ideal,ier)
---
>       call cg_model_write_f('GasModel_t',CaloricallyPerfect,ier)
2777a2806,2876
> c
> c   Create DataArray containing Specific Heat Ratio under GasModel
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'FlowEquationSet_t',1,'GasModel_t',1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       if (idouble .eq. 1) then
>         call cg_array_write_f('SpecificHeatRatio',RealDouble,
>      +   1,1,gamma,ier)
>       else
>         call cg_array_write_f('SpecificHeatRatio',RealSingle,
>      +   1,1,gamma,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'FlowEquationSet_t',1,'GasModel_t',1,'DataArray_t',
>      +  1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_dataclass_write_f(NondimensionalParameter,ier)
>       if (ier .ne. 0) call cg_error_exit_f
> c
> c   Create DataArray containing Prandtl number under ThermalConductivityModel
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'FlowEquationSet_t',1,'ThermalConductivityModel_t',1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       if (idouble .eq. 1) then
>         call cg_array_write_f('Prandtl',RealDouble,
>      +   1,1,prandtl,ier)
>       else
>         call cg_array_write_f('Prandtl',RealSingle,
>      +   1,1,prandtl,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'FlowEquationSet_t',1,'ThermalConductivityModel_t',1,
>      +  'DataArray_t',1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_dataclass_write_f(NondimensionalParameter,ier)
>       if (ier .ne. 0) call cg_error_exit_f
> c
> c   Create DataArray containing Sutherland law constant under ViscosityModel
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'FlowEquationSet_t',1,'ViscosityModel_t',1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       if (idouble .eq. 1) then
>         call cg_array_write_f('SutherlandLawConstant',RealDouble,
>      +   1,1,suth,ier)
>       else
>         call cg_array_write_f('SutherlandLawConstant',RealSingle,
>      +   1,1,suth,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'FlowEquationSet_t',1,'ViscosityModel_t',1,
>      +  'DataArray_t',1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_dataclass_write_f(Dimensional,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_units_write_f(Null,Null,Null,Rankine,Null,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       units(1)=0.
>       units(2)=0.
>       units(3)=0.
>       units(4)=1.
>       units(5)=0.
>       if (idouble .eq. 1) then
>         call cg_exponents_write_f(RealDouble,units,ier)
>       else
>         call cg_exponents_write_f(RealSingle,units,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
2779a2879,2881
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'FlowEquationSet_t',1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
2894,2929d2995
< c   Create DataArray containing Specific Heat Ratio under GasModel
<       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
<      + 'FlowEquationSet_t',1,'GasModel_t',1,'end')
<       if (ier .ne. 0) call cg_error_exit_f
<       if (idouble .eq. 1) then
<         call cg_array_write_f('SpecificHeatRatio',RealDouble,
<      +   1,1,gamma,ier)
<       else
<         call cg_array_write_f('SpecificHeatRatio',RealSingle,
<      +   1,1,gamma,ier)
<       end if
<       if (ier .ne. 0) call cg_error_exit_f
<       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
<      + 'FlowEquationSet_t',1,'GasModel_t',1,'DataArray_t',
<      +  1,'end')
<       call cg_dataclass_write_f(NondimensionalParameter,ier)
<       if (ier .ne. 0) call cg_error_exit_f
< c
< c   Create DataArray containing Prandtl number under ThermalConductivityModel
<       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
<      + 'FlowEquationSet_t',1,'ThermalConductivityModel_t',1,'end')
<       if (ier .ne. 0) call cg_error_exit_f
<       if (idouble .eq. 1) then
<         call cg_array_write_f('Prandtl',RealDouble,
<      +   1,1,prandtl,ier)
<       else
<         call cg_array_write_f('Prandtl',RealSingle,
<      +   1,1,prandtl,ier)
<       end if
<       if (ier .ne. 0) call cg_error_exit_f
<       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
<      + 'FlowEquationSet_t',1,'ThermalConductivityModel_t',1,
<      +  'DataArray_t',1,'end')
<       call cg_dataclass_write_f(NondimensionalParameter,ier)
<       if (ier .ne. 0) call cg_error_exit_f
< c
2945,2963d3010
<       call cg_dataclass_write_f(NondimensionalParameter,ier)
<       if (ier .ne. 0) call cg_error_exit_f
< c
< c   Create DataArray containing Sutherland law constant under ViscosityModel
<       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
<      + 'FlowEquationSet_t',1,'ViscosityModel_t',1,'end')
<       if (ier .ne. 0) call cg_error_exit_f
<       if (idouble .eq. 1) then
<         call cg_array_write_f('SutherlandLawConstant',RealDouble,
<      +   1,1,suth,ier)
<       else
<         call cg_array_write_f('SutherlandLawConstant',RealSingle,
<      +   1,1,suth,ier)
<       end if
<       if (ier .ne. 0) call cg_error_exit_f
<       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
<      + 'FlowEquationSet_t',1,'ViscosityModel_t',1,
<      +  'DataArray_t',1,'end')
<       call cg_dataclass_write_f(Dimensional,ier)
2965c3012
<       call cg_units_write_f(Null,Null,Null,Rankine,Null,ier)
---
>       call cg_dataclass_write_f(NondimensionalParameter,ier)
2993c3040
<       integer idata(6)
---
>       dimension idata(6),idimvec(4)
3030c3077
<           write(11,'('' CGNS read solution of:  '',a32)') 
---
>           write(11,'('' cgns read solution of:  '',a32)') 
3077a3125
>       if (ier .ne. 0) call cg_error_exit_f
3110a3159
>       if (ier .ne. 0) call cg_error_exit_f
3143a3193
>       if (ier .ne. 0) call cg_error_exit_f
3176a3227
>       if (ier .ne. 0) call cg_error_exit_f
3228a3280
>         if (ier .ne. 0) call cg_error_exit_f
3231a3284
>           if (ier .ne. 0) call cg_error_exit_f
3319c3372
<       subroutine writetime(iccg,ibase,time,iter)
---
>       subroutine writetime(iccg,ibase,time,iter,dt)
3321c3374,3376
< c     Purpose: Writes latest time info to CGNS file.
---
> c     Purpose: Writes latest time info to CGNS file.  This includes
> c     the time step dt, which will only be read in (by rsecord) if
> c     the run is 2nd-order time-accurate.
3329a3385
> c      dt...............time step (real)
3335a3392,3395
>       parameter (numnames=5)
> c
>       character name(numnames)*32
> c
3357c3417,3418
<       call cg_dataclass_write_f(NondimensionalParameter,ier)
---
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_dataclass_write_f(NormalizedByUnknownDimensional,ier)
3363a3425,3456
> c
> c   Go to Base node, write CFL3DTimeStep array as UserDefinedData
>       call cg_goto_f(iccg,ibase,ier,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_user_data_write_f('CFL3DTimeStep', ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_nuser_data_f(nuserdata, ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .gt. numnames) then
>         write(11,'('' Error... numnames too small in writetime'')')
>         stop
>       end if
>       do n=1,nuserdata
>         call cg_user_data_read_f(n, name(n), ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if(name(n) .eq. 'CFL3DTimeStep') then
>           nset=n
>         end if
>       enddo
>       call cg_goto_f(iccg,ibase,ier,'UserDefinedData_t',nset,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       if (idouble .eq. 1) then
>         call cg_array_write_f('LatestDTUsed',RealDouble,1,1,dt,ier)
>       else
>         call cg_array_write_f('LatestDTUsed',RealSingle,1,1,dt,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_goto_f(iccg,ibase,ier,'UserDefinedData_t',nset,
>      +  'DataArray_t',1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_dataclass_write_f(NormalizedByUnknownDimensional,ier)
>       if (ier .ne. 0) call cg_error_exit_f
3383c3476
<       parameter (numnames=2)
---
>       parameter (numnames=3)
3384a3478
>       dimension idimvec(4)
3416a3511
>         if (ier .ne. 0) call cg_error_exit_f
3471a3567
>       dimension units(5)
3502a3599
>         if (ier .ne. 0) call cg_error_exit_f
3503a3601
>         if (ier .ne. 0) call cg_error_exit_f
3505a3604
>         if (ier .ne. 0) call cg_error_exit_f
3507a3607
>         if (ier .ne. 0) call cg_error_exit_f
3508a3609
>         if (ier .ne. 0) call cg_error_exit_f
3510a3612
>         if (ier .ne. 0) call cg_error_exit_f
3512d3613
<       if (ier .ne. 0) call cg_error_exit_f
3514a3616
>       if (ier .ne. 0) call cg_error_exit_f
3522a3625
>         if (ier .ne. 0) call cg_error_exit_f
3524a3628
>         if (ier .ne. 0) call cg_error_exit_f
3526a3631
>         if (ier .ne. 0) call cg_error_exit_f
3528a3634
>         if (ier .ne. 0) call cg_error_exit_f
3530a3637
>         if (ier .ne. 0) call cg_error_exit_f
3532a3640
>         if (ier .ne. 0) call cg_error_exit_f
3534a3643
>         if (ier .ne. 0) call cg_error_exit_f
3536a3646
>         if (ier .ne. 0) call cg_error_exit_f
3538d3647
<       if (ier .ne. 0) call cg_error_exit_f
3540a3650
>       if (ier .ne. 0) call cg_error_exit_f
3554a3665
>       if (ier .ne. 0) call cg_error_exit_f
3558a3670,3680
>       units(1)=0.
>       units(2)=0.
>       units(3)=0.
>       units(4)=1.
>       units(5)=0.
>       if (idouble .eq. 1) then
>         call cg_exponents_write_f(RealDouble,units,ier)
>       else
>         call cg_exponents_write_f(RealSingle,units,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
3571a3694
>       if (ier .ne. 0) call cg_error_exit_f
3575a3699,3709
>       units(1)=0.
>       units(2)=0.
>       units(3)=0.
>       units(4)=0.
>       units(5)=1.
>       if (idouble .eq. 1) then
>         call cg_exponents_write_f(RealDouble,units,ier)
>       else
>         call cg_exponents_write_f(RealSingle,units,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
3588a3723
>       if (ier .ne. 0) call cg_error_exit_f
3592a3728,3738
>       units(1)=0.
>       units(2)=0.
>       units(3)=0.
>       units(4)=0.
>       units(5)=1.
>       if (idouble .eq. 1) then
>         call cg_exponents_write_f(RealDouble,units,ier)
>       else
>         call cg_exponents_write_f(RealSingle,units,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
3604a3751
>       if (ier .ne. 0) call cg_error_exit_f
3618a3766
>       if (ier .ne. 0) call cg_error_exit_f
3634a3783
>       if (ier .ne. 0) call cg_error_exit_f
3651a3801
>       if (ier .ne. 0) call cg_error_exit_f
3670a3821
>       if (ier .ne. 0) call cg_error_exit_f
3684a3836
>       if (ier .ne. 0) call cg_error_exit_f
3698a3851
>       if (ier .ne. 0) call cg_error_exit_f
3719a3873
>       if (ier .ne. 0) call cg_error_exit_f
3740a3895
>       if (ier .ne. 0) call cg_error_exit_f
3781a3937
>       dimension idimvec(4)
3803c3959
<            write(11,'('' ERROR:  Restart file must have data that'',
---
>            write(11,'('' Error:  Restart file must have data that'',
3850a4007
>         if (ier .ne. 0) call cg_error_exit_f
4004a4162
>       if (ier .ne. 0) call cg_error_exit_f
4016a4175
>       if (ier .ne. 0) call cg_error_exit_f
4043a4203
>       if (ier .ne. 0) call cg_error_exit_f
4056c4216
<       subroutine writeinput(iccg,ibase,iunit5)
---
>       subroutine writeinput(iccg,ibase,iunit5,irest)
4069c4229,4230
< c      iunit5...........unit number of the input file to copy
---
> c      iunit5...........unit number of the input file to copy (integer)
> c      irest............flag is zero if not a restart run (integer)
4095c4256
<       do n=1,ndesc
---
>       do n=ndesc,1,-1
4096a4258
>         if (ier .ne. 0) call cg_error_exit_f
4122c4284,4289
<           inum=inum+1
---
>           if (irest .eq. 0) then
>             call cg_delete_node_f(name,ier)
>             if (ier .ne. 0) call cg_error_exit_f
>           else
>             inum=inum+1
>           end if
4315c4482
<       extra='CFL3D V6.0 code:  '
---
>       extra='CFL3D V6.X code:  '
4317a4485
>       if (ier .ne. 0) call cg_error_exit_f
4332a4501
>       if (ier .ne. 0) call cg_error_exit_f
4339a4509
>       if (ier .ne. 0) call cg_error_exit_f
4346a4517
>       if (ier .ne. 0) call cg_error_exit_f
4353a4525
>       if (ier .ne. 0) call cg_error_exit_f
4360a4533
>       if (ier .ne. 0) call cg_error_exit_f
4367a4541
>       if (ier .ne. 0) call cg_error_exit_f
4374a4549
>       if (ier .ne. 0) call cg_error_exit_f
4381a4557
>       if (ier .ne. 0) call cg_error_exit_f
4388a4565
>       if (ier .ne. 0) call cg_error_exit_f
4395a4573
>       if (ier .ne. 0) call cg_error_exit_f
4402a4581
>       if (ier .ne. 0) call cg_error_exit_f
4409a4589
>       if (ier .ne. 0) call cg_error_exit_f
4416a4597
>       if (ier .ne. 0) call cg_error_exit_f
4423a4605
>       if (ier .ne. 0) call cg_error_exit_f
4455c4637
<      +                   jdim,kdim,wk,qc0,nsoluse,i2d)
---
>      +                   jdim,kdim,wk,qc0,tursav2,nsoluse,i2d,ialph)
4457c4639,4640
< c     Purpose: Writes qc0 (Q's from previous time step) for 2nd order
---
> c     Purpose: Writes qc0 & tursav2 (Q's and turb quantities
> c     from previous time step) for 2nd order
4486a4670,4672
> c      tursav2..........cell-centered turb values from last time step, 
> c                       in (j,k,i) order; dimensioned by 4, but only
> c                       need to store two of them (real)
4492c4678,4680
< c                          and k- directions)
---
> c                          and k- directions) (integer)
> c      ialph............parameter in CFL3D for determining whether y
> c                       or z is "up" (integer)
4499c4687,4689
<       dimension qc0(jdim,kdim,idim-1,5),
---
>       parameter(numnames=20)
> c
>       dimension qc0(jdim,kdim,idim-1,5),tursav2(jdim,kdim,idim,4),
4500a4691
>       character*32 name(numnames)
4549a4741
>       if (ialph .eq. 0) then
4551a4744,4747
>       else
>       call reordsln(nfac,i2d,idima,jdima,kdima,idim-1,jdim,kdim,
>      +  qc0,wk,wk,wk,wk,wk,wk,5,4,2,wk)
>       end if
4561a4758
>       if (ialph .eq. 0) then
4563a4761,4764
>       else
>       call reordsln(nfac,i2d,idima,jdima,kdima,idim-1,jdim,kdim,
>      +  -qc0,wk,wk,wk,wk,wk,wk,5,3,2,wk)
>       end if
4584a4786,4809
> c   First turb quantity:
>       call reordsln(nfac,i2d,idima,jdima,kdima,idim,jdim,kdim,
>      +  tursav2,wk,wk,wk,wk,wk,wk,4,1,2,wk)
>       if (idouble .eq. 1) then
>       call cg_field_write_f(iccg, ibase, igrid, nsoluse, RealDouble,
>      +                      'TurbVal1LastDT', wk, ifindex, ier)
>       else
>       call cg_field_write_f(iccg, ibase, igrid, nsoluse, RealSingle,
>      +                      'TurbVal1LastDT', wk, ifindex, ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
> c   Second turb quantity:
>       call reordsln(nfac,i2d,idima,jdima,kdima,idim,jdim,kdim,
>      +  tursav2,wk,wk,wk,wk,wk,wk,4,2,2,wk)
>       if (idouble .eq. 1) then
>       call cg_field_write_f(iccg, ibase, igrid, nsoluse, RealDouble,
>      +                      'TurbVal2LastDT', wk, ifindex, ier)
>       else
>       call cg_field_write_f(iccg, ibase, igrid, nsoluse, RealSingle,
>      +                      'TurbVal2LastDT', wk, ifindex, ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
4589c4814,4815
<      +                   jdim,kdim,wk,nsoluse,irind,jrind,krind,i2d,qc0)
---
>      +                   jdim,kdim,wk,nsoluse,irind,jrind,krind,i2d,dt,
>      +                   ialph,qc0,tursav2,dtold)
4591c4817,4818
< c     Purpose: Reads qc0 (Q's from previous time step) for 2nd order
---
> c     Purpose: Reads qc0 & tursav2 (Q's and turb quantities
> c     from previous time step) & dt for 2nd order
4617c4844,4847
< c      i2d..............0 if 3-D, 1 if 2-D
---
> c      i2d..............0 if 3-D, 1 if 2-D (integer)
> c      dt...............current time step (real)
> c      ialph............parameter in CFL3D for determining whether y
> c                       or z is "up" (integer)
4620a4851,4854
> c      tursav2..........cell-centered turb values from last time step,
> c                       in (j,k,i) order; dimensioned by 4, but only
> c                       need to store two of them (real)
> c      dtold............previous (saved) time step (real)
4625c4859
<       parameter(numfield=50)
---
>       parameter(numfield=50,numnames=3)
4627c4861
<       dimension qc0(jdim,kdim,idim-1,5), 
---
>       dimension qc0(jdim,kdim,idim-1,5),tursav2(jdim,kdim,idim,4),
4630a4865
>       character*32 name(numnames)
4713a4949,4955
>       if (m .eq. 3 .and. ialph .ne. 0) then
>       call reorderq(idima,jdima,kdima,idim-1,jdim,kdim,nfac,
>      +    nfaci,wk,irind,jrind,krind,qc0(1,1,1,4))
>       else if (m .eq. 4 .and. ialph .ne. 0) then
>       call reorderq(idima,jdima,kdima,idim-1,jdim,kdim,nfac,
>      +    nfaci,-wk,irind,jrind,krind,qc0(1,1,1,3))
>       else
4715a4958,4979
>       end if
>       enddo
> c
> c   Now get 2nd order turb quantities (they may not exist if this
> c   is reading an older file)
>       numwanted=2
>       fndesired(1)='TurbVal1LastDT'
>       fndesired(2)='TurbVal2LastDT'
>       ibad=0
>       do n=1,numwanted
>         ido=0
>         do nn=1,nfields
>           if(fndesired(n) .eq. fieldname(nn)) then
>             ido=1
>           end if
>         enddo
>         if (ido .eq. 0) then
>           write(11,'('' Cannot find solution of name '',a32)')
>      +      fndesired(n)
>           write(11,'('' ...leaving old turbs as 0 and continuing'')')
>           ibad=1
>         end if
4716a4981,4998
>       if (ibad .eq. 1) then
> c       Do not read - values will be left as zero (as initialized)
>         continue
>       else
> c   Read old turb quantities:
>         do m=1,2
>         if (idouble .eq. 1) then
>         call cg_field_read_f(iccg, ibase, igrid, nsoluse,
>      +     fndesired(m), RealDouble, irmin, irmax, wk, ier)
>         else
>         call cg_field_read_f(iccg, ibase, igrid, nsoluse,
>      +     fndesired(m), RealSingle, irmin, irmax, wk, ier)
>         end if
>         if (ier .ne. 0) call cg_error_exit_f
>         call reorderq(idima,jdima,kdima,idim,jdim,kdim,nfac,
>      +    nfaci,wk,irind,jrind,krind,tursav2(1,1,1,m))
>         enddo
>       end if
4717a5000,5034
> c   Go to Base node, read CFL3DTimeStep array from UserDefinedData
>       call cg_goto_f(iccg,ibase,ier,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_nuser_data_f(nuserdata,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .eq. 0) then
>         write(11,'('' no user data exists in base, so'',
>      +    '' no old time step is available: set to current'')')
>         dtold=dt
>       else if (nuserdata .gt. numfield) then
>         write(11,'('' Error... numfield too small in rsecord'')')
>         stop
>       else
>         do n=1,nuserdata
>           call cg_user_data_read_f(n,fieldname(n),ier)
>           if (ier .ne. 0) call cg_error_exit_f
>         enddo
>         do n=1,nuserdata
>           if(fieldname(n) .eq. 'CFL3DTimeStep') goto 101
>         enddo
>         write(11,'('' WARNING. No CFL3DTimeStep node exists'')')
>         write(11,'(''   setting dtold=dt and continuing'')')
>         dtold=dt
>         goto 201
>  101    continue
>         call cg_goto_f(iccg,ibase,ier,'UserDefinedData_t',n,'end')
>         if (ier .ne. 0) call cg_error_exit_f
>         if (idouble .eq. 1) then
>           call cg_array_read_as_f(1,RealDouble,dtold,ier)
>         else
>           call cg_array_read_as_f(1,RealSingle,dtold,ier)
>         end if
>         if (ier .ne. 0) call cg_error_exit_f
>       end if
>  201  continue
4721c5038,5039
<       subroutine reorderg(idim,jdim,kdim,wk,xyz)
---
>       subroutine reorderg(nfac,nfaci,idima,jdima,kdima,
>      .   idim,jdim,kdim,wk,xyz)
4725c5043
< c     the data)
---
> c     the data).
4728c5046,5057
< c      idim,jdim,kdim...dimensions used in arrays (integers)
---
> c      nfac.............factor denoting "level" of grid (e.g.,
> c                       1=grid on finest level, 2=1-level down,
> c                       4=2-levels down, 8=3-levels down,
> c                       16=4-levels down (integer)
> c      nfaci............same as nfac, except for i-direction only
> c                       (when 2-D, the i-direction does not coarsen)
> c                       (integer)
> c      idima,jdima,kdima...expected dimensions of this zone
> c                          (zone "igrid") at finest level (integers)
> c      idim,jdim,kdim...actual (GRIDPOINT) dimensions of existing data
> c                       for this zone (e.g., could be every other point
> c                       of fine grid) (integers)
4737c5066
<       dimension xyz(jdim,kdim,idim),wk(idim,jdim,kdim)
---
>       dimension xyz(jdim,kdim,idim),wk(idima,jdima,kdima)
4739,4742c5068,5077
<       do k=1,kdim
<       do j=1,jdim
<       do i=1,idim
<         xyz(j,k,i)=wk(i,j,k)
---
>       kk=0
>       do k=1,kdima,nfac
>       kk=kk+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>         xyz(jj,kk,ii)=wk(i,j,k)
4755c5090
< c     the data)
---
> c     the data).
4769c5104,5105
< c                       4=2-levels down, 8=3-levels down (integer)
---
> c                       4=2-levels down, 8=3-levels down,
> c                       16=4-levels down (integer)
4806c5142
< c     factor if on coarser level, and include rind (BC) data)
---
> c     factor if on coarser level, and include rind (BC) data).
4808c5144
< c     iflag=2, bci,bcj,bck,qi0,qj0,qk0 are not accessed
---
> c     iflag=2, bci,bcj,bck,qi0,qj0,qk0 are not accessed.
4813,4814c5149,5151
< c                       4=2-levels down, 8=3-levels down (integer)
< c      i2d..............0 if 3-D, 1 if 2-D
---
> c                       4=2-levels down, 8=3-levels down,
> c                       16=4-levels down (integer)
> c      i2d..............0 if 3-D, 1 if 2-D (integer)
4828,4830d5164
< c     
< c      irind,jrind,krind...= 0 if rind data exists for the direction,
< c                          = 1 if it does not (integers)
5015c5349
< c     needs to be read)
---
> c     needs to be read).
5038a5373
>       dimension idimvec(4)
5041a5377,5379
> c   Find out how many zones there are
>       call cg_nzones_f(iccg, ibase, nzones, ier)
>       if (ier .ne. 0) call cg_error_exit_f
5043c5381
<       do igrid=1,10000
---
>       do igrid=1,nzones
5045c5383
<       if (ier .ne. 0) goto 999
---
>       if (ier .ne. 0) call cg_error_exit_f
5063,5064c5401,5404
< c   If ANY RigidGridMotion_t nodes exist in CFL3D file, then it means that
< c   it is an unsteady run (there is unsteady data that needs to be read)
---
> c   If ANY RigidGridMotion_t nodes exist in CFL3D file -and- if
> c   ZoneIterativeData contains RigidGridMotionPointers, then it 
> c   it is an unsteady moving grid run (there is unsteady data that  
> c   needs to be read)
5073,5076c5413,5443
<         if (iflagg .eq. 0) then
<           iflagg = 2
<         else if (iflagg .eq. 1) then
<           iflagg = 3
---
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      +   'ZoneIterativeData_t',1,'end')
>         if (ier .eq. 0) then
> c         Find out how many arrays
>           call cg_narrays_f(narrays,ier)
>           if (ier .ne. 0) call cg_error_exit_f
>           if (narrays .gt. numfield) then
>             write(11,'('' Error.  Too many RigidGridMotion arrays.'')')
>             write(11,'(''   increase numfield in getiflagg'')')
>             stop
>           end if
>           do n=1,narrays
>             call cg_array_info_f(n,fieldname(n),itype,idatadim,
>      +        idimvec,ier)
>             if (ier .ne. 0) call cg_error_exit_f
>           enddo
>           imov=1
>           do n=1,narrays
>             if (fieldname(n) .eq. 'RigidGridMotionPointers') goto 101
>           enddo
>           write(11,'('' No RigidGridMotionPointers exists... assume'',
>      +      '' restart from non-moving grid case'')')
>           imov=0
>  101      continue
>           if (imov .eq. 1) then
>             if (iflagg .eq. 0) then
>               iflagg = 2
>             else if (iflagg .eq. 1) then
>               iflagg = 3
>             end if
>           end if
5080,5082d5446
<       write(11,'('' Error.  Too many zones!'')')
<       stop
<  999  continue
5123,5128c5487,5488
< c     Purpose:  Use ZoneIterativeData to store BC info
< c     necessary for CFL3D V6.  We do this because until a
< c     'UserDefinedDataArray' node is allowed in CGNS, there is no
< c     better place to put data arrays that are of different size from
< c     the grid size.
< c     If i2d=1, don't write qi0, vi0, or ti0
---
> c     Purpose:  Store BC info necessary for CFL3D V6 in a
> c     'UserDefinedData'.  If i2d=1, don't write qi0, vi0, or ti0 
5130c5490
< c     CGNS file unnecessarily!)
---
> c     CGNS file unnecessarily!).
5140c5500
< c      qi0,qj0,qk0......arrays of BC data (CONSERVED quantities) (real)
---
> c      qi0,qj0,qk0......arrays of BC data (PRIMITIVE quantities) (real)
5143c5503
< c      i2d..............0 if 3-D, 1 if 2-D
---
> c      i2d..............0 if 3-D, 1 if 2-D (integer)
5149a5510,5511
>       parameter(numnames=20)
> c
5155a5518
>       character*32 name(numnames)
5163,5167c5526,5534
< c   Go to ZoneIterativeData node
<       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
<      + 'ZoneIterativeData_t',1,'end')
<       if (ier .ne. 0) then
<         write(11,'('' Error.  ZoneIterativeData node does not exist'')')
---
> c   Go to Zone node and create a user-defined node
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_user_data_write_f('CFL3DBoundaryValues', ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_nuser_data_f(nuserdata, ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .gt. numnames) then
>         write(11,'('' Error... numnames too small in writebcs'')')
5169a5537,5546
>       do n=1,nuserdata
>         call cg_user_data_read_f(n, name(n), ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if(name(n) .eq. 'CFL3DBoundaryValues') then
>           nset=n
>         end if
>       enddo
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      +  'UserDefinedData_t',nset,'end')
>       if (ier .ne. 0) call cg_error_exit_f
5301,5307c5678,5679
< c     Purpose:  Reads CFL3D's BC info from 'ZoneIterativeData' node.
< c     (We are also using ZoneIterativeData to store BC info
< c     necessary for CFL3D V6.  We do this because until a
< c     'UserDefinedDataArray' node is allowed in CGNS, there is no
< c     better place to put data arrays that are of different size from
< c     the grid size.)
< c     If i2d=1, don't need to read qi0, vi0, or ti0
---
> c     Purpose:  Reads CFL3D's BC info.
> c     If i2d=1, don't need to read qi0, vi0, or ti0.
5317c5689
< c      i2d..............0 if 3-D, 1 if 2-D
---
> c      i2d..............0 if 3-D, 1 if 2-D (integer)
5319,5321c5691,5692
< c      qi0,qj0,qk0......arrays of BC data (CONSERVED or PRIMITIVE
< c                       quantities - same type as Q's read in
< c                       via readsoln) (real)
---
> c      qi0,qj0,qk0......arrays of BC data (PRIMITIVE quantities
> c                       (real)
5335c5706
<       dimension idata(2),jdata(4)
---
>       dimension idata(2),jdata(4),idimvec(4)
5344,5353c5715,5722
< c   Get Information about what is under ZoneIterativeData node
<       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
<      . 'ZoneIterativeData_t',1,'end')
<       if (ier .ne. 0) then
<         write(11,'('' WARNING... ZoneIterativeData node does not'',
<      +    '' exist'')')
<         write(11,'(''   not changing default BCs... continuing'')')
<         return
<       end if
<       call cg_narrays_f(narrays,ier)
---
> c   We must locate the BCs:
> c   In new method, they are stored under Zone in a UserDefinedData node
> c   called CFL3DBoundaryValues.  In old method, they were put under
> c   ZoneIterativeData (because there was no better place to put them
> c   at the time).  Check both places, just in case.
> c
> c   Go to Zone and look for UserDefinedData
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,'end')
5355,5356c5724,5727
<       if (narrays .gt. numnames) then
<         write(11,'('' WARNING.  Too many ZoneIterativeData arrays.'')')
---
>       call cg_nuser_data_f(nuserdata,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .gt. numnames) then
>         write(11,'('' WARNING... numnames too small in readbcs'')')
5360,5362c5731,5812
<       do n=1,narrays
<         call cg_array_info_f(n,name(n),itype,idatadim,idimvec,ier)
<       enddo
---
>       if (nuserdata .ne. 0) then
>         do n=1,nuserdata
>           call cg_user_data_read_f(n,name(n),ier)
>           if (ier .ne. 0) call cg_error_exit_f
>         enddo
>         do n=1,nuserdata
>           if(name(n) .eq. 'CFL3DBoundaryValues') goto 1001
>         enddo
> c   No CFL3DBoundaryValues... Try reading BCs from old location
>         write(11,'('' no BC data exists in UserDefinedData nodes'')')
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      .    'ZoneIterativeData_t',1,'end')
>         if (ier .ne. 0) then
>           write(11,'('' WARNING... BCs not in ZoneIterativeData or'',
>      +      '' a UserDefinedData array'')')
>           write(11,'(''   not changing default BCs... continuing'')')
>           return
>         end if
>         call cg_narrays_f(narrays,ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if (narrays .gt. numnames) then
>           write(11,'('' WARNING.  Too many ZoneIterativeData'',
>      +     '' arrays.'')')
>           write(11,'(''   not changing default BCs... continuing'')')
>           return
>         end if
>         write(11,'('' Reading BC info from ZoneIterativeData (old'',
>      +    '' method)'')')
>         write(11,'(''  ... it will be moved to new location of'',
>      +    '' UserDefinedData node CFL3DBoundaryValues when written'')')
>         do n=1,narrays
>           call cg_array_info_f(n,name(n),itype,idatadim,idimvec,ier)
>           if (ier .ne. 0) call cg_error_exit_f
>         enddo
>         goto 1002
> c   Read BCs from new location
>  1001   continue
>         write(11,'('' Reading BC info from UserDefinedData'')')
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      +    'UserDefinedData_t',n,'end')
>         if (ier .ne. 0) call cg_error_exit_f
>         call cg_narrays_f(narrays,ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if (narrays .gt. numnames) then
>           write(11,'('' WARNING.  Too many arrays in'',
>      +      '' CFL3DBoundaryValues...'')')
>           write(11,'(''   not changing default BCs... continuing'')')
>           return
>         end if
>         do n=1,narrays
>           call cg_array_info_f(n,name(n),itype,idatadim,idimvec,ier)
>           if (ier .ne. 0) call cg_error_exit_f
>         enddo
>  1002   continue
>       else
> c   Try reading BCs from old location
>         write(11,'('' no BC data exists in UserDefinedData nodes'')')
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      .    'ZoneIterativeData_t',1,'end')
>         if (ier .ne. 0) then
>           write(11,'('' WARNING... BCs not in ZoneIterativeData or'',
>      +      '' a UserDefinedData array'')')
>           write(11,'(''   not changing default BCs... continuing'')')
>           return
>         end if
>         call cg_narrays_f(narrays,ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if (narrays .gt. numnames) then
>           write(11,'('' WARNING.  Too many ZoneIterativeData'',
>      +      '' arrays.'')')
>           write(11,'(''   not changing default BCs... continuing'')')
>           return
>         end if
>         write(11,'('' Reading BC info from ZoneIterativeData (old'',
>      +    '' method)'')')
>         write(11,'(''  ... it will be moved to new location of'',
>      +    '' UserDefinedData node CFL3DBoundaryValues when written'')')
>         do n=1,narrays
>           call cg_array_info_f(n,name(n),itype,idatadim,idimvec,ier)
>           if (ier .ne. 0) call cg_error_exit_f
>         enddo
>       end if
5527c5977
<      .                  dthzmxmc,time2,time2mc,dt)
---
>      .                  dthzmxmc,time2,time2mc,dt,ialph)
5531c5981
< c     Also adds RigidGridMotionPointers to ZoneIterativeData
---
> c     Also adds RigidGridMotionPointers to ZoneIterativeData.
5547a5998,5999
> c      ialph............parameter in CFL3D for determining whether y
> c                       or z is "up" (integer)
5590,5598c6042,6062
<       data1(1,1)=xorig0
<       data1(2,1)=yorig0
<       data1(3,1)=zorig0
<       data1(1,2)=xorig
<       data1(2,2)=yorig
<       data1(3,2)=zorig
<       data(1)=thetax
<       data(2)=thetay
<       data(3)=thetaz
---
>       if (ialph .eq. 0) then
>         data1(1,1)=xorig0
>         data1(2,1)=yorig0
>         data1(3,1)=zorig0
>         data1(1,2)=xorig
>         data1(2,2)=yorig
>         data1(3,2)=zorig
>         data(1)=thetax
>         data(2)=thetay
>         data(3)=thetaz
>       else
>         data1(1,1)=xorig0
>         data1(2,1)=zorig0
>         data1(3,1)=-yorig0
>         data1(1,2)=xorig
>         data1(2,2)=zorig
>         data1(3,2)=-yorig
>         data(1)=thetax
>         data(2)=thetaz
>         data(3)=-thetay
>       end if
5601a6066
>         if (ier .ne. 0) call cg_error_exit_f
5603a6069
>         if (ier .ne. 0) call cg_error_exit_f
5606a6073
>         if (ier .ne. 0) call cg_error_exit_f
5608a6076
>         if (ier .ne. 0) call cg_error_exit_f
5609a6078,6083
> c
> c   Next write other (cfl3d-specific) data:
>       call cg_user_data_write_f('CFL3DParameters', ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'RigidGridMotion_t',1,'UserDefinedData_t',1,'end')
5612d6085
< c   Next write other (cfl3d-specific) real data:
5782a6256
>       if (ier .ne. 0) call cg_error_exit_f
5783a6258
>       if (ier .ne. 0) call cg_error_exit_f
5784a6260
>       if (ier .ne. 0) call cg_error_exit_f
5785a6262
>       if (ier .ne. 0) call cg_error_exit_f
5792c6269
<       subroutine rgrdmov(iccg,ibase,igrid,
---
>       subroutine rgrdmov(iccg,ibase,igrid,ialph,
5804c6281
< c     Purpose:  Reads 'GridMotionDefinition' node moving grid info
---
> c     Purpose:  Reads 'GridMotionDefinition' node moving grid info.
5811a6289,6290
> c      ialph............parameter in CFL3D for determining whether y
> c                       or z is "up" (integer)
5826,5827c6305,6306
<       dimension data(3),data1(3,2)
<       character*32 name(numnames),namer
---
>       dimension data(3),data1(3,2),idimvec(4)
>       character*32 name(numnames)
5900,5901d6378
< c   Read RigidGridMotion_t node
<       call cg_rigid_motion_read_f(iccg,ibase,igrid,1,namer,itype,ier)
5915a6393
>         if (ier .ne. 0) call cg_error_exit_f
5930,5935c6408,6422
<       xorig0=data1(1,1)
<       yorig0=data1(2,1)
<       zorig0=data1(3,1)
<       xorig=data1(1,2)
<       yorig=data1(2,2)
<       zorig=data1(3,2)
---
>       if (ialph .eq. 0) then
>         xorig0=data1(1,1)
>         yorig0=data1(2,1)
>         zorig0=data1(3,1)
>         xorig=data1(1,2)
>         yorig=data1(2,2)
>         zorig=data1(3,2)
>       else
>         xorig0=data1(1,1)
>         zorig0=data1(2,1)
>         yorig0=-data1(3,1)
>         xorig=data1(1,2)
>         zorig=data1(2,2)
>         yorig=-data1(3,2)
>       end if
5950,5952c6437,6476
<       thetax=data(1)
<       thetay=data(2)
<       thetaz=data(3)
---
>       if (ialph .eq. 0) then
>         thetax=data(1)
>         thetay=data(2)
>         thetaz=data(3)
>       else
>         thetax=data(1)
>         thetaz=data(2)
>         thetay=-data(3)
>       end if
> c
>       call cg_nuser_data_f(nuserdata,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .ne. 1) then
>         write(11,'('' Error... should be 1 user data node in'', 
>      +    '' RigidGridMotion'')')
>         stop
>       else
>         call cg_user_data_read_f(1,name(1),ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if(name(1) .eq. 'CFL3DParameters') goto 1004
>         write(11,'('' Error. No CFL3DParameters node exists'')')
>         stop
>  1004   continue
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'RigidGridMotion_t',1,'UserDefinedData_t',1,'end')
>         if (ier .ne. 0) call cg_error_exit_f
>       end if
> c
> c   Find out how many arrays
>       call cg_narrays_f(narrays,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (narrays .gt. numnames) then
>         write(11,'('' Error.  Too many RigidGridMotion arrays.'')')
>         write(11,'(''   increase numnames in rgrdmov'')')
>         stop
>       end if
>       do n=1,narrays
>         call cg_array_info_f(n,name(n),itype,idatadim,idimvec,ier)
>         if (ier .ne. 0) call cg_error_exit_f
>       enddo
6302c6826
< c     parameter
---
> c     parameter.
6319c6843,6844
<       character*32 name(numnames),namer
---
>       dimension idimvec(4)
>       character*32 name(numnames)
6334,6336d6858
< c   Read RigidGridMotion_t node
<       call cg_rigid_motion_read_f(iccg,ibase,igrid,1,namer,itype,ier)
<       if (ier .ne. 0) call cg_error_exit_f
6340a6863,6880
> c   Find out how many UserDefinedData_t nodes there are
>       call cg_nuser_data_f(nuserdata,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .ne. 1) then
>         write(11,'('' Error... should be 1 user data node in'',
>      +    '' RigidGridMotion'')')
>         stop
>       else
>         call cg_user_data_read_f(1,name(1),ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if(name(1) .eq. 'CFL3DParameters') goto 1004
>         write(11,'('' Error. No CFL3DParameters node exists'')')
>         stop
>  1004   continue
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'RigidGridMotion_t',1,'UserDefinedData_t',1,'end')
>         if (ier .ne. 0) call cg_error_exit_f
>       end if
6350a6891
>         if (ier .ne. 0) call cg_error_exit_f
6372,6373c6913,6914
<      .            jcsf,kcsi,kcsf,jdim,kdim,idim,
<      .            x,y,z,xnm2,ynm2,znm2,wk)
---
>      .            jcsf,kcsi,kcsf,jdima,kdima,idima,
>      .            jdim,kdim,idim,x,y,z,xnm2,ynm2,znm2,wk,ialph,i2d)
6377,6381d6917
< c     All the CFL3D-specific info is currently stored under
< c     the RigidGridMotion node (because arbitrary arrays are
< c     not allowed under ArbitraryGridMotion).
< c     We do this until a 'UserDefinedDataArray' node is allowed in 
< c     CGNS.
6383c6919
< c     to ZoneIterativeData
---
> c     to ZoneIterativeData.
6419c6955,6959
< c      jdim,kdim,idim...dimensions of grid (integers)
---
> c      idima,jdima,kdima...expected dimensions of this zone
> c                          (zone "igrid"), at finest level (integers)
> c      idim,jdim,kdim...actual (GRIDPOINT) dimensions of existing data
> c                       for this zone (e.g., could be every other point
> c                       of fine grid) (integers)
6427c6967,6970
< c                       (idim*jdim*kdim) or larger (real)
---
> c                       (idima*jdima*kdima) or larger (real)
> c      ialph............parameter in CFL3D for determining whether y
> c                       or z is "up" (integer)
> c      i2d..............0 if 3-D, 1 if 2-D (integer)
6445c6988
<       dimension wk(idim,jdim,kdim)
---
>       dimension wk(idima,jdima,kdima)
6446a6990
>       character*52 string1
6473c7017,7029
< c   Write CFL3D-specific info into RigidGridMotion node for now
---
> c   Set dimensions
>       jdata(1)=idima
>       jdata(2)=jdima
>       jdata(3)=kdima
> c   Initialize wk array to zero
>       do i=1,idima
>       do j=1,jdima
>       do k=1,kdima
>         wk(i,j,k)=0.
>       enddo
>       enddo
>       enddo
> c   Write CFL3D-specific info
6475c7031,7035
<      + 'RigidGridMotion_t',1,'end')
---
>      + 'ArbitraryGridMotion_t',1,'end')
>       call cg_user_data_write_f('CFL3DParameters', ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'ArbitraryGridMotion_t',1,'UserDefinedData_t',1,'end')
6476a7037
> c
6493c7054
<      +   Vtrnsae,ier)
---
>      +   vtrnsae,ier)
6496c7057
<      +   Vtrnsae,ier)
---
>      +   vtrnsae,ier)
6608,6611d7168
< c   Set dimensions for grid info
<       jdata(1)=idim
<       jdata(2)=jdim
<       jdata(3)=kdim
6619a7177,7203
> c   First, get "factor" in case want to write every other point, etc
>       if(idim.eq.idima .and. jdim.eq.jdima .and. kdim.eq.kdima) then
>         nfac=1
>         string1='Fine grid level'
>       else if(jdim.eq.(jdima+1)/2 .and. kdim.eq.(kdima+1)/2) then
>         nfac=2
>         string1='Every-2nd-gridpoint written (1 level down)'
>       else if(jdim.eq.(jdima+3)/4 .and. kdim.eq.(kdima+3)/4) then
>         nfac=4
>         string1='Every-4th-gridpoint written (2 levels down)'
>       else if(jdim.eq.(jdima+7)/8 .and. kdim.eq.(kdima+7)/8) then
>         nfac=8
>         string1='Every-8th-gridpoint written (3 levels down)'
>       else if(jdim.eq.(jdima+15)/16 .and. kdim.eq.(kdima+15)/16) then
>         nfac=16
>         string1='Every-16th-gridpoint written (4 levels down)'
>       else
>         write(11,'('' Error.  Desired grid level not supported'')')
>         stop
>       end if
>       if(i2d .eq. 1) then
>         nfaci=1
>       else
>         nfaci=nfac
>       end if
>       call cg_descriptor_write_f('Information',string1,ier)
>       if (ier .ne. 0) call cg_error_exit_f
6621,6624c7205,7214
<       do i=1,idim
<       do j=1,jdim
<       do k=1,kdim
<         wk(i,j,k)=x(j,k,i)
---
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=x(jj,kk,ii)
6637,6640c7227,7237
<       do i=1,idim
<       do j=1,jdim
<       do k=1,kdim
<         wk(i,j,k)=y(j,k,i)
---
>       if (ialph .eq. 0) then
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=y(jj,kk,ii)
6644,6645c7241,7257
<       if (idouble .eq. 1) then
<         call cg_array_write_f('CoordinateY',RealDouble,3,jdata,
---
>       else
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=z(jj,kk,ii)
>       enddo
>       enddo
>       enddo
>       end if
>       if (idouble .eq. 1) then
>         call cg_array_write_f('CoordinateY',RealDouble,3,jdata,
6653,6656c7265,7289
<       do i=1,idim
<       do j=1,jdim
<       do k=1,kdim
<         wk(i,j,k)=z(j,k,i)
---
>       if (ialph .eq. 0) then
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=z(jj,kk,ii)
>       enddo
>       enddo
>       enddo
>       else
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=-y(jj,kk,ii)
6659a7293
>       end if
6676a7311,7312
>       call cg_descriptor_write_f('Information',string1,ier)
>       if (ier .ne. 0) call cg_error_exit_f
6678,6681c7314,7323
<       do i=1,idim
<       do j=1,jdim
<       do k=1,kdim
<         wk(i,j,k)=xnm2(j,k,i)
---
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=xnm2(jj,kk,ii)
6693,6697c7335,7346
< c   Write X
<       do i=1,idim
<       do j=1,jdim
<       do k=1,kdim
<         wk(i,j,k)=ynm2(j,k,i)
---
> c   Write Y
>       if (ialph .eq. 0) then
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=ynm2(jj,kk,ii)
6700a7350,7364
>       else
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=znm2(jj,kk,ii)
>       enddo
>       enddo
>       enddo
>       end if
6709,6713c7373,7386
< c   Write X
<       do i=1,idim
<       do j=1,jdim
<       do k=1,kdim
<         wk(i,j,k)=znm2(j,k,i)
---
> c   Write Z
>       if (ialph .eq. 0) then
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=znm2(jj,kk,ii)
>       enddo
>       enddo
6714a7388,7398
>       else
>       ii=0
>       do i=1,idima,nfaci
>       ii=ii+1
>       jj=0
>       do j=1,jdima,nfac
>       jj=jj+1
>       kk=0
>       do k=1,kdima,nfac
>         kk=kk+1
>         wk(i,j,k)=-ynm2(jj,kk,ii)
6716a7401,7402
>       enddo
>       end if
6731,6736c7417
< c     Purpose:  Get parameter nsegdfrm from deforming grid info
< c     This parameter is currently stored under
< c     the RigidGridMotion node (because arbitrary arrays are
< c     not allowed under ArbitraryGridMotion).
< c     We do this until a 'UserDefinedDataArray' node is allowed in
< c     CGNS.
---
> c     Purpose:  Get parameter nsegdfrm from deforming grid info.
6752c7433,7434
<       character*32 name(numnames),namer
---
>       dimension idimvec(4)
>       character*32 name(numnames)
6754,6755c7436,7437
< c   Find out how many RigidGridMotion_t nodes there are
<       call cg_n_rigid_motions_f(iccg,ibase,igrid,nmotions,ier)
---
> c   Find out how many ArbitraryGridMotion_t nodes there are
>       call cg_n_arbitrary_motions_f(iccg,ibase,igrid,nmotions,ier)
6758,6759c7440,7441
<         write(11,'('' Error.  No RigidGridMotion nodes, igrid='',i5)') 
<      +   igrid
---
>         write(11,'('' Error.  No ArbitraryGridMotion nodes,'',
>      +   '' igrid='',i5)') igrid
6764c7446,7447
<         write(11,'('' Error, more than 1 RigidGridMotion_t nodes!'')')
---
>         write(11,'('' Error, more than 1 ArbitraryGridMotion_t'',
>      +   '' nodes!'')')
6767,6770c7450
< c   Read RigidGridMotion_t node
<       call cg_rigid_motion_read_f(iccg,ibase,igrid,1,namer,itype,ier)
<       if (ier .ne. 0) call cg_error_exit_f
< c   Go to RigidGridMotion_t node
---
> c   Go to ArbitraryGridMotion_t node
6772c7452
<      + 'RigidGridMotion_t',1,'end')
---
>      + 'ArbitraryGridMotion_t',1,'end')
6773a7454,7471
> c   Find out how many UserDefinedData_t nodes there are
>       call cg_nuser_data_f(nuserdata,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .ne. 1) then
>         write(11,'('' Error... should be 1 user data node in'',
>      +    '' ArbitraryGridMotion'')')
>         stop
>       else
>         call cg_user_data_read_f(1,name(1),ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if(name(1) .eq. 'CFL3DParameters') goto 1004
>         write(11,'('' Error. No CFL3DParameters node exists'')')
>         stop
>  1004   continue
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'ArbitraryGridMotion_t',1,'UserDefinedData_t',1,'end')
>         if (ier .ne. 0) call cg_error_exit_f
>       end if
6778,6779c7476,7477
<         write(11,'('' Error.  Too many RigidGridMotion arrays.'')')
<         write(11,'(''   increase numnames in getnsegdfrm'')')
---
>         write(11,'('' Error.  Too many ArbitraryGridMotion arrays.'')')
>         write(11,'(''   increase numnames in readiuns'')')
6783a7482
>         if (ier .ne. 0) call cg_error_exit_f
6784a7484
> c
6799c7499,7500
<      .            wk,jdim,kdim,idim,idefrm,utrnsae,
---
>      .            wk,jdima,kdima,idima,i2d,
>      .            jdim,kdim,idim,ialph,idefrm,utrnsae,
6809,6814c7510
< c     to get idfrmseg)
< c     All the CFL3D-specific info is currently stored under
< c     the RigidGridMotion node (because arbitrary arrays are
< c     not allowed under ArbitraryGridMotion).
< c     We do this until a 'UserDefinedDataArray' node is allowed in
< c     CGNS.
---
> c     to get idfrmseg).
6832c7528,7535
< c      jdim,kdim,idim...dimensions of grid (integers)
---
> c      idima,jdima,kdima...expected dimensions of this zone
> c                          (zone "igrid"), at finest level (integers)
> c      i2d..............0 if 3-D, 1 if 2-D (integer)
> c      idim,jdim,kdim...actual (GRIDPOINT) dimensions of existing data
> c                       for this zone (e.g., could be every other point
> c                       of fine grid) (integers)
> c      ialph............parameter in CFL3D for determining whether y
> c                       or z is "up" (integer)
6878,6879c7581,7584
<       dimension wk(idim,jdim,kdim)
<       character*32 name(numnames),namer,nameg(3)
---
>       dimension wk(idima,jdima,kdima)
>       dimension idimvec(4)
>       character*32 name(numnames),nameg(3),namei
>       character*52 text
6887,6888c7592,7593
< c   Find out how many RigidGridMotion_t nodes there are
<       call cg_n_rigid_motions_f(iccg,ibase,igrid,nmotions,ier)
---
> c   Find out how many ArbitraryGridMotion_t nodes there are
>       call cg_n_arbitrary_motions_f(iccg,ibase,igrid,nmotions,ier)
6891,6893c7596,7598
<         write(11,'('' Error.  No RigidGridMotion nodes, igrid='',i5)')
<      +   igrid
<         write(11,'(''   cannot get deforming data'')')
---
>         write(11,'('' Error.  No ArbitraryGridMotion nodes,'',
>      +   '' igrid='',i5)') igrid
>         write(11,'(''   cannot get nsegdfrm'')')
6897c7602,7603
<         write(11,'('' Error, more than 1 RigidGridMotion_t nodes!'')')
---
>         write(11,'('' Error, more than 1 ArbitraryGridMotion_t'',
>      +   '' nodes!'')')
6900,6903c7606
< c   Read RigidGridMotion_t node
<       call cg_rigid_motion_read_f(iccg,ibase,igrid,1,namer,itype,ier)
<       if (ier .ne. 0) call cg_error_exit_f
< c   Go to RigidGridMotion_t node
---
> c   Go to ArbitraryGridMotion_t node
6905c7608,7611
<      + 'RigidGridMotion_t',1,'end')
---
>      + 'ArbitraryGridMotion_t',1,'end')
>       if (ier .ne. 0) call cg_error_exit_f
> c   Find out how many UserDefinedData_t nodes there are
>       call cg_nuser_data_f(nuserdata,ier)
6906a7613,7627
>       if (nuserdata .ne. 1) then
>         write(11,'('' Error... should be 1 user data node in'',
>      +    '' ArbitraryGridMotion'')')
>         stop
>       else
>         call cg_user_data_read_f(1,name(1),ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if(name(1) .eq. 'CFL3DParameters') goto 1004
>         write(11,'('' Error. No CFL3DParameters node exists'')')
>         stop
>  1004   continue
>         call cg_goto_f(iccg,ibase,ier,'Zone_t',igrid,
>      + 'ArbitraryGridMotion_t',1,'UserDefinedData_t',1,'end')
>         if (ier .ne. 0) call cg_error_exit_f
>       end if
6911c7632
<         write(11,'('' Error.  Too many RigidGridMotion arrays.'')')
---
>         write(11,'('' Error.  Too many ArbitraryGridMotion arrays.'')')
6916a7638
>         if (ier .ne. 0) call cg_error_exit_f
7184a7907,7927
> c   First, get "factor" in case want to read every other point, etc
>       if(idim.eq.idima .and. jdim.eq.jdima .and. kdim.eq.kdima) then
>         nfac=1
>       else if(jdim.eq.(jdima+1)/2 .and. kdim.eq.(kdima+1)/2) then
>         nfac=2
>       else if(jdim.eq.(jdima+3)/4 .and. kdim.eq.(kdima+3)/4) then
>         nfac=4
>       else if(jdim.eq.(jdima+7)/8 .and. kdim.eq.(kdima+7)/8) then
>         nfac=8
>       else if(jdim.eq.(jdima+15)/16 .and. kdim.eq.(kdima+15)/16) then
>         nfac=16
>       else
>         write(11,'('' Error.  Desired grid level not supported'')')
>         stop
>       end if
>       if(i2d .eq. 1) then
>         nfaci=1
>       else
>         nfaci=nfac
>       end if
> c
7207a7951
> c
7217a7962
>         if (ier .ne. 0) call cg_error_exit_f
7233c7978,7979
<       call reorderg(idim,jdim,kdim,wk,x)
---
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,wk,x)
7248c7994,8000
<       call reorderg(idim,jdim,kdim,wk,y)
---
>       if (ialph .eq. 0) then
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,wk,y)
>       else
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,wk,z)
>       end if
7263c8015,8021
<       call reorderg(idim,jdim,kdim,wk,z)
---
>       if (ialph .eq. 0) then
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,wk,z)
>       else
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,-wk,y)
>       end if
7284a8043
>         if (ier .ne. 0) call cg_error_exit_f
7300c8059,8060
<       call reorderg(idim,jdim,kdim,wk,xnm2)
---
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,wk,xnm2)
7315c8075,8081
<       call reorderg(idim,jdim,kdim,wk,ynm2)
---
>       if (ialph .eq. 0) then
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,wk,ynm2)
>       else
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,wk,znm2)
>       end if
7330c8096,8439
<       call reorderg(idim,jdim,kdim,wk,znm2)
---
>       if (ialph .eq. 0) then
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,wk,znm2)
>       else
>       call reorderg(nfac,nfaci,idima,jdima,kdima,
>      +   idim,jdim,kdim,-wk,ynm2)
>       end if
> c
>       return
>       end
> 
>       subroutine waeromode(iccg,ibase,timekeep,xxn,gforcn,
>      .         gforcnm,aehist,ncycmax,nmds,maxaes,
>      .         ntt,naesrf,wk,maxnum,wk2,maxnum2)
> c**********************************************************************
> c     Purpose:  Write aeroelastic mode data.
> c
> c   INPUTS:
> c      iccg.............CGNS file index number (determined outside
> c                       this routine) (integer)
> c      ibase............CGNS base index number (determined outside
> c                       this routine) (integer)
> c      timekeep, xnn, gforcn, gforcnm, aehist
> c           ............aeroelastic mode data (real)
> c      ncycmax, nmds, maxaes, ntt
> c           ............dimension arguments (integer)
> c      naesrf...........number of aeroelastic surfaces (integer)
> c      wk...............working space needed, of dimension
> c                       (maxnum) or larger (real)
> c      maxnum...........dimension of wk array (integer)
> c      wk2..............working space needed, of dimension
> c                       (maxnum2) or larger (real)
> c      maxnum2..........dimension of wk2 array (integer)
> c   OUTPUTS:
> c      none
> c**********************************************************************
> c
> #     include "cgnslib_f.h"
> c
>       parameter (numnames=5)
> c
>       dimension timekeep(ntt),xxn(2*nmds,maxaes),
>      + gforcn(2*nmds,maxaes),gforcnm(2*nmds,maxaes),
>      + aehist(ncycmax,3,nmds,maxaes)
>       dimension wk(maxnum),wk2(maxnum2)
>       character name(numnames)*32
> c
> c   Determine if single or double precision is being used:
>       idouble=0
> #if defined DBLE_PRECSN
>       idouble=1
> #endif
> c
> c   Go to Base node, write CFL3DAeroModeData array as UserDefinedData
>       call cg_goto_f(iccg,ibase,ier,'end')
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_user_data_write_f('CFL3DAeroModeData', ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       call cg_nuser_data_f(nuserdata, ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .gt. numnames) then
>         write(11,'('' Error... numnames too small in waeromode'')')
>         stop
>       end if
>       do n=1,nuserdata
>         call cg_user_data_read_f(n, name(n), ier)
>         if (ier .ne. 0) call cg_error_exit_f
>         if(name(n) .eq. 'CFL3DAeroModeData') then
>           nset=n
>         end if
>       enddo
>       call cg_goto_f(iccg,ibase,ier,'UserDefinedData_t',nset,'end')
>       if (ier .ne. 0) call cg_error_exit_f
> c
> c   Write data
> c
>       if (idouble .eq. 1) then
>         call cg_array_write_f('Timekeep',RealDouble,1,ntt,timekeep,ier)
>       else
>         call cg_array_write_f('Timekeep',RealSingle,1,ntt,timekeep,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
>       j=0
>       do i=1,naesrf
>         do n=1,2*nmds
>           j=j+1
>           wk(j)=xxn(n,i)
>         enddo
>       enddo
>       if (idouble .eq. 1) then
>         call cg_array_write_f('Xxn',RealDouble,1,j,wk,ier)
>       else
>         call cg_array_write_f('Xxn',RealSingle,1,j,wk,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
>       j=0
>       do i=1,naesrf
>         do n=1,2*nmds
>           j=j+1
>           wk(j)=gforcn(n,i)
>         enddo
>       enddo
>       if (idouble .eq. 1) then
>         call cg_array_write_f('Gforcn',RealDouble,1,j,wk,ier)
>       else
>         call cg_array_write_f('Gforcn',RealSingle,1,j,wk,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
>       j=0
>       do i=1,naesrf
>         do n=1,2*nmds
>           j=j+1
>           wk(j)=gforcnm(n,i)
>         enddo
>       enddo
>       if (idouble .eq. 1) then
>         call cg_array_write_f('Gforcnm',RealDouble,1,j,wk,ier)
>       else
>         call cg_array_write_f('Gforcnm',RealSingle,1,j,wk,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
>       j=0
>       do i=1,naesrf
>         do n=1,nmds
>           do m=1,3
>             do l=1,ntt
>               j=j+1
>               wk2(j)=aehist(l,m,n,i)
>             enddo
>           enddo
>         enddo
>       enddo
>       if (idouble .eq. 1) then
>         call cg_array_write_f('Aehist',RealDouble,1,j,wk2,ier)
>       else
>         call cg_array_write_f('Aehist',RealSingle,1,j,wk2,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
>       return
>       end
> 
>       subroutine raeromode(iccg,ibase,ncycmax,nmds,maxaes,
>      .         ntt,naesrf,wk,maxnum,wk2,maxnum2,
>      .         timekeep,xxn,gforcn,gforcnm,aehist)
> c**********************************************************************
> c     Purpose:  Read aeroelastic mode data.
> c
> c   INPUTS:
> c      iccg.............CGNS file index number (determined outside
> c                       this routine) (integer)
> c      ibase............CGNS base index number (determined outside
> c                       this routine) (integer)
> c      ncycmax, nmds, maxaes, ntt
> c           ............dimension arguments (integer)
> c      naesrf...........number of aeroelastic surfaces (integer)
> c      wk...............working space needed, of dimension
> c                       (maxnum) or larger (real)
> c      maxnum...........dimension of wk array (integer)
> c      wk2..............working space needed, of dimension
> c                       (maxnum2) or larger (real)
> c      maxnum2..........dimension of wk2 array (integer)
> c   OUTPUTS:
> c      timekeep, xnn, gforcn, gforcnm, aehist
> c           ............aeroelastic mode data (real)
> c**********************************************************************
> c
> #     include "cgnslib_f.h"
> c
>       parameter (numnames=5)
> c
>       dimension timekeep(ntt),xxn(2*nmds,maxaes),
>      + gforcn(2*nmds,maxaes),gforcnm(2*nmds,maxaes),
>      + aehist(ncycmax,3,nmds,maxaes)
>       dimension wk(maxnum),wk2(maxnum2),idimvec(numnames)
>       character name(numnames)*32
> c
> c   Determine if single or double precision is being used:
>       idouble=0
> #if defined DBLE_PRECSN
>       idouble=1
> #endif
> c
> c   Go to Base node:
>       call cg_goto_f(iccg,ibase,ier,'end')
> c   Find out how many UserDefinedData_t nodes there are
>       call cg_nuser_data_f(nuserdata,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (nuserdata .gt. numnames) then
>         write(11,'('' Error... numnames not big enough'',
>      +    '' in raeromode'')')
>         write(11,'(''   increase numnames in raeromode'')')
>         stop
>       else
>         do n=1,nuserdata
>           call cg_user_data_read_f(n, name(n), ier)
>           if (ier .ne. 0) call cg_error_exit_f
>           if(name(n) .eq. 'CFL3DAeroModeData') goto 100
>         enddo
>         write(11,'('' Error. No CFL3DAeroModeData node exists'')')
>         stop
>  100    continue
>         call cg_goto_f(iccg,ibase,ier,'UserDefinedData_t',n,'end')
>         if (ier .ne. 0) call cg_error_exit_f
>       end if
> c   Find out how many arrays
>       call cg_narrays_f(narrays,ier)
>       if (ier .ne. 0) call cg_error_exit_f
>       if (narrays .gt. numnames) then
>         write(11,'('' Error.  Too many arrays under'',
>      +    '' CFL3DAeroModeData'')')
>         write(11,'(''   increase numnames in raeromode'')')
>         stop
>       end if
>       do n=1,narrays
>         call cg_array_info_f(n,name(n),itype,idatadim,idimvec(n),ier)
>         if (ier .ne. 0) call cg_error_exit_f
>       enddo
> c
> c   Get Timekeep
>       do n=1,narrays
>         if (name(n) .eq. 'Timekeep') goto 101
>       enddo
>       write(11,'('' Error. No Timekeep node exists'')')
>       stop
>  101  continue
>       if (idimvec(n) .ne. ntt) then
>         write(11,'('' Error, Timekeep is wrong size'')')
>         stop
>       end if
>       if (idouble .eq. 1) then
>         call cg_array_read_as_f(n,RealDouble,timekeep,ier)
>       else
>         call cg_array_read_as_f(n,RealSingle,timekeep,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
> c
> c   Get Xxn
>       do n=1,narrays
>         if (name(n) .eq. 'Xxn') goto 201
>       enddo
>       write(11,'('' Error. No Xxn node exists'')')
>       stop
>  201  continue
>       if (idimvec(n) .ne. maxnum) then
>         write(11,'('' Error, Xxn is wrong size'')')
>         stop
>       end if
>       if (idouble .eq. 1) then
>         call cg_array_read_as_f(n,RealDouble,wk,ier)
>       else
>         call cg_array_read_as_f(n,RealSingle,wk,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
>       j=0
>       do i=1,naesrf
>         do n=1,2*nmds
>           j=j+1
>           xxn(n,i)=wk(j)
>         enddo
>       enddo
> c
> c   Get Gforcn
>       do n=1,narrays
>         if (name(n) .eq. 'Gforcn') goto 301
>       enddo
>       write(11,'('' Error. No Gforcn node exists'')')
>       stop
>  301  continue
>       if (idimvec(n) .ne. maxnum) then
>         write(11,'('' Error, Gforcn is wrong size'')')
>         stop
>       end if
>       if (idouble .eq. 1) then
>         call cg_array_read_as_f(n,RealDouble,wk,ier)
>       else
>         call cg_array_read_as_f(n,RealSingle,wk,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
>       j=0
>       do i=1,naesrf
>         do n=1,2*nmds
>           j=j+1
>           gforcn(n,i)=wk(j)
>         enddo
>       enddo
> c
> c   Get Gforcnm
>       do n=1,narrays
>         if (name(n) .eq. 'Gforcnm') goto 401
>       enddo
>       write(11,'('' Error. No Gforcnm node exists'')')
>       stop
>  401  continue
>       if (idimvec(n) .ne. maxnum) then
>         write(11,'('' Error, Gforcnm is wrong size'')')
>         stop
>       end if
>       if (idouble .eq. 1) then
>         call cg_array_read_as_f(n,RealDouble,wk,ier)
>       else
>         call cg_array_read_as_f(n,RealSingle,wk,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
>       j=0
>       do i=1,naesrf
>         do n=1,2*nmds
>           j=j+1
>           gforcnm(n,i)=wk(j)
>         enddo
>       enddo
> c
> c   Get Aehist
>       do n=1,narrays
>         if (name(n) .eq. 'Aehist') goto 501
>       enddo
>       write(11,'('' Error. No Aehist node exists'')')
>       stop
>  501  continue
>       if (idimvec(n) .ne. maxnum2) then
>         write(11,'('' Error, Aehist is wrong size'')')
>         stop
>       end if
>       if (idouble .eq. 1) then
>         call cg_array_read_as_f(n,RealDouble,wk2,ier)
>       else
>         call cg_array_read_as_f(n,RealSingle,wk2,ier)
>       end if
>       if (ier .ne. 0) call cg_error_exit_f
>       j=0
>       do i=1,naesrf
>         do n=1,nmds
>           do m=1,3
>             do l=1,ntt
>               j=j+1
>               aehist(l,m,n,i)=wk2(j)
>             enddo
>           enddo
>         enddo
>       enddo
7335a8445
> 
Index: source/cfl3d/libs/deform.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/deform.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
11c11
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
35,75c35
<       dimension nou(nbuf),idefrm(maxbl)
<       dimension x(jdim,kdim,idim),y(jdim,kdim,idim),z(jdim,kdim,idim)
<       dimension xnm2(jdim,kdim,idim),ynm2(jdim,kdim,idim),
<      .          znm2(jdim,kdim,idim),vel(jdim,kdim,idim,3)
<       dimension xnm1(jdim,kdim,idim),ynm1(jdim,kdim,idim),
<      .          znm1(jdim,kdim,idim)
<       dimension deltj(kdim,idim,3,2),deltk(jdim,idim,3,2),
<      .          delti(jdim,kdim,3,2)
<       dimension icsi(maxbl,maxsegdg),icsf(maxbl,maxsegdg),
<      .          jcsi(maxbl,maxsegdg),jcsf(maxbl,maxsegdg),
<      .          kcsi(maxbl,maxsegdg),kcsf(maxbl,maxsegdg)
<       dimension nbci0(maxbl),nbcidim(maxbl),nbcj0(maxbl),
<      .          nbcjdim(maxbl),nbck0(maxbl),nbckdim(maxbl),
<      .          ibcinfo(maxbl,maxseg,7,2),jbcinfo(maxbl,maxseg,7,2),
<      .          kbcinfo(maxbl,maxseg,7,2)
<       dimension wk(9*nsurf),slavept(nslave,3,nmaster,5)
<       dimension iskip(maxbl),jskip(maxbl),kskip(maxbl)
<       dimension nsegdfrm(maxbl),idfrmseg(maxbl,maxsegdg),
<      .          iaesurf(maxbl,maxsegdg)
< c
<       dimension dx1(jdim,kdim,idim),dy1(jdim,kdim,idim),
<      .          dz1(jdim,kdim,idim),dx2(jdim,kdim,idim),
<      .          dy2(jdim,kdim,idim),dz2(jdim,kdim,idim),
<      .          dx3(jdim,kdim,idim),dy3(jdim,kdim,idim),
<      .          dz3(jdim,kdim,idim),dx(jdim,kdim,idim),
<      .          dy(jdim,kdim,idim),dz(jdim,kdim,idim),
<      .          arci(jdim,kdim,idim),arcj(jdim,kdim,idim),
<      .          arck(jdim,kdim,idim),ibl(nsurf)
<       dimension jend(2),jsta(2)
<       dimension dvol(jdim*idim*kdim)
<       dimension xok(jdim*idim,6) 
<       dimension xoj(kdim*idim,6),xoi(jdim*kdim,6) 
< c
<       pointer (ip_dvol,dvol),(ip_xok,xok) 
<       pointer (ip_xoi,xoi),(ip_xoj,xoj) 
<       pointer (ip_jend,jend),(ip_jsta,jsta)
<       pointer (ip_dx1,dx1),(ip_dy1,dy1),(ip_dz1,dz1),
<      .        (ip_dx2,dx2),(ip_dy2,dy2),(ip_dz2,dz2),
<      .        (ip_dx3,dx3),(ip_dy3,dy3),(ip_dz3,dz3),
<      .        (ip_arci,arci),(ip_arcj,arcj),(ip_arck,arck),
<      .        (ip_dx,dx),(ip_dy,dy),(ip_dz,dz),(ip_ibl,ibl)
---
>       integer stats
76a37,98
>       dimension delti(jdim,kdim,3,2)
>       dimension deltj(kdim,idim,3,2)
>       dimension deltk(jdim,idim,3,2)
>       dimension iaesurf(maxbl,maxsegdg)
>       dimension ibcinfo(maxbl,maxseg,7,2)
>       dimension icsf(maxbl,maxsegdg)
>       dimension icsi(maxbl,maxsegdg)
>       dimension idefrm(maxbl)
>       dimension idfrmseg(maxbl,maxsegdg)
>       dimension iskip(maxbl)
>       dimension jbcinfo(maxbl,maxseg,7,2)
>       dimension jcsf(maxbl,maxsegdg)
>       dimension jcsi(maxbl,maxsegdg)
>       dimension jskip(maxbl)
>       dimension kbcinfo(maxbl,maxseg,7,2)
>       dimension kcsf(maxbl,maxsegdg)
>       dimension kcsi(maxbl,maxsegdg)
>       dimension kskip(maxbl)
>       dimension nbci0(maxbl)
>       dimension nbcidim(maxbl)
>       dimension nbcj0(maxbl)
>       dimension nbcjdim(maxbl)
>       dimension nbck0(maxbl)
>       dimension nbckdim(maxbl)
>       dimension nou(nbuf)
>       dimension nsegdfrm(maxbl)
>       dimension slavept(nslave,3,nmaster,5)
>       dimension vel(jdim,kdim,idim,3)
>       dimension wk(9*nsurf)
>       dimension x(jdim,kdim,idim)
>       dimension xnm1(jdim,kdim,idim)
>       dimension xnm2(jdim,kdim,idim)
>       dimension y(jdim,kdim,idim)
>       dimension ynm1(jdim,kdim,idim)
>       dimension ynm2(jdim,kdim,idim)
>       dimension z(jdim,kdim,idim)
>       dimension znm1(jdim,kdim,idim)
>       dimension znm2(jdim,kdim,idim)
> c
>       allocatable :: arci(:,:,:)
>       allocatable :: arcj(:,:,:)
>       allocatable :: arck(:,:,:)
>       allocatable :: dvol(:)
>       allocatable :: dx(:,:,:)
>       allocatable :: dx1(:,:,:)
>       allocatable :: dx2(:,:,:)
>       allocatable :: dx3(:,:,:)
>       allocatable :: dy(:,:,:)
>       allocatable :: dy1(:,:,:)
>       allocatable :: dy2(:,:,:)
>       allocatable :: dy3(:,:,:)
>       allocatable :: dz(:,:,:)
>       allocatable :: dz1(:,:,:)
>       allocatable :: dz2(:,:,:)
>       allocatable :: dz3(:,:,:)
>       allocatable :: ibl(:)
>       allocatable :: jend(:)
>       allocatable :: jsta(:)
>       allocatable :: xoi(:,:)
>       allocatable :: xoj(:,:)
>       allocatable :: xok(:,:)
> 
82d103
<       icall  = 0
84,99c105,137
<       call umalloc(ip_dx1,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_dy1,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_dz1,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_dx2,idim*jdim*kdim,0,icall,memuse) 
<       call umalloc(ip_dy2,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_dz2,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_dx3,idim*jdim*kdim,0,icall,memuse) 
<       call umalloc(ip_dy3,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_dz3,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_dx,idim*jdim*kdim,0,icall,memuse) 
<       call umalloc(ip_dy,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_dz,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_arci,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_arcj,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_arck,idim*jdim*kdim,0,icall,memuse)
<       call umalloc(ip_ibl,nsurf,1,icall,memuse)
---
> c
>       allocate( arci(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'arci',memuse,stats)
>       allocate( arcj(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'arcj',memuse,stats)
>       allocate( arck(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'arck',memuse,stats)
>       allocate( dx(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dx',memuse,stats)
>       allocate( dx1(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dx1',memuse,stats)
>       allocate( dx2(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dx2',memuse,stats)
>       allocate( dx3(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dx3',memuse,stats)
>       allocate( dy(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dy',memuse,stats)
>       allocate( dy1(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dy1',memuse,stats)
>       allocate( dy2(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dy2',memuse,stats)
>       allocate( dy3(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dy3',memuse,stats)
>       allocate( dz(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dz',memuse,stats)
>       allocate( dz1(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dz1',memuse,stats)
>       allocate( dz2(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dz2',memuse,stats)
>       allocate( dz3(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'dz3',memuse,stats)
>       allocate( ibl(nsurf), stat=stats )
>       call umalloc(nsurf,1,'ibl',memuse,stats)
497,502c535,546
<          call umalloc(ip_dvol,jdim*idim*kdim,0,icall,memuse)
<          call umalloc(ip_xok,jdim*idim*6,0,icall,memuse)
<          call umalloc(ip_xoi,jdim*kdim*6,0,icall,memuse)
<          call umalloc(ip_xoj,kdim*idim*6,0,icall,memuse)
<          call umalloc(ip_jend,2,1,icall,memuse)
<          call umalloc(ip_jsta,2,1,icall,memuse)
---
>          allocate( dvol(jdim*idim*kdim), stat=stats )
>          call umalloc(jdim*idim*kdim,0,'dvol',memuse,stats)
>          allocate( xoi(jdim*kdim,6), stat=stats )
>          call umalloc(jdim*kdim*6,0,'xoi',memuse,stats)
>          allocate( xoj(kdim*idim,6), stat=stats )
>          call umalloc(kdim*idim*6,0,'xoj',memuse,stats)
>          allocate( xok(jdim*idim,6), stat=stats )
>          call umalloc(jdim*idim*6,0,'xok',memuse,stats)
>          allocate( jend(2), stat=stats )
>          call umalloc(2,1,'jend',memuse,stats)
>          allocate( jsta(2), stat=stats )
>          call umalloc(2,1,'jsta',memuse,stats)
515,520c559,564
<          call ufree(ip_dvol)
<          call ufree(ip_xok)
<          call ufree(ip_xoi)
<          call ufree(ip_xoj)
<          call ufree(ip_jend)
<          call ufree(ip_jsta)
---
>          deallocate(dvol)
>          deallocate(xok)
>          deallocate(xoi)
>          deallocate(xoj)
>          deallocate(jend)
>          deallocate(jsta)
597,612c641,656
<       call ufree(ip_dx1)
<       call ufree(ip_dy1)
<       call ufree(ip_dz1)
<       call ufree(ip_dx2)
<       call ufree(ip_dy2)
<       call ufree(ip_dz2)
<       call ufree(ip_dx3)
<       call ufree(ip_dy3)
<       call ufree(ip_dz3)
<       call ufree(ip_dx)
<       call ufree(ip_dy)
<       call ufree(ip_dz)
<       call ufree(ip_arci)
<       call ufree(ip_arcj)
<       call ufree(ip_arck)
<       call ufree(ip_ibl)
---
>       deallocate(dx1)
>       deallocate(dy1)
>       deallocate(dz1)
>       deallocate(dx2)
>       deallocate(dy2)
>       deallocate(dz2)
>       deallocate(dx3)
>       deallocate(dy3)
>       deallocate(dz3)
>       deallocate(dx)
>       deallocate(dy)
>       deallocate(dz)
>       deallocate(arci)
>       deallocate(arcj)
>       deallocate(arck)
>       deallocate(ibl)
615a660,694
>        subroutine dmsetup(jdm,kdm,idm,nbl,jsta,jend,ipid,imid,rj1jd,
>      .                    rj2jd,epsilon) 
> c***********************************************************************
> c     Purpose:  Sets up information for use in the smoothing step
> c
> c
> c     Bob Bartels NASA Langley Aeroelasticity Branch    (757)864-2813
> c       responsible for the following subroutines:
> c         gdsa      -      spring analogy smoothing and near surface
> c                          orientation preservation.
> c         dmsetup0  -      some initialization of xoi,xoj and dx,dy,dz 
> c         dmsetup1  -      some initialization of xok and dx,dy,dz 
> c         dmsetup   -      some initialization of arrays 
> c         bdata     -      computation of block boundary face spacing
> c                          arrays 
> c         permut_ijkxyz -  permutes indices i and j to better align 
> c                          k = 0 and k = kdim surfaces for vectorizing 
> c         unperm_ijkxyz -  unpermutes indices i and j after smoothing 
> c     
> c***********************************************************************
> c
> #   ifdef CMPLX
>       implicit complex(a-h,o-z)
> #   endif
>        common /grid1/ algepmn,coef(2)   
>        common /grid2/ kimx(2),jte1(2),         
>      .   jflp(2,2),icsi(2),icso(2),iafmv1(2),jsp1(2),  
>      .   jsp2(2),jsp3(2),itecs(2),ispcs(2),itp(2,2)
>      .  ,iaxrt(2)
>        common /grid4/ time0
>        common /sklton/ isklton
>        dimension epsilon(kdm,2)
>        dimension  ipid(jdm*idm),imid(jdm*idm),rj1jd(jdm*idm),
>      .            rj2jd(jdm*idm),jend(2),jsta(2)
> 
616a696,737
>        do 30 k = 1,kdm
>          epsilon(k,1) = 1. 
>          epsilon(k,2) = 1. 
> 30     continue
> 
>        coefa  =  -algepmn
>        do 29 n = 1,2
>        do 29 k = kimx(n)+1,kdm 
>           ro1 = coef(n)*real(k-kimx(n)) 
>           arg1= coefa*ro1        
>           epsilon(k,n) = exp(-arg1) 
> 29     continue 
>        if(idm.gt.2) then
>         do 438 j = 1,jdm*idm  
>           ipid(j)= j+jdm           
>           imid(j)= j-jdm  
> 438     continue  
>         jdmi1 = jdm*(idm-1)
>         do 440 j = 1,jdm 
>           imid(j)= j   
>           ipid(j+jdmi1)=j+jdmi1  
> 440     continue 
>        else
>         do 448 j = 1,jdm     
>           imid(j) = j    
>           ipid(j) = j+jdm      
> 448     continue  
>         do 449 j = 1+jdm,jdm*idm     
>           imid(j) = j-jdm      
>           ipid(j) = j      
> 449     continue  
>        end if 
> 
>        do 511 i=1,idm   
>        jdmi1 = jdm*(i-1)  
>        do 511 j = 1,jdm   
>            rj1jd(j+jdmi1) = real(jdm-j) 
>            rj2jd(j+jdmi1) = real(j-1) 
> 511    continue 
> 
>        return
>        end  
619a741
> 
623,638d744
<       dimension x(jdm,kdm,idm),y(jdm,kdm,idm),z(jdm,kdm,idm)
<       dimension dx(jdm,kdm,idm),dy(jdm,kdm,idm),dz(jdm,kdm,idm)
<       dimension dxn(jdm,kdm,idm),dyn(jdm,kdm,idm),dzn(jdm,kdm,idm)
<       dimension xoj(kdm*idm,6),xoi(jdm*kdm,6) 
<       dimension xok(jdm*idm,6)
<       dimension dvol(jdm*idm*kdm)
<       dimension itp1(maxbl,maxsegdg),itp2(maxbl,maxsegdg),
<      .           jtp1(maxbl,maxsegdg),jtp2(maxbl,maxsegdg),
<      .           ksta(maxbl,maxsegdg),kend(maxbl,maxsegdg)
<      .          ,jend(2),jsta(2)
<       dimension epsilon3(jdm),epsilon4(idm) 
<       pointer (ip_epsilon3,epsilon3)
<       pointer (ip_epsilon4,epsilon4)
<       pointer (ip_dxn,dxn)
<       pointer (ip_dyn,dyn)
<       pointer (ip_dzn,dzn)
640,646c746,771
<       icall  = 0
<       memuse = 0
<       call umalloc(ip_epsilon3,jdm,0,icall,memuse)
<       call umalloc(ip_epsilon4,idm,0,icall,memuse)
<       call umalloc(ip_dxn,jdm*kdm*idm,0,icall,memuse)
<       call umalloc(ip_dyn,jdm*kdm*idm,0,icall,memuse)
<       call umalloc(ip_dzn,jdm*kdm*idm,0,icall,memuse)
---
>       integer stats
> c
>       dimension dvol(jdm*idm*kdm)
>       dimension dx(jdm,kdm,idm)
>       dimension dy(jdm,kdm,idm)
>       dimension dz(jdm,kdm,idm)
>       dimension itp1(maxbl,maxsegdg)
>       dimension itp2(maxbl,maxsegdg)
>       dimension jend(2)
>       dimension jsta(2)
>       dimension jtp1(maxbl,maxsegdg)
>       dimension jtp2(maxbl,maxsegdg)
>       dimension kend(maxbl,maxsegdg)
>       dimension ksta(maxbl,maxsegdg)
>       dimension x(jdm,kdm,idm)
>       dimension xoi(jdm*kdm,6)
>       dimension xoj(kdm*idm,6)
>       dimension xok(jdm*idm,6)
>       dimension y(jdm,kdm,idm)
>       dimension z(jdm,kdm,idm)
> 
>       allocatable :: dxn(:,:,:)
>       allocatable :: dyn(:,:,:)
>       allocatable :: dzn(:,:,:)
>       allocatable :: epsilon3(:)
>       allocatable :: epsilon4(:)
647a773,785
>       memuse = 0
> c
>       allocate( dxn(jdm,kdm,idm), stat=stats )
>       call umalloc(jdm*kdm*idm,0,'dxn',memuse,stats)
>       allocate( dyn(jdm,kdm,idm), stat=stats )
>       call umalloc(jdm*kdm*idm,0,'dyn',memuse,stats)
>       allocate( dzn(jdm,kdm,idm), stat=stats )
>       call umalloc(jdm*kdm*idm,0,'dzn',memuse,stats)
>       allocate( epsilon3(jdm), stat=stats )
>       call umalloc(jdm,0,'epsilon3',memuse,stats)
>       allocate( epsilon4(idm), stat=stats )
>       call umalloc(idm,0,'epsilon4',memuse,stats)
> c
751,752c889,890
<        call ufree(ip_epsilon3)
<        call ufree(ip_epsilon4)
---
>        deallocate(epsilon3)
>        deallocate(epsilon4)
763,765c901,903
<        call ufree(ip_dxn)
<        call ufree(ip_dyn)
<        call ufree(ip_dzn)
---
>        deallocate(dxn)
>        deallocate(dyn)
>        deallocate(dzn)
802c940,942
< 
---
> c
>       integer stats
> c
811,812c951,955
<        dimension epsilon3(kdm)
<        pointer (ip_epsilon3,epsilon3)
---
> 
> 
>       allocatable :: epsilon3(:)
> 
>       memuse = 0
814,816c957,958
<        icall  = 0
<        memuse = 0
<        call umalloc(ip_epsilon3,kdm,0,icall,memuse)
---
>       allocate( epsilon3(kdm), stat=stats )
>       call umalloc(kdm,0,'epsilon3',memuse,stats)
1006c1148
<       call ufree(ip_epsilon3)
---
>       deallocate(epsilon3)
1010,1090d1151
< c 
<        subroutine dmsetup(jdm,kdm,idm,nbl,jsta,jend,ipid,imid,rj1jd,
<      .                    rj2jd,epsilon) 
< c***********************************************************************
< c     Purpose:  Sets up information for use in the smoothing step
< c
< c
< c     Bob Bartels NASA Langley Aeroelasticity Branch    (757)864-2813
< c       responsible for the following subroutines:
< c         gdsa      -      spring analogy smoothing and near surface
< c                          orientation preservation.
< c         dmsetup0  -      some initialization of xoi,xoj and dx,dy,dz 
< c         dmsetup1  -      some initialization of xok and dx,dy,dz 
< c         dmsetup   -      some initialization of arrays 
< c         bdata     -      computation of block boundary face spacing
< c                          arrays 
< c         permut_ijkxyz -  permutes indices i and j to better align 
< c                          k = 0 and k = kdim surfaces for vectorizing 
< c         unperm_ijkxyz -  unpermutes indices i and j after smoothing 
< c     
< c***********************************************************************
< c
< #   ifdef CMPLX
<       implicit complex(a-h,o-z)
< #   endif
<        common /grid1/ algepmn,coef(2)   
<        common /grid2/ kimx(2),jte1(2),         
<      .   jflp(2,2),icsi(2),icso(2),iafmv1(2),jsp1(2),  
<      .   jsp2(2),jsp3(2),itecs(2),ispcs(2),itp(2,2)
<      .  ,iaxrt(2)
<        common /grid4/ time0
<        common /sklton/ isklton
<        dimension epsilon(kdm,2)
<        dimension  ipid(jdm*idm),imid(jdm*idm),rj1jd(jdm*idm),
<      .            rj2jd(jdm*idm),jend(2),jsta(2)
< 
< 
<        do 30 k = 1,kdm
<          epsilon(k,1) = 1. 
<          epsilon(k,2) = 1. 
< 30     continue
< 
<        coefa  =  -algepmn
<        do 29 n = 1,2
<        do 29 k = kimx(n)+1,kdm 
<           ro1 = coef(n)*real(k-kimx(n)) 
<           arg1= coefa*ro1        
<           epsilon(k,n) = exp(-arg1) 
< 29     continue 
<        if(idm.gt.2) then
<         do 438 j = 1,jdm*idm  
<           ipid(j)= j+jdm           
<           imid(j)= j-jdm  
< 438     continue  
<         jdmi1 = jdm*(idm-1)
<         do 440 j = 1,jdm 
<           imid(j)= j   
<           ipid(j+jdmi1)=j+jdmi1  
< 440     continue 
<        else
<         do 448 j = 1,jdm     
<           imid(j) = j    
<           ipid(j) = j+jdm      
< 448     continue  
<         do 449 j = 1+jdm,jdm*idm     
<           imid(j) = j-jdm      
<           ipid(j) = j      
< 449     continue  
<        end if 
< 
<        do 511 i=1,idm   
<        jdmi1 = jdm*(i-1)  
<        do 511 j = 1,jdm   
<            rj1jd(j+jdmi1) = real(jdm-j) 
<            rj2jd(j+jdmi1) = real(j-1) 
< 511    continue 
< 
<        return
<        end  
< 
<   
1289,1290d1349
< 
< 
1360d1418
< 
1428,1429d1485
< 
< c 
1470,1511c1526
<        dimension  ipid(jdmt*idmt),imid(jdmt*idmt),rj1jd(jdmt*idmt),
<      .            rj2jd(jdmt*idmt),jend(2),jsta(2)
<        dimension epsilon(kdmt,2),seta(kdmt) 
<        dimension xj1p(jdmt*idmt),xk1p(kdmt), xj2p(jdmt*idmt)                          
<      .          ,xk2p(kdmt),xj1m(jdmt*idmt),xk1m(kdmt),
<      .           xj2m(jdmt*idmt), xk2m(kdmt),xj3p(jdmt*idmt,2)  
<      .          ,xi1m(jdmt*idmt),xi1p(jdmt*idmt),xi2m(jdmt*idmt),
<      .           xi2p(jdmt*idmt)
<        dimension xip(jdmt*idmt,2),xim(jdmt*idmt,2) 
<        dimension xjp(jdmt*idmt,2),xjm(jdmt*idmt,2) 
<        dimension xkp(jdmt*idmt,2),xkm(jdmt*idmt,2)            
<        dimension xid(jdmt*idmt,2),xjd(jdmt*idmt,2)
< c
<        dimension xnm1(jdmt*kdmt*idmt),ynm1(jdmt*kdmt*idmt),
<      .           znm1(jdmt*kdmt*idmt)
<        dimension dx(jdmt*kdmt*idmt),dy(jdmt*kdmt*idmt),
<      .           dz(jdmt*kdmt*idmt)
<        dimension x(jdmt*idmt*kdmt),y(jdmt*idmt*kdmt),
<      .           z(jdmt*idmt*kdmt)
<        dimension dvol(jdmt*idmt*kdmt)
<        dimension xok(jdmt*idmt,6)
<        dimension xoj(kdmt*idmt,6),xoi(jdmt*kdmt,6) 
<        dimension dzj(jdmt*idmt,2),dxj(jdmt*idmt,2)   
<      .          ,dyj(jdmt*idmt,2)  
< 
<       pointer (ip_xj1p,xj1p),(ip_xj1m,xj1m) 
<       pointer (ip_xj2p,xj2p),(ip_xj2m,xj2m) 
<       pointer (ip_xi1p,xi1p),(ip_xi1m,xi1m) 
<       pointer (ip_xi2p,xi2p),(ip_xi2m,xi2m) 
<       pointer (ip_xk1p,xk1p),(ip_xk1m,xk1m) 
<       pointer (ip_xk2p,xk2p),(ip_xk2m,xk2m) 
<       pointer (ip_xj3p,xj3p)
<       pointer (ip_seta,seta)
<       pointer (ip_xip,xip)  ,(ip_xim,xim)
<       pointer (ip_xjp,xjp)  ,(ip_xjm,xjm)
<       pointer (ip_xkp,xkp)  ,(ip_xkm,xkm)
<       pointer (ip_xid,xid)  ,(ip_xjd,xjd)
<       pointer (ip_ipid,ipid),(ip_imid,imid)
<       pointer (ip_rj1jd,rj1jd),(ip_rj2jd,rj2jd)
<       pointer (ip_dzj,dzj)  ,(ip_dxj,dxj)
<       pointer (ip_dyj,dyj)  
<       pointer (ip_epsilon,epsilon)
---
>       integer stats
1513,1519c1528,1573
<       icall  = 0
<       memuse = 0
<       call umalloc(ip_ipid,jdmt*idmt,1,icall,memuse)
<       call umalloc(ip_imid,jdmt*idmt,1,icall,memuse)
<       call umalloc(ip_rj1jd,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_rj2jd,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_epsilon,kdmt*2,0,icall,memuse)
---
>       dimension dvol(jdmt*idmt*kdmt)
>       dimension dx(jdmt*kdmt*idmt)
>       dimension dy(jdmt*kdmt*idmt)
>       dimension dz(jdmt*kdmt*idmt)
>       dimension jend(2)
>       dimension jsta(2)
>       dimension x(jdmt*idmt*kdmt)
>       dimension xnm1(jdmt*kdmt*idmt)
>       dimension xoi(jdmt*kdmt,6)
>       dimension xoj(kdmt*idmt,6)
>       dimension xok(jdmt*idmt,6)
>       dimension y(jdmt*idmt*kdmt)
>       dimension ynm1(jdmt*kdmt*idmt)
>       dimension z(jdmt*idmt*kdmt)
>       dimension znm1(jdmt*kdmt*idmt)
> 
>       allocatable :: dxj(:,:)
>       allocatable :: dyj(:,:)
>       allocatable :: dzj(:,:)
>       allocatable :: epsilon(:,:)
>       allocatable :: imid(:)
>       allocatable :: ipid(:)
>       allocatable :: rj1jd(:)
>       allocatable :: rj2jd(:)
>       allocatable :: seta(:)
>       allocatable :: xi1m(:)
>       allocatable :: xi1p(:)
>       allocatable :: xi2m(:)
>       allocatable :: xi2p(:)
>       allocatable :: xid(:,:)
>       allocatable :: xim(:,:)
>       allocatable :: xip(:,:)
>       allocatable :: xj1m(:)
>       allocatable :: xj1p(:)
>       allocatable :: xj2m(:)
>       allocatable :: xj2p(:)
>       allocatable :: xj3p(:,:)
>       allocatable :: xjd(:,:)
>       allocatable :: xjm(:,:)
>       allocatable :: xjp(:,:)
>       allocatable :: xk1m(:)
>       allocatable :: xk1p(:)
>       allocatable :: xk2m(:)
>       allocatable :: xk2p(:)
>       allocatable :: xkm(:,:)
>       allocatable :: xkp(:,:)
1520a1575,1637
>       memuse = 0
> c
>       allocate( dxj(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'dxj',memuse,stats)
>       allocate( dyj(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'dyj',memuse,stats)
>       allocate( dzj(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'dzj',memuse,stats)
>       allocate( epsilon(kdmt,2), stat=stats)
>       call umalloc(kdmt*2,0,'epsilon',memuse,stats)
>       allocate( imid(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,1,'imid',memuse,stats)
>       allocate( ipid(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,1,'ipid',memuse,stats)
>       allocate( rj1jd(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'rj1jd',memuse,stats)
>       allocate( rj2jd(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'rj2jd',memuse,stats)
>       allocate( seta(kdmt), stat=stats)
>       call umalloc(kdmt,0,'seta',memuse,stats)
>       allocate( xi1m(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'xi1m',memuse,stats)
>       allocate( xi1p(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'xi1p',memuse,stats)
>       allocate( xi2m(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'xi2m',memuse,stats)
>       allocate( xi2p(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'xi2p',memuse,stats)
>       allocate( xid(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xid',memuse,stats)
>       allocate( xim(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xim',memuse,stats)
>       allocate( xip(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xip',memuse,stats)
>       allocate( xj1m(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'xj1m',memuse,stats)
>       allocate( xj1p(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'xj1p',memuse,stats)
>       allocate( xj2m(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'xj2m',memuse,stats)
>       allocate( xj2p(jdmt*idmt), stat=stats)
>       call umalloc(jdmt*idmt,0,'xj2p',memuse,stats)
>       allocate( xj3p(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xj3p',memuse,stats)
>       allocate( xjd(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xjd',memuse,stats)
>       allocate( xjm(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xjm',memuse,stats)
>       allocate( xjp(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xjp',memuse,stats)
>       allocate( xk1m(kdmt), stat=stats)
>       call umalloc(kdmt,0,'xk1m',memuse,stats)
>       allocate( xk1p(kdmt), stat=stats)
>       call umalloc(kdmt,0,'xk1p',memuse,stats)
>       allocate( xk2m(kdmt), stat=stats)
>       call umalloc(kdmt,0,'xk2m',memuse,stats)
>       allocate( xk2p(kdmt), stat=stats)
>       call umalloc(kdmt,0,'xk2p',memuse,stats)
>       allocate( xkm(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xkm',memuse,stats)
>       allocate( xkp(jdmt*idmt,2), stat=stats)
>       call umalloc(jdmt*idmt*2,0,'xkp',memuse,stats)
> c
1528,1542d1644
<       call umalloc(ip_xj1p,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_xj1m,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_xj2p,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_xj2m,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_xi1p,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_xi1m,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_xi2p,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_xi2m,jdmt*idmt,0,icall,memuse)
<       call umalloc(ip_xk1p,kdmt,0,icall,memuse)
<       call umalloc(ip_xk1m,kdmt,0,icall,memuse)
<       call umalloc(ip_xk2p,kdmt,0,icall,memuse)
<       call umalloc(ip_xk2m,kdmt,0,icall,memuse)
<       call umalloc(ip_xj3p,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_seta,kdmt,0,icall,memuse)
< 
1550,1562d1651
<       call umalloc(ip_xip,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_xjp,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_xkp,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_xim,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_xjm,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_xkm,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_xid,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_xjd,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_dzj,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_dxj,jdmt*idmt*2,0,icall,memuse)
<       call umalloc(ip_dyj,jdmt*idmt*2,0,icall,memuse)
< 
< 
2382,2411c2471,2500
<       call ufree(ip_xj1p)
<       call ufree(ip_xj1m)
<       call ufree(ip_xj2p)
<       call ufree(ip_xj2m)
<       call ufree(ip_xi1p)
<       call ufree(ip_xi1m)
<       call ufree(ip_xi2p)
<       call ufree(ip_xi2m)
<       call ufree(ip_xk1p)
<       call ufree(ip_xk1m)
<       call ufree(ip_xk2p)
<       call ufree(ip_xk2m)
<       call ufree(ip_xj3p)
<       call ufree(ip_seta)
<       call ufree(ip_ipid)
<       call ufree(ip_imid)
<       call ufree(ip_rj1jd)
<       call ufree(ip_rj2jd)
<       call ufree(ip_xip)
<       call ufree(ip_xjp)
<       call ufree(ip_xkp)
<       call ufree(ip_xim)
<       call ufree(ip_xjm)
<       call ufree(ip_xkm)
<       call ufree(ip_xid)
<       call ufree(ip_xjd)
<       call ufree(ip_dzj)
<       call ufree(ip_dxj)
<       call ufree(ip_dyj)
<       call ufree(ip_epsilon)
---
>       deallocate(xj1p)
>       deallocate(xj1m)
>       deallocate(xj2p)
>       deallocate(xj2m)
>       deallocate(xi1p)
>       deallocate(xi1m)
>       deallocate(xi2p)
>       deallocate(xi2m)
>       deallocate(xk1p)
>       deallocate(xk1m)
>       deallocate(xk2p)
>       deallocate(xk2m)
>       deallocate(xj3p)
>       deallocate(seta)
>       deallocate(ipid)
>       deallocate(imid)
>       deallocate(rj1jd)
>       deallocate(rj2jd)
>       deallocate(xip)
>       deallocate(xjp)
>       deallocate(xkp)
>       deallocate(xim)
>       deallocate(xjm)
>       deallocate(xkm)
>       deallocate(xid)
>       deallocate(xjd)
>       deallocate(dzj)
>       deallocate(dxj)
>       deallocate(dyj)
>       deallocate(epsilon)
2419,2420d2507
< 
< 
Index: source/cfl3d/libs/getdhdr.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/getdhdr.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
33a34,46
>          end if
>       end if
> c
>       if (ibctyp.eq.2009) then
>          datahdr(1)  = '   pt/pinf'
>          datahdr(2)  = '   tt/tinf'
>          datahdr(3)  = '     alpha'
>          datahdr(4)  = '      beta'
>          if (abs(ndata).gt.4) then
>             datahdr(5)  = '     turb1'
>          end if
>          if (abs(ndata).gt.5) then
>             datahdr(6)  = '     turb2'
Index: source/cfl3d/libs/getibk.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/getibk.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15,16c15,20
<       real dxintgr(iitot),dyintgr(iitot),dzintgr(iitot),
<      .     blankr(jdim,kdim,idim)
---
>       integer stats
> c
>       real, dimension(:,:,:), allocatable :: blankr
>       real, dimension(:), allocatable :: dxintgr
>       real, dimension(:), allocatable :: dyintgr
>       real, dimension(:), allocatable :: dzintgr
18,19d21
<       pointer (ip_dxintgr,dxintgr),(ip_dyintgr,dyintgr),
<      .        (ip_dzintgr,dzintgr),(ip_blankr,blankr)
30a33,34
> 
> 
35d38
<       icall  = 0
37,40c40,47
<       call umalloc(ip_dxintgr,iitot,0,icall,memuse)
<       call umalloc(ip_dyintgr,iitot,0,icall,memuse)
<       call umalloc(ip_dzintgr,iitot,0,icall,memuse)
<       call umalloc(ip_blankr,jdim*kdim*idim,0,icall,memuse)
---
>       allocate( blankr(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'blankr',memuse,stats)
>       allocate( dxintgr(iitot), stat=stats )
>       call umalloc(iitot,0,'dxintgr',memuse,stats)
>       allocate( dyintgr(iitot), stat=stats )
>       call umalloc(iitot,0,'dyintgr',memuse,stats)
>       allocate( dzintgr(iitot), stat=stats )
>       call umalloc(iitot,0,'dzintgr',memuse,stats)
153,156c160,163
<       call ufree(ip_dxintgr)
<       call ufree(ip_dyintgr)
<       call ufree(ip_dzintgr)
<       call ufree(ip_blankr)
---
>       deallocate(dxintgr)
>       deallocate(dyintgr)
>       deallocate(dzintgr)
>       deallocate(blankr)
Index: source/cfl3d/libs/global.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/global.F,v
retrieving revision 1.3
retrieving revision 1.11
diff -r1.3 -r1.11
29c29
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
121a122,123
>       common /avgdata/ xnumavg,iteravg
>       common /cfl/ dt0,dtold
123c125,127
<      .                geom_img,surf_img
---
>      .                geom_img,surf_img,xrotrate_img,yrotrate_img,
>      .                zrotrate_img
>       common /des/ cdes,ides
167c171
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
340a345
>       dtold  = dt
357a363,367
>       if (irest .eq. 0 .and. iteravg .eq. 2) then
>         write(iunit11,98)
>    98   format(/,47h when irest=0, iteravg=2 starts running-average,
>      .   31h from scratch (as if iteravg=1),/)
>       end if
431a442,446
> c   DES must be run in 3-D
>       if (ides .eq. 1 .and. i2d .eq. 1) then
>         write(iunit11,'('' DES must be run 3-D (i2d=0)'')')
>         call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)
>       end if
610a626,634
> c   DES currently only works with Spalart model
>       if (ides .eq. 1) then
>         if (ivisc(1) .ne. 5 .or. ivisc(2) .ne. 5 .or.
>      .      ivisc(3) .ne. 5) then
>           write(iunit11,'('' DES currently works with SA model only'',
>      .     '', and must be on in all 3 directions'')')
>           call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)
>         end if
>       end if
748c772,780
<   337    format(1x,'('' stopping...must have idim=2 for 2d cases!'')')
---
>   337    format(42h stopping...must have idim=2 for 2d cases!)
>       end if
>       if (i2d .eq. 0 .and. idim .eq. 2) then
>          write(iunit11,338)
>   338    format(49h WARNING: idim=2 for i2d=0 may not be a good idea)
>       end if
>       if (ides .eq. 1 .and. idim .eq. 2) then
>          write(iunit11,339)
>   339    format(47h WARNING: idim=2 for DES may not be a good idea)
1285c1317
<  1212 format(5f10.5,2e10.3)
---
>  1212 format(4f10.5,3e10.3)
2763a2796,2800
>       if (mseq.gt.1 .and. iemtot.ne.0 .and. iteravg .ne. 0) then
>         write(iunit11,*)' Stopping!',
>      .        '  Cannot use iteravg>0 with mseq>1 and embedded grids'
>         call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)
>       end if
2819a2857,2861
>       if (m.gt.1 .and. ncyc1(m).ne.0 .and. iteravg.gt.0) then
>         write(iunit11,'('' not allowed to use a running-average'',
>      .   '' file (iteravg>0) with mesh sequencing'')')
>         call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)
>       end if
2895,2896c2937,2938
<   198 format('('' you MUST use subiterations (ncyc>1) to get'',
<      .'' second-order accuracy in time!'')')
---
>   198 format(43h you MUST use subiterations (ncyc>1) to get,
>      .       31h second-order accuracy in time!)
2910,2911c2952,2953
<   199 format('('' you MUST do at least one cycle on the starting'',
<      .         '' level!'')')
---
>   199 format(47h you MUST do at least one cycle on the starting,
>      .       7h level!)
3173d3214
<          nplt3d1 = nplot3d
3342c3383
< 1788        format(4x,42h Note: embedded grids are computed only on,
---
> 1788        format(4x,46h stopping: embedded grids are computed only on,
3345c3386
<             nplt3d1 = nplt3d1 - 1
---
>             call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)
3353,3357d3393
< c        adjust nplot3d for number of embedded meshes that are not
< c        output, if applicable
< c
<          nplot3d = nplt3d1
< c
3427d3462
<          nprnt1 = nprint
3589c3624
<             nprnt1 = nprnt1 - 1
---
>             call termn8(myid,ierrflg,ibufdim,nbuf,bou,nou)
3595,3599d3629
< c        adjust nprint for number of embedded meshes that are not
< c        output, if applicable
< c
<          nprint = nprnt1
< c
4923a4954
>                            nsegdfrm(nbl)      = nsegdfrm(nbl-1)
Index: source/cfl3d/libs/global0.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/global0.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
29d28
< c   ***CGNSstart
33c32
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
37c36
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
39d37
< c   ***CGNSend
601d598
< c   ***CGNSstart
603d599
< c   ***CGNSend
608d603
< c   ***CGNSstart
619d613
< c   ***CGNSend
741c735
< #ifdef CRAY_TIME then
---
> #ifdef CRAY_TIME
743c737
< #   ifdef IBM then
---
> #   ifdef IBM
Index: source/cfl3d/libs/global2.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/global2.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
9c9
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
43c43
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
77c77
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
Index: source/cfl3d/libs/gradinfo.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/gradinfo.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
17c17,19
<      .                geom_img,surf_img
---
>      .                geom_img,surf_img,xrotrate_img,yrotrate_img,
>      .                zrotrate_img
>       common /igrdtyp/ ip3dgrd,ialph
59a62,89
>          end if
>       else if (real(xrotrate_img) .gt. 0.) then
>          delh = real(xrotrate_img)
>          if (iunit .gt. 0) then
>             write(iunit,'(''                      derivatives with '',
>      .                 ''respect to omega_x (roll rate)'')')
>          end if
>       else if (real(yrotrate_img) .gt. 0.) then
>          delh = real(yrotrate_img)
>          if (iunit .gt. 0) then
>             if (ialph .eq. 0) then
>             write(iunit,'(''                      derivatives with '',
>      .                 ''respect to omega_y (pitch rate)'')')
>             else
>             write(iunit,'(''                      derivatives with '',
>      .                 ''respect to omega_y (yaw rate)'')')
>             end if
>          end if
>       else if (real(zrotrate_img) .gt. 0.) then
>          delh = real(zrotrate_img)
>          if (iunit .gt. 0) then
>             if (ialph .eq. 0) then
>             write(iunit,'(''                      derivatives with '',
>      .                 ''respect to omega_z (yaw rate)'')')
>             else
>             write(iunit,'(''                      derivatives with '',
>      .                 ''respect to omega_z (pitch rate)'')')
>             end if
Index: source/cfl3d/libs/histout.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/histout.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
61a62,64
> c            = 2....enhanced standard: ALL force/moment coefficients
> c                   are output (thus there is no need to distinguish
> c                   between ialpha=0 and ialpha=1)
72c75,76
<             write(12,'(3x,i6,5e14.5)') n,log10(real(rms(n))),
---
> c           write(12,'(3x,i6,5e14.5)') n,log10(real(rms(n))),
>             write(12,'(3x,i6,6e15.7)') n,log10(real(rms(n))),
83c87,88
<             write(12,'(3x,i6,5e14.5)') n,log10(real(rms(n))),
---
> c           write(12,'(3x,i6,5e14.5)') n,log10(real(rms(n))),
>             write(12,'(3x,i6,6e15.7)') n,log10(real(rms(n))),
87c92
<       else
---
>       else if (ihstry.eq.1) then
95c100,101
<          write(12,'(3x,i6,5e14.5)') n,log10(real(rms(n))),
---
> c        write(12,'(3x,i6,5e14.5)') n,log10(real(rms(n))),
>          write(12,'(3x,i6,6e15.7)') n,log10(real(rms(n))),
98c104,122
< 
---
>       else
>          write(12,'('' Final cl,cd       ='',2e13.5)')
>      .   real(clw(ntt)),real(cdw(ntt))
>          write(12,'('' Final cx,cy,cz    ='',3e13.5)')
>      .   real(cxw(ntt)),real(cyw(ntt)),real(czw(ntt))
>          write(12,'('' Final cmx,cmy,cmz ='',3e13.5)')
>      .   real(cmxw(ntt)),real(cmyw(ntt)),real(cmzw(ntt))
>          write(12,*)
>          write(12,'(''    it     log(res)           cl'',
>      .   ''           cd           cx           cy'',
>      .   ''           cz          cmx          cmy'',
>      .   ''          cmz'')')
>          write(12,*)
>          do n=1,ntt
>             if(real(rms(n)) .le. 0.) rms(n)=1.
>             write(12,'(i6,9e13.5)') n,log10(real(rms(n))),
>      .      real(clw(n)),real(cdw(n)),real(cxw(n)),real(cyw(n)),
>      .      real(czw(n)),real(cmxw(n)),real(cmyw(n)),real(cmzw(n))
>          end do
141c165,166
<                    write(34,'(3x,i6,5e14.5)') n,real(timekeep(n)),
---
> c                  write(34,'(3x,i6,5e14.5)') n,real(timekeep(n)),
>                    write(34,'(3x,i6,6e15.7)') n,real(timekeep(n)),
Index: source/cfl3d/libs/histout_img.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/histout_img.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
32c32,33
<      .                geom_img,surf_img
---
>      .                geom_img,surf_img,xrotrate_img,yrotrate_img,
>      .                zrotrate_img
83a85,87
> c            = 2....enhanced standard: ALL force/moment derivative
> c                   coefficients are output (thus there is no need
> c                   to distinguish between ialpha=0 and ialpha=1)
93c97
<             write(35,'(i6,'' it  Im(log(res))    d(cl)/d()'',
---
>             write(35,'(i6,'' it  log|Im(res)|    d(cl)/d()'',
96c100
<             if(imag(rms(n)) .le. 0.) rms(n)=cmplx(real(rms(n)),1.)
---
>             if(imag(rms(n)) .eq. 0.) rms(n)=cmplx(real(rms(n)),1.)
105c109
<             write(35,'(i6,'' it  Im(log(res))    d(cl)/d()'',
---
>             write(35,'(i6,'' it  log|Im(res)|    d(cl)/d()'',
108c112
<             if(imag(rms(n)) .le. 0.) rms(n)=cmplx(real(rms(n)),1.)
---
>             if(imag(rms(n)) .eq. 0.) rms(n)=cmplx(real(rms(n)),1.)
114c118
<       else
---
>       else if (ihstry.eq.1) then
119c123
<          write(35,'(i6,'' it  Im(log(res))   d(mdot)/d()'',
---
>          write(35,'(i6,'' it  log|Im(res)|   d(mdot)/d()'',
122c126
<          if(imag(rms(n)) .le. 0.) rms(n)=cmplx(real(rms(n)),1.)
---
>          if(imag(rms(n)) .eq. 0.) rms(n)=cmplx(real(rms(n)),1.)
127c131,152
< 
---
>       else
>          write(35,'('' Final d/d() of cl,cd       ='',2e13.5)')
>      .   imag(clw(ntt))/real(delh),imag(cdw(ntt))/real(delh)
>          write(35,'('' Final d/d() of cx,cy,cz    ='',3e13.5)')
>      .   imag(cxw(ntt))/real(delh),imag(cyw(ntt))/real(delh),
>      .   imag(czw(ntt))/real(delh)
>          write(35,'('' Final d/d() of cmx,cmy,cmz ='',3e13.5)')
>      .   imag(cmxw(ntt))/real(delh),imag(cmyw(ntt))/real(delh),
>      .   imag(cmzw(ntt))/real(delh)
>          write(35,*)
>          write(35,'(''    it log|Im(res)|    d(cl)/d()'',
>      .   ''    d(cd)/d()    d(cx)/d()    d(cy)/d()    d(cz)/d()'',
>      .   ''   d(cmx)/d()   d(cmy)/d()   d(cmz)/d()'')')
>          write(35,*)
>          do n=1,ntt
>             if(imag(rms(n)) .eq. 0.) rms(n)=cmplx(real(rms(n)),1.)
>             write(35,'(i6,9e13.5)') n,log10(abs(imag(rms(n)))),
>      .      imag(clw(n))/real(delh),imag(cdw(n))/real(delh),
>      .      imag(cxw(n))/real(delh),imag(cyw(n))/real(delh),
>      .      imag(czw(n))/real(delh),imag(cmxw(n))/real(delh),
>      .      imag(cmyw(n))/real(delh),imag(cmzw(n))/real(delh)
>          end do
Index: source/cfl3d/libs/init.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/init.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
4c4
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
125,126c125,126
<           tur10=0.1
<           tur20=0.
---
>           if (real(tur10) .lt. 0.) tur10=0.1
>           if (real(tur20) .lt. 0.) tur20=0.
129,130c129,130
<           tur10=1.341946
<           tur20=0.
---
>           if (real(tur10) .lt. 0.) tur10=1.341946
>           if (real(tur20) .lt. 0.) tur20=0.
138,139c138,139
<           tur10=1.e-17
<           tur20=1.e-9
---
>           if (real(tur10) .lt. 0.) tur10=1.e-17
>           if (real(tur20) .lt. 0.) tur20=1.e-9
146,147c146,147
<           tur10=9.e-8
<           tur20=9.e-9
---
>           if (real(tur10) .lt. 0.) tur10=9.e-8
>           if (real(tur20) .lt. 0.) tur20=9.e-9
149,150c149,150
<           tur10=1.e-6
<           tur20=9.e-9
---
>           if (real(tur10) .lt. 0.) tur10=1.e-6
>           if (real(tur20) .lt. 0.) tur20=9.e-9
Index: source/cfl3d/libs/init_mast.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/init_mast.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
Index: source/cfl3d/libs/initvist.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/initvist.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
43c43
<                 vist3d(j,k,i)=0.009
---
>                 vist3d(j,k,i)=0.09*tur10
51c51
<                 vist3d(j,k,i)=0.009
---
>                 vist3d(j,k,i)=tur10*(tur10**3/(tur10**3+357.911))
118a119
>           v3dset=cmu*rho0*tur20/tur10
127c128
<                 v3d=ccmaxcr(v3d,.009)
---
>                 v3d=ccmax(v3d,v3dset)
Index: source/cfl3d/libs/int2.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/int2.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
7c7
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
94c94
<       phi      = 0.5 +  lim_ptch*(phi - 0.5)
---
>       phi      = 0.5 +  float(lim_ptch)*(phi - 0.5)
112c112
<       phi      = 0.5 +  lim_ptch*(phi - 0.5)
---
>       phi      = 0.5 +  float(lim_ptch)*(phi - 0.5)
191c191
<       phi      = 0.5 +  lim_ptch*(phi - 0.5)
---
>       phi      = 0.5 +  float(lim_ptch)*(phi - 0.5)
209c209
<       phi      = 0.5 +  lim_ptch*(phi - 0.5)
---
>       phi      = 0.5 +  float(lim_ptch)*(phi - 0.5)
288c288
<       phi      = 0.5 +  lim_ptch*(phi - 0.5)
---
>       phi      = 0.5 +  float(lim_ptch)*(phi - 0.5)
306c306
<       phi      = 0.5 +  lim_ptch*(phi - 0.5)
---
>       phi      = 0.5 +  float(lim_ptch)*(phi - 0.5)
Index: source/cfl3d/libs/invert.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/invert.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
13c13
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
28c28
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
62c62
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
Index: source/cfl3d/libs/lead.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/lead.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
25c25
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
120,137c120,138
<       lux    = lw(46,nbl)
<       lcmuv  = lw(47,nbl)
<       lvolj0 = lw(48,nbl)
<       lvolk0 = lw(49,nbl)
<       lvoli0 = lw(50,nbl)
<       lxmdj  = lw(51,nbl)
<       lxmdk  = lw(52,nbl)
<       lxmdi  = lw(53,nbl)
<       lvelg  = lw(54,nbl)
<       lxnm2  = lw(55,nbl)
<       lynm2  = lw(56,nbl)
<       lznm2  = lw(57,nbl)
<       ldeltj = lw(58,nbl)
<       ldeltk = lw(59,nbl)
<       ldelti = lw(60,nbl)
<       lxnm1  = lw(61,nbl)
<       lynm1  = lw(62,nbl)
<       lznm1  = lw(63,nbl)
---
>       lqavg  = lw(46,nbl)
>       lux    = lw(47,nbl)
>       lcmuv  = lw(48,nbl)
>       lvolj0 = lw(49,nbl)
>       lvolk0 = lw(50,nbl)
>       lvoli0 = lw(51,nbl)
>       lxmdj  = lw(52,nbl)
>       lxmdk  = lw(53,nbl)
>       lxmdi  = lw(54,nbl)
>       lvelg  = lw(55,nbl)
>       lxnm2  = lw(56,nbl)
>       lynm2  = lw(57,nbl)
>       lznm2  = lw(58,nbl)
>       ldeltj = lw(59,nbl)
>       ldeltk = lw(60,nbl)
>       ldelti = lw(61,nbl)
>       lxnm1  = lw(62,nbl)
>       lynm1  = lw(63,nbl)
>       lznm1  = lw(64,nbl)
Index: source/cfl3d/libs/metric.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/metric.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
210a211
>         izzndx = i-(2*m)+3
214,216c215,218
<         si(izz,i,1) = 0.e0
<         si(izz,i,2) = 0.e0
<         si(izz,i,3) = 0.e0
---
> c       set directions on collapsed face equal to those at closest interior face
>         si(izz,i,1) = si(izz,izzndx,1)
>         si(izz,i,2) = si(izz,izzndx,2)
>         si(izz,i,3) = si(izz,izzndx,3)
218c220
<         si(izz,i,5) = 0.e0
---
>         si(izz,i,5) = si(izz,izzndx,5)
505,507c507,511
<         sj(izz,i,1) = 0.e0
<         sj(izz,i,2) = 0.e0
<         sj(izz,i,3) = 0.e0
---
>         izzndx = izz-(2*m)+3
> c       set directions on collapsed face equal to those at closest interior face
>         sj(izz,i,1) = sj(izzndx,i,1)
>         sj(izz,i,2) = sj(izzndx,i,2)
>         sj(izz,i,3) = sj(izzndx,i,3)
509c513
<         sj(izz,i,5) = 0.e0
---
>         sj(izz,i,5) = sj(izzndx,i,5)
724,726c728,732
<         sk(izz,i,1) = 0.e0
<         sk(izz,i,2) = 0.e0
<         sk(izz,i,3) = 0.e0
---
>         izzndx = izz-(2*jdim*m)+(3*jdim)
> c       set directions on collapsed face equal to those at closest interior face
>         sk(izz,i,1) = sk(izzndx,i,1)
>         sk(izz,i,2) = sk(izzndx,i,2)
>         sk(izz,i,3) = sk(izzndx,i,3)
728c734
<         sk(izz,i,5) = 0.e0
---
>         sk(izz,i,5) = sk(izzndx,i,5)
Index: source/cfl3d/libs/modread.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/modread.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15c15,19
<       real xmdjr(kdim,idim,6),xmdkr(jdim,idim,6),xmdir(jdim,kdim,6)
---
>       integer stats
> c
>       real, dimension(:,:,:), allocatable :: xmdir
>       real, dimension(:,:,:), allocatable :: xmdjr
>       real, dimension(:,:,:), allocatable :: xmdkr
17d20
<       pointer (ip_xmdjr,xmdjr),(ip_xmdkr,xmdkr),(ip_xmdir,xmdir)
27a31
> 
31d34
<       icall  = 0
33,35c36,41
<       call umalloc(ip_xmdjr,kdim*idim*6,0,icall,memuse)
<       call umalloc(ip_xmdkr,jdim*idim*6,0,icall,memuse)
<       call umalloc(ip_xmdir,jdim*kdim*6,0,icall,memuse)
---
>       allocate( xmdir(jdim,kdim,6), stat=stats )
>       call umalloc(jdim*kdim*6,0,'xmdir',memuse,stats)
>       allocate( xmdjr(kdim,idim,6), stat=stats )
>       call umalloc(kdim*idim*6,0,'xmdjr',memuse,stats)
>       allocate( xmdkr(jdim,idim,6), stat=stats )
>       call umalloc(jdim*idim*6,0,'xmdkr',memuse,stats)
179,181c185,187
<       call ufree(ip_xmdjr)
<       call ufree(ip_xmdkr)
<       call ufree(ip_xmdir)
---
>       deallocate(xmdjr)
>       deallocate(xmdkr)
>       deallocate(xmdir)
Index: source/cfl3d/libs/outbuf.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/outbuf.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
20c20
< #ifdef CRAY_TIME then
---
> #ifdef CRAY_TIME
22c22
< #   ifdef IBM then
---
> #   ifdef IBM
Index: source/cfl3d/libs/pltmode.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/pltmode.F,v
retrieving revision 1.3
retrieving revision 1.4
diff -r1.3 -r1.4
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
36c36
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/libs/pre_embed.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/pre_embed.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
8c8
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
36c36
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/libs/pre_period.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/pre_period.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
9c9
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
38c38
<      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1
---
>      .        lxnm2,lynm2,lznm2,lxnm1,lynm1,lznm1,lqavg
Index: source/cfl3d/libs/rcfl.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/rcfl.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
<       subroutine rcfl(x,y,z,jdim,kdim,idim,igrid,ialph,igeom_img)
---
>       subroutine rcfl(x,y,z,jdim,kdim,idim,igrid,ialph,igeom_img,irr)
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18,19c18,22
<       real xr(jdim,kdim,idim),yr(jdim,kdim,idim),
<      .     zr(jdim,kdim,idim)
---
>       integer stats
> c
>       real, dimension(:,:,:), allocatable :: xr
>       real, dimension(:,:,:), allocatable :: yr
>       real, dimension(:,:,:), allocatable :: zr
21d23
<       pointer (ip_xr,xr),(ip_yr,yr),(ip_zr,zr)
30d31
<       icall  = 0
32,34c33,38
<       call umalloc(ip_xr,jdim*kdim*idim,0,icall,memuse)
<       call umalloc(ip_yr,jdim*kdim*idim,0,icall,memuse)
<       call umalloc(ip_zr,jdim*kdim*idim,0,icall,memuse)
---
>       allocate( xr(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'xr',memuse,stats)
>       allocate( yr(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'yr',memuse,stats)
>       allocate( zr(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'zr',memuse,stats)
43c47,48
<             read(1) (((xr(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
---
>             read(1,end=999,err=999)
>      .              (((xr(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
59c64,65
<             read(1) (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
---
>             read(1,end=999,err=999) 
>      .              (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
64c70,71
<          read(1) (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
---
>          read(1,end=999,err=999) 
>      .           (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
74c81,82
<             read(1) (((xr(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
---
>             read(1,end=999,err=999) 
>      .              (((xr(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
87c95,96
<             read(1) (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
---
>             read(1,end=999,err=999) 
>      .              (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
92c101,102
<          read(1) (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
---
>          read(1,end=999,err=999) 
>      .           (((x(j,k,i),j=1,jdim),k=1,kdim),i=1,idim),
108,110c118,120
<       call ufree(ip_xr)
<       call ufree(ip_yr)
<       call ufree(ip_zr)
---
>       deallocate(xr)
>       deallocate(yr)
>       deallocate(zr)
112a123,125
>       return
>  999  continue
>       irr=1
Index: source/cfl3d/libs/readdat.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/readdat.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
4c4
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
14c14
<       real bcdatar(mdim,ndim,2,7)
---
>       integer stats
16c16
<       pointer (ip_bcdatar,bcdatar)
---
>       real, dimension(:,:,:,:), allocatable :: bcdatar
24a25
> 
28d28
<       icall  = 0
30c30,31
<       call umalloc(ip_bcdatar,mdim*ndim*2*7,0,icall,memuse)
---
>       allocate( bcdatar(mdim,ndim,2,7), stat=stats )
>       call umalloc(mdim*ndim*2*7,0,'bcdatar',memuse,stats)
46,48c47,48
<          nou(1) = min(nou(1)+1,ibufdim)
<          write(bou(nou(1),1),'(''  reading bc data file '',a80)')
<      .   filname
---
>          write(11,*)
>          write(11,'('' reading bc data file '',a80)') filname
52,57c52,55
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),*)' stopping in readdat...data file',
<      .      ' has dimensions ',mdum,ndum
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),*)' dimensions set from input file',
<      .      ' are',mdim,ndim
---
>             write(11,'('' stopping in readdat...data file'' 
>      .      '' has dimensions '',2i6)')mdum,ndum
>             write(11,'('' dimensions set from input file'',
>      .      '' are '',2i6)') mdim,ndim
61,63c59,60
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),*)' stopping in readdat...data file',
<      .      ' must have 1 or 2 planes of data - there are ',np
---
>             write(11,'('' stopping in readdat...data file'',
>      .      '' must have 1 or 2 planes of data - there are '',i6)') np
68,70c65,66
<             nou(1) = min(nou(1)+1,ibufdim)
<             write(bou(nou(1),1),*) ' stopping in readdat...no more',
<      .      ' than 7 variables are allowed - there are ',nvar
---
>             write(11,'('' stopping in readdat...no more'',
>      .      '' than 7 variables are allowed - there are '',i6)') nvar
115c111
<       call ufree(ip_bcdatar)
---
>       deallocate(bcdatar)
Index: source/cfl3d/libs/readkey.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/readkey.F,v
retrieving revision 1.3
retrieving revision 1.13
diff -r1.3 -r1.13
4c4
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
24a25,26
>       common /des/ cdes,ides
>       common /avgdata/ xnumavg,iteravg
34c36,37
<      .                geom_img,surf_img
---
>      .                geom_img,surf_img,xrotrate_img,yrotrate_img,
>      .                zrotrate_img
40c43
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
48a52,55
>       common /noninertial/ xcentrot,ycentrot,zcentrot,xrotrate,
>      .                     yrotrate,zrotrate,noninflag
>       common /ivals/ p0,rho0,c0,u0,v0,w0,et0,h0,pt0,rhot0,qiv(5),
>      .        tur10,tur20
273a281,376
> c     non-inertial reference frame flag (0=inertial; 1=noninertial)
> c
>       noninflag = 0
>       nkey      = nkey + 1
> c
> c     rotation center x-coordinate for non-inertial reference frame
> c
>       xcentrot = 0.
>       nkey     = nkey + 1
> c
> c     rotation center y-coordinate for non-inertial reference frame
> c
>       ycentrot = 0.
>       nkey     = nkey + 1
> c
> c     rotation center z-coordinate for non-inertial reference frame
> c
>       zcentrot = 0.
>       nkey     = nkey + 1
> c
> c     rotation rate in x-direction for non-inertial reference frame
> c
>       xrotrate = 0.
>       nkey     = nkey + 1
> c
> c     rotation rate in y-direction for non-inertial reference frame
> c
>       yrotrate = 0.
>       nkey     = nkey + 1
> c
> c     rotation rate in z-direction for non-inertial reference frame
> c
>       zrotrate = 0.
>       nkey     = nkey + 1
> c
> c     complex perturbation to the rotation rate in x-direction for
> c     non-inertial reference frame
>       xrotrate_img = 0.
>       nkey      = nkey + 1
> c
> c     complex perturbation to the rotation rate in y-direction for
> c     non-inertial reference frame
>       yrotrate_img = 0.
>       nkey      = nkey + 1
> c
> c     complex perturbation to the rotation rate in z-direction for
> c     non-inertial reference frame
>       zrotrate_img = 0.
>       nkey      = nkey + 1
> c
> c     flag to read (1) or skip reading (0) 2nd order-time turbulence 
> c     terms and dt in restart file (need to skip if using an older 
> c     time-accurate-with-2nd-order-time restart file which does not 
> c     have them) - 1=default
> c
>       itime2read = 1
>       nkey     = nkey + 1
> c
> c     flag to control time-accuracy of turbulence model - in the old
> c     method (0), turb eqns were 1st order regardless of order of
> c     accuracy of mean flow eqns; new default (1) is they are the same
> c     order as the mean flow eqns, as defined by the parameter "ita"
> c
>       itaturb = 1
>       nkey     = nkey + 1
> c
> c     flag to perform DES with turbulence model (1) or not (0)
> c
>       ides = 0
>       nkey     = nkey + 1
> c
> c     constant associated with DES
> c
>       cdes = 0.65
>       nkey     = nkey + 1
> c
> c     flag to store iteration-averaged q values in a PLOT3D file:
> c     0 = no averaging or storage, 1 = start averaging now,
> c     2 = continue averaging from previous run
> c
>       iteravg = 0
>       nkey     = nkey + 1
> c
> c     turbulent quantity freestream levels
> c     < 0  = use the default value (different for each turb model)
> c     >= 0 = use this number as the specified user input value
> c     (defaults=-1)
>       tur10 = -1.
>       tur20 = -1.
>       nkey     = nkey + 2
> c
> c     lower limit on epsilon or omega for 2-eqn models,
> c     applied only if it goes negative
>       tur1cut = 1.e-20
>       nkey     = nkey + 1
> c
532a636,729
> c
>       else if (inpstr(lc1:lc2).eq.'noninflag') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) noninflag
> c
>       else if (inpstr(lc1:lc2).eq.'xcentrot') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          xcentrot = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'ycentrot') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          ycentrot = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'zcentrot') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          zcentrot = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'xrotrate') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          xrotrate = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'yrotrate') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          yrotrate = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'zrotrate') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          zrotrate = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'xrotrate_img') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          xrotrate_img = realval(1)
> #ifdef CMPLX
>          xrotrate = cmplx(real(xrotrate),real(xrotrate_img))
> #endif
> c
>       else if (inpstr(lc1:lc2).eq.'yrotrate_img') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          yrotrate_img = realval(1)
> #ifdef CMPLX
>          yrotrate = cmplx(real(yrotrate),real(yrotrate_img))
> #endif
> c
>       else if (inpstr(lc1:lc2).eq.'zrotrate_img') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          zrotrate_img = realval(1)
> #ifdef CMPLX
>          zrotrate = cmplx(real(zrotrate),real(zrotrate_img))
> #endif
> c
>       else if (inpstr(lc1:lc2).eq.'itime2read') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) itime2read
> c
>       else if (inpstr(lc1:lc2).eq.'itaturb') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) itaturb
> c
>       else if (inpstr(lc1:lc2).eq.'ides') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) ides
> c
>       else if (inpstr(lc1:lc2).eq.'cdes') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          cdes = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'iteravg') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) iteravg
> c
>       else if (inpstr(lc1:lc2).eq.'tur10') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          tur10 = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'tur20') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          tur20 = realval(1)
> c
>       else if (inpstr(lc1:lc2).eq.'tur1cut') then
>          lc2 = lc2 +1
>          read(inpstr(lc2:lcl),*) realval(1)
>          tur1cut = realval(1)
Index: source/cfl3d/libs/resid.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/resid.F,v
retrieving revision 1.2
retrieving revision 1.7
diff -r1.2 -r1.7
10c10
<      .           idefrm,iadvance)
---
>      .           idefrm,iadvance,qavg)
12c12
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
36c36
<       dimension q(jdim*kdim*idim,5),   qj0(kdim*(idim-1),5,4),
---
>       dimension q(jdim,kdim,idim,5),   qj0(kdim*(idim-1),5,4),
53c53
<       dimension ux(jdim-1,kdim-1,idim-1,9),xib2(jdim,kdim,idim,2)
---
>       dimension ux(jdim-1,kdim-1,idim-1,9),xib2(jdim,kdim,idim,4)
59a60
>       dimension qavg(jdim-1,kdim-1,idim-1,5)
61c62,64
<       common /cfl/ dt0
---
>       common /avgdata/ xnumavg,iteravg
>       common /fluid/ gamma,gm1,gp1,gm1g,gp1g,ggm1
>       common /cfl/ dt0,dtold
73a77,78
>       common /noninertial/ xcentrot,ycentrot,zcentrot,xrotrate,
>      .                     yrotrate,zrotrate,noninflag
632a638,644
> c     call resnonin to add rotating noninertital source term to res
> c
>       if (noninflag.gt.0) then
>         call resnonin(nbl,jdim,kdim,idim,q,x,y,z,sj,sk,si,vol,res,
>      .                nou,bou,nbuf,ibufdim)
>       endif
> c
670a683,711
>       if (iteravg .eq. 1 .or. iteravg .eq. 2) then
>       if (level.ge.lglobal .and. ntime.eq.nit) then
>         if (real(dt) .lt. 0. .or. (real(dt) .gt. 0. .and. 
>      +      icyc .eq. ncyc)) then
> c   get iteration-averaged Q values and increment xnumavg
> c   note: the qavg values are kept as conserved variables, whereas 
> c   q values are primitive (this is done to avoid round-off differences
> c   during restarts, because the PLOT3D output is in conserved form)
>           do i=1,idim-1
>             do j=1,jdim-1
>               do k=1,kdim-1
>                 qavg(j,k,i,1)=(qavg(j,k,i,1)*(xnumavg-1.)+
>      +            q(j,k,i,1))/xnumavg
>                 qavg(j,k,i,2)=(qavg(j,k,i,2)*(xnumavg-1.)+
>      +            q(j,k,i,1)*q(j,k,i,2))/xnumavg
>                 qavg(j,k,i,3)=(qavg(j,k,i,3)*(xnumavg-1.)+
>      +            q(j,k,i,1)*q(j,k,i,3))/xnumavg
>                 qavg(j,k,i,4)=(qavg(j,k,i,4)*(xnumavg-1.)+
>      +            q(j,k,i,1)*q(j,k,i,4))/xnumavg
>                 qavg(j,k,i,5)=(qavg(j,k,i,5)*(xnumavg-1.)+
>      +            (q(j,k,i,5)/gm1+0.5*(q(j,k,i,2)**2+
>      +            q(j,k,i,3)**2+q(j,k,i,4)**2)/q(j,k,i,1))
>      +            )/xnumavg
>               enddo
>             enddo
>           enddo
>         end if
>       end if
>       end if
Index: source/cfl3d/libs/rp3d.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/rp3d.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
1c1
<       subroutine rp3d(x,y,z,jdim,kdim,idim,igrid,ialph,igeom_img)
---
>       subroutine rp3d(x,y,z,jdim,kdim,idim,igrid,ialph,igeom_img,irr)
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
18,19c18
<       real xr(jdim,kdim,idim),yr(jdim,kdim,idim),
<      .     zr(jdim,kdim,idim)
---
>       integer stats
21c20,22
<       pointer (ip_xr,xr),(ip_yr,yr),(ip_zr,zr)
---
>       real, dimension(:,:,:), allocatable :: xr
>       real, dimension(:,:,:), allocatable :: yr
>       real, dimension(:,:,:), allocatable :: zr
31d31
<       icall  = 0
33,35c33,38
<       call umalloc(ip_xr,jdim*kdim*idim,0,icall,memuse)
<       call umalloc(ip_yr,jdim*kdim*idim,0,icall,memuse)
<       call umalloc(ip_zr,jdim*kdim*idim,0,icall,memuse)
---
>       allocate( xr(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'xr',memuse,stats)
>       allocate( yr(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'yr',memuse,stats)
>       allocate( zr(jdim,kdim,idim), stat=stats )
>       call umalloc(jdim*kdim*idim,0,'zr',memuse,stats)
44c47,48
<             read(1) (((xr(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
---
>             read(1,end=999,err=999) 
>      .              (((xr(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
60c64,65
<             read(1) (((x(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
---
>             read(1,end=999,err=999) 
>      .              (((x(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
66c71,72
<          read(1) (((x(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
---
>          read(1,end=999,err=999) 
>      .           (((x(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
76c82,83
<             read(1) (((xr(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
---
>             read(1,end=999,err=999) 
>      .              (((xr(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
92c99,100
<             read(1) (((x(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
---
>             read(1,end=999,err=999) 
>      .              (((x(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
97c105,106
<          read(1) (((x(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
---
>          read(1,end=999,err=999) 
>      .           (((x(j,k,i),i=1,idim),j=1,jdim),k=1,kdim),
113,115c122,124
<       call ufree(ip_xr)
<       call ufree(ip_yr)
<       call ufree(ip_zr)
---
>       deallocate(xr)
>       deallocate(yr)
>       deallocate(zr)
117a127,129
>       return
>  999  continue
>       irr=1
Index: source/cfl3d/libs/rpatch.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/rpatch.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
5c5
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
15c15
<       real windexr(maxxe,2),dthetxr,dthetyr,dthetzr
---
>       integer stats
17c17
<       pointer (ip_windexr,windexr)
---
>       real, dimension(:,:), allocatable :: windexr
27a28
> 
31d31
<       icall  = 0
33c33,34
<       call umalloc(ip_windexr,maxxe*2,0,icall,memuse)
---
>       allocate( windexr(maxxe,2), stat=stats )
>       call umalloc(maxxe*2,0,'windexr',memuse,stats)
148c149
<       call ufree(ip_windexr)
---
>       deallocate(windexr)
Index: source/cfl3d/libs/rsurf.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/rsurf.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
5c5
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
24,25c24
<       real deltjr(kdim,idim,3,2),deltkr(jdim,idim,3,2),
<      .     deltir(jdim,kdim,3,2)
---
>       integer stats
27c26,28
<       pointer (ip_deltjr,deltjr),(ip_deltkr,deltkr),(ip_deltir,deltir)
---
>       real, dimension(:,:,:,:), allocatable :: deltir
>       real, dimension(:,:,:,:), allocatable :: deltjr
>       real, dimension(:,:,:,:), allocatable :: deltkr
43c44,45
<      .                geom_img,surf_img
---
>      .                geom_img,surf_img,xrotrate_img,yrotrate_img,
>      .                zrotrate_img
51d52
<       icall  = 0
53,55c54,59
<       call umalloc(ip_deltjr,kdim*idim*3*2,0,icall,memuse)
<       call umalloc(ip_deltkr,jdim*idim*3*2,0,icall,memuse)
<       call umalloc(ip_deltir,jdim*kdim*3*2,0,icall,memuse)
---
>       allocate( deltir(jdim,kdim,3,2), stat=stats )
>       call umalloc(jdim*kdim*3*2,0,'deltir',memuse,stats)
>       allocate( deltjr(kdim,idim,3,2), stat=stats )
>       call umalloc(kdim*idim*3*2,0,'deltjr',memuse,stats)
>       allocate( deltkr(jdim,idim,3,2), stat=stats )
>       call umalloc(jdim*idim*3*2,0,'deltkr',memuse,stats)
203,205c207,209
<       call ufree(ip_deltjr)
<       call ufree(ip_deltkr)
<       call ufree(ip_deltir)
---
>       deallocate(deltjr)
>       deallocate(deltkr)
>       deallocate(deltir)
Index: source/cfl3d/libs/shear.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/shear.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
11c11
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
27c27
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
55c55
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
Index: source/cfl3d/libs/spalart.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/spalart.F,v
retrieving revision 1.2
retrieving revision 1.6
diff -r1.2 -r1.6
7c7
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
22a23
>       common /des/ cdes,ides
35c36,37
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
>       common /unst/ time,cfltau,ntstep,ita,iunst
55c57
<       dimension tursav2(jdim,kdim,idim,2)
---
>       dimension tursav2(jdim,kdim,idim,4)
59a62,67
>          if (ides .eq. 1) then
>          nou(1) = min(nou(1)+1,ibufdim)
>          write(bou(nou(1),1),'(''   computing turbulent'',
>      +'' viscosity using Spalart DES (cdes='',f7.3,
>      +''), block ='',i4)') cdes,nbl
>          else
62a71
>          end if
78a88,110
>       phi=0.
>       if (real(dt) .gt. 0.) then
>         if (abs(ita) .eq. 2) then
>           phi=0.5
>         else
>           phi=0.
>         end if
> c   revert to old way (always 1st order for turb model) if itaturb=0
>         if (itaturb .eq. 0) then
>           phi=0.
>           if (isklton .gt. 0) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),'(''   turb model is 1st'',
>      +       '' order in time'')')
>           end if
>         else
>           if (isklton .gt. 0) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),'(''   turb model is same'',
>      +       '' order in time as mean flow eqns'')')
>           end if
>         end if
>       end if
185a218,220
> c tursav2(j,k,i,1) and (j,k,i,2) are turb quantities 
> c tursav2(j,k,i,3) and (j,k,i,4) are Delta turb quantities
> c (in SA, only (j,k,i,1) and (j,k,i,3) are used)
186a222,243
>       if (abs(ita) .eq. 2) then
> c     if tursav2 at 1st point is zero, then we know that we do not have 
> c     2nd order data from the restart; no choice but to set 
> c     tursav2(j,k,i,3)=deltaQ=0 for 1st iteration
>         if (real(tursav2(1,1,1,1)) .eq. 0.) then
>         do i=1,idim-1
>           do k=1,kdim-1
>             do j=1,jdim-1
>               tursav2(j,k,i,3)=0.
>             enddo
>           enddo
>         enddo
>         else
>         do i=1,idim-1
>           do k=1,kdim-1
>             do j=1,jdim-1
>               tursav2(j,k,i,3)=tursav(j,k,i,1)-tursav2(j,k,i,1)
>             enddo
>           enddo
>         enddo
>         end if
>       end if
741a799,822
> c     can use damp1 to temporarily store distance variable (different for DES)
> c     (later, damp1 is used to store LHS implicit contribution)
>         if (ides .eq. 1) then
>         do i=1,idim-1
>           do j=1,jdim-1
>             do k=1,kdim-1
>               deltaj = 2.*vol(j,k,i)/(sj(j,k,i,4)+sj(j+1,k,i,4))
>               deltak = 2.*vol(j,k,i)/(sk(j,k,i,4)+sk(j,k+1,i,4))
>               deltai = 2.*vol(j,k,i)/(si(j,k,i,4)+si(j,k,i+1,4))
>               delta = ccmax(deltaj,deltak)
>               delta = ccmax(delta,deltai)
>               damp1(j,k,i) = ccmin(smin(j,k,i),cdes*delta)
>             enddo
>           enddo
>         enddo
>         else
>         do i=1,idim-1
>           do j=1,jdim-1
>             do k=1,kdim-1
>               damp1(j,k,i) = smin(j,k,i)
>             enddo
>           enddo
>         enddo
>         end if
756c837
<               sst=ss+turre(j,k,i)*fv2/(re*(akarman*smin(j,k,i))**2)
---
>               sst=ss+turre(j,k,i)*fv2/(re*(akarman*damp1(j,k,i))**2)
758c839
<               rr=turre(j,k,i)/(sst*re*(akarman*smin(j,k,i))**2)
---
>               rr=turre(j,k,i)/(sst*re*(akarman*damp1(j,k,i))**2)
766c847
<               dist2i=1./(re*smin(j,k,i)**2+1.e-20)
---
>               dist2i=1./(re*damp1(j,k,i)**2+1.e-20)
939c1020
<               cy(j,k)=cy(j,k)*fact+1.0
---
>               cy(j,k)=cy(j,k)*fact+1.0*(1.+phi)
945c1026,1027
<                 fy(j,k)=fy(j,k)+tursav2(j,k,i,1)-turre(j,k,i)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(tursav2(j,k,i,1)-turre(j,k,i))
>      +                 +phi*tursav2(j,k,i,3)
1015c1097
<               cy(j,k)=cy(j,k)*fact+1.0
---
>               cy(j,k)=cy(j,k)*fact+1.0*(1.+phi)
1021c1103,1104
<                 fy(j,k)=fy(j,k)+tursav2(j,k,i,1)-turre(j,k,i)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(tursav2(j,k,i,1)-turre(j,k,i))
>      +                 +phi*tursav2(j,k,i,3)
1090c1173
<               cy(j,k)=cy(j,k)*fact+1.0
---
>               cy(j,k)=cy(j,k)*fact+1.0*(1.+phi)
1096c1179,1180
<                 fy(j,k)=fy(j,k)+tursav2(j,k,i,1)-turre(j,k,i)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(tursav2(j,k,i,1)-turre(j,k,i))
>      +                 +phi*tursav2(j,k,i,3)
1179c1263
<               cx(k,j)=cx(k,j)*fact+1.0
---
>               cx(k,j)=cx(k,j)*fact+1.0*(1.+phi)
1181c1265
<               fx(k,j)=vist3d(j,k,i)
---
>               fx(k,j)=vist3d(j,k,i)*(1.+phi)
1245c1329
<               cx(k,j)=cx(k,j)*fact+1.0
---
>               cx(k,j)=cx(k,j)*fact+1.0*(1.+phi)
1247c1331
<               fx(k,j)=vist3d(j,k,i)
---
>               fx(k,j)=vist3d(j,k,i)*(1.+phi)
1310c1394
<               cx(k,j)=cx(k,j)*fact+1.0
---
>               cx(k,j)=cx(k,j)*fact+1.0*(1.+phi)
1312c1396
<               fx(k,j)=vist3d(j,k,i)
---
>               fx(k,j)=vist3d(j,k,i)*(1.+phi)
1395c1479
<                 cz(k,i)=cz(k,i)*fact+1.0
---
>                 cz(k,i)=cz(k,i)*fact+1.0*(1.+phi)
1397c1481
<                 fz(k,i)=vist3d(j,k,i)
---
>                 fz(k,i)=vist3d(j,k,i)*(1.+phi)
1461c1545
<                 cz(k,i)=cz(k,i)*fact+1.0
---
>                 cz(k,i)=cz(k,i)*fact+1.0*(1.+phi)
1463c1547
<                 fz(k,i)=vist3d(j,k,i)
---
>                 fz(k,i)=vist3d(j,k,i)*(1.+phi)
1526c1610
<                 cz(k,i)=cz(k,i)*fact+1.0
---
>                 cz(k,i)=cz(k,i)*fact+1.0*(1.+phi)
1528c1612
<                 fz(k,i)=vist3d(j,k,i)
---
>                 fz(k,i)=vist3d(j,k,i)*(1.+phi)
Index: source/cfl3d/libs/topol2.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/topol2.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
20c20
<      .             aeinp,aeout,sdhist
---
>      .             aeinp,aeout,sdhist,avgg,avgq
32c32
<      .                 aeinp,aeout,sdhist
---
>      .                 aeinp,aeout,sdhist,avgg,avgq
Index: source/cfl3d/libs/twoeqn.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/cfl3d/libs/twoeqn.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
10c10
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
42c42,43
<      .                  iwarneddy
---
>      .                  iwarneddy,itime2read,itaturb,tur1cut
>       common /unst/ time,cfltau,ntstep,ita,iunst
69c70
<       dimension ux(jdim-1,kdim-1,idim-1,9),zksav2(jdim,kdim,idim,2),
---
>       dimension ux(jdim-1,kdim-1,idim-1,9),zksav2(jdim,kdim,idim,4),
98a100,101
> c               (k,j,i,1) and (j,k,i,2) = k and omega (or epsilon)
> c               (k,j,i,3) and (j,k,i,4) = delta k and delta omega (or epsilon)
341c344
<       if(ivmx.eq.8 .or. ivmx.eq.14)                 sigk1=1./2.0
---
>       if(ivmx.eq.8 .or. ivmx.eq.14)                 sigk1=1./1.0
349c352
<       if(ivmx.eq.8 .or. ivmx.eq.14)                 alp1 = 0.575
---
>       if(ivmx.eq.8 .or. ivmx.eq.14)                 alp1 = 0.53
383a387,409
>       phi=0.
>       if (real(dt) .gt. 0.) then
>         if (abs(ita) .eq. 2) then
>           phi=0.5
>         else
>           phi=0.
>         end if
> c   revert to old way (always 1st order for turb model) if itaturb=0
>         if (itaturb .eq. 0) then
>           phi=0.
>           if (isklton .gt. 0) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),'(''   turb model is 1st'',
>      +       '' order in time'')')
>           end if
>         else
>           if (isklton .gt. 0) then
>             nou(1) = min(nou(1)+1,ibufdim)
>             write(bou(nou(1),1),'(''   turb model is same'',
>      +       '' order in time as mean flow eqns'')')
>           end if
>         end if
>       end if
486a513,514
> c zksav2(j,k,i,1) and (j,k,i,2) are turb quantities
> c zksav2(j,k,i,3) and (j,k,i,4) are Delta turb quantities
487a516,539
>       if (abs(ita) .eq. 2) then
> c     if zksav2 at 1st point is zero, then we know that we do not have
> c     2nd order data from the restart; no choice but to set
> c     zksav2(j,k,i,3&4)=deltaQ=0 for 1st iteration
>         if (real(zksav2(1,1,1,1)) .eq. 0.) then
>         do i=1,idim-1
>           do k=1,kdim-1
>             do j=1,jdim-1
>               zksav2(j,k,i,3)=0.
>               zksav2(j,k,i,4)=0.
>             enddo
>           enddo
>         enddo
>         else
>         do i=1,idim-1
>           do k=1,kdim-1
>             do j=1,jdim-1
>               zksav2(j,k,i,3)=zksav(j,k,i,1)-zksav2(j,k,i,1)
>               zksav2(j,k,i,4)=zksav(j,k,i,2)-zksav2(j,k,i,2)
>             enddo
>           enddo
>         enddo
>         end if
>       end if
1814,1815c1866,1867
<               cy(j,k)=cy(j,k)*timestp(j,k,i)+1.0
<               cy2(j,k)=cy2(j,k)*timestp(j,k,i)+1.0
---
>               cy(j,k)=cy(j,k)*timestp(j,k,i)+1.0*(1.+phi)
>               cy2(j,k)=cy2(j,k)*timestp(j,k,i)+1.0*(1.+phi)
1823,1824c1875,1878
<                 fy(j,k)=fy(j,k)+zksav2(j,k,i,1)-turre(j,k,i,1)
<                 fy2(j,k)=fy2(j,k)+zksav2(j,k,i,2)-turre(j,k,i,2)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(zksav2(j,k,i,1)-
>      +                 turre(j,k,i,1))+phi*zksav2(j,k,i,3)
>                 fy2(j,k)=fy2(j,k)+(1.+phi)*(zksav2(j,k,i,2)-
>      +                 turre(j,k,i,2))+phi*zksav2(j,k,i,4)
1926,1927c1980,1981
<               cy(j,k)=cy(j,k)*timestp(j,k,i)+1.0
<               cy2(j,k)=cy2(j,k)*timestp(j,k,i)+1.0
---
>               cy(j,k)=cy(j,k)*timestp(j,k,i)+1.0*(1.+phi)
>               cy2(j,k)=cy2(j,k)*timestp(j,k,i)+1.0*(1.+phi)
1935,1936c1989,1992
<                 fy(j,k)=fy(j,k)+zksav2(j,k,i,1)-turre(j,k,i,1)
<                 fy2(j,k)=fy2(j,k)+zksav2(j,k,i,2)-turre(j,k,i,2)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(zksav2(j,k,i,1)-
>      +                 turre(j,k,i,1))+phi*zksav2(j,k,i,3)
>                 fy2(j,k)=fy2(j,k)+(1.+phi)*(zksav2(j,k,i,2)-
>      +                 turre(j,k,i,2))+phi*zksav2(j,k,i,4)
2037,2038c2093,2094
<               cy(j,k)=cy(j,k)*timestp(j,k,i)+1.0
<               cy2(j,k)=cy2(j,k)*timestp(j,k,i)+1.0
---
>               cy(j,k)=cy(j,k)*timestp(j,k,i)+1.0*(1.+phi)
>               cy2(j,k)=cy2(j,k)*timestp(j,k,i)+1.0*(1.+phi)
2046,2047c2102,2105
<                 fy(j,k)=fy(j,k)+zksav2(j,k,i,1)-turre(j,k,i,1)
<                 fy2(j,k)=fy2(j,k)+zksav2(j,k,i,2)-turre(j,k,i,2)
---
>                 fy(j,k)=fy(j,k)+(1.+phi)*(zksav2(j,k,i,1)-
>      +                 turre(j,k,i,1))+phi*zksav2(j,k,i,3)
>                 fy2(j,k)=fy2(j,k)+(1.+phi)*(zksav2(j,k,i,2)-
>      +                 turre(j,k,i,2))+phi*zksav2(j,k,i,4)
2148,2149c2206,2207
<               cx(k,j)=cx(k,j)*timestp(j,k,i)+1.0
<               cx2(k,j)=cx2(k,j)*timestp(j,k,i)+1.0
---
>               cx(k,j)=cx(k,j)*timestp(j,k,i)+1.0*(1.+phi)
>               cx2(k,j)=cx2(k,j)*timestp(j,k,i)+1.0*(1.+phi)
2152,2153c2210,2211
<               fx(k,j)=rhside(j,k,i,1)
<               fx2(k,j)=rhside(j,k,i,2)
---
>               fx(k,j)=rhside(j,k,i,1)*(1.+phi)
>               fx2(k,j)=rhside(j,k,i,2)*(1.+phi)
2228,2229c2286,2287
<               cx(k,j)=cx(k,j)*timestp(j,k,i)+1.0
<               cx2(k,j)=cx2(k,j)*timestp(j,k,i)+1.0
---
>               cx(k,j)=cx(k,j)*timestp(j,k,i)+1.0*(1.+phi)
>               cx2(k,j)=cx2(k,j)*timestp(j,k,i)+1.0*(1.+phi)
2232,2233c2290,2291
<               fx(k,j)=rhside(j,k,i,1)
<               fx2(k,j)=rhside(j,k,i,2)
---
>               fx(k,j)=rhside(j,k,i,1)*(1.+phi)
>               fx2(k,j)=rhside(j,k,i,2)*(1.+phi)
2307,2308c2365,2366
<               cx(k,j)=cx(k,j)*timestp(j,k,i)+1.0
<               cx2(k,j)=cx2(k,j)*timestp(j,k,i)+1.0
---
>               cx(k,j)=cx(k,j)*timestp(j,k,i)+1.0*(1.+phi)
>               cx2(k,j)=cx2(k,j)*timestp(j,k,i)+1.0*(1.+phi)
2311,2312c2369,2370
<               fx(k,j)=rhside(j,k,i,1)
<               fx2(k,j)=rhside(j,k,i,2)
---
>               fx(k,j)=rhside(j,k,i,1)*(1.+phi)
>               fx2(k,j)=rhside(j,k,i,2)*(1.+phi)
2413,2414c2471,2472
<                 cz(k,i)=cz(k,i)*timestp(j,k,i)+1.0
<                 cz2(k,i)=cz2(k,i)*timestp(j,k,i)+1.0
---
>                 cz(k,i)=cz(k,i)*timestp(j,k,i)+1.0*(1.+phi)
>                 cz2(k,i)=cz2(k,i)*timestp(j,k,i)+1.0*(1.+phi)
2417,2418c2475,2476
<                 fz(k,i)=rhside(j,k,i,1)
<                 fz2(k,i)=rhside(j,k,i,2)
---
>                 fz(k,i)=rhside(j,k,i,1)*(1.+phi)
>                 fz2(k,i)=rhside(j,k,i,2)*(1.+phi)
2493,2494c2551,2552
<                 cz(k,i)=cz(k,i)*timestp(j,k,i)+1.0
<                 cz2(k,i)=cz2(k,i)*timestp(j,k,i)+1.0
---
>                 cz(k,i)=cz(k,i)*timestp(j,k,i)+1.0*(1.+phi)
>                 cz2(k,i)=cz2(k,i)*timestp(j,k,i)+1.0*(1.+phi)
2497,2498c2555,2556
<                 fz(k,i)=rhside(j,k,i,1)
<                 fz2(k,i)=rhside(j,k,i,2)
---
>                 fz(k,i)=rhside(j,k,i,1)*(1.+phi)
>                 fz2(k,i)=rhside(j,k,i,2)*(1.+phi)
2572,2573c2630,2631
<                 cz(k,i)=cz(k,i)*timestp(j,k,i)+1.0
<                 cz2(k,i)=cz2(k,i)*timestp(j,k,i)+1.0
---
>                 cz(k,i)=cz(k,i)*timestp(j,k,i)+1.0*(1.+phi)
>                 cz2(k,i)=cz2(k,i)*timestp(j,k,i)+1.0*(1.+phi)
2576,2577c2634,2635
<                 fz(k,i)=rhside(j,k,i,1)
<                 fz2(k,i)=rhside(j,k,i,2)
---
>                 fz(k,i)=rhside(j,k,i,1)*(1.+phi)
>                 fz2(k,i)=rhside(j,k,i,2)*(1.+phi)
2617c2675
<                 turre(j,k,i,1)=1.e-20
---
>                 turre(j,k,i,1)=tur1cut
Index: source/maggie/maggie.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/maggie/maggie.F,v
retrieving revision 1.3
retrieving revision 1.5
diff -r1.3 -r1.5
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
146c146
<  9990 format(2(2h *),43h   VERSION 6.0 :  Computational Fluids Lab,,
---
>  9990 format(2(2h *),43h   VERSION 6.X :  Computational Fluids Lab,,
149c149
<      .3x,2(2h *),/2(2h *),18x,33hRelease Date:    August  8, 2001.,
---
>      .3x,2(2h *),/2(2h *),18x,33hRelease Date:       MMM DD, YYYY.,
Index: source/precfl3d/get_cmd_args.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/precfl3d/get_cmd_args.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
36c36
<          if (arg .eq. "-np" .or. arg .eq. "-n") then
---
>          if (arg .eq. "-np" .or. arg .eq. "-nt" .or. arg .eq. "-n") then
Index: source/precfl3d/main.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/precfl3d/main.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
10c10
< c     VERSION 6.0 :  Computational Fluids Laboratory, Mail Stop 128,
---
> c     VERSION 6.X :  Computational Fluids Laboratory, Mail Stop 128,
Index: source/precfl3d/usrint.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/precfl3d/usrint.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
33c33
< #   ifdef IBM then
---
> #   ifdef IBM
Index: source/ronnie/ronnie.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/ronnie/ronnie.F,v
retrieving revision 1.3
retrieving revision 1.6
diff -r1.3 -r1.6
4c4
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
19,20c19
<       integer lout(nsub1),xif1(nsub1),xif2(nsub1),etf1(nsub1),
<      .        etf2(nsub1)
---
>       integer stats
22,27c21,22
<       dimension work(nwork),levelg(maxbl)
<       dimension mglevg(maxbl),nemgl(maxbl)
<       dimension lw(65,maxbl),lw2(43,maxbl),igridg(maxbl),jdimg(maxbl),
<      .          kdimg(maxbl),idimg(maxbl),nblcg(maxbl)
<       dimension jtest(maxgr),ktest(maxgr),itest(maxgr)
<       dimension ncgg(maxgr),nblg(maxgr),iemg(maxgr)
---
>       dimension ie_pat(5)
>       dimension is_pat(5)
29,107c24,112
<       dimension xorig(maxbl),yorig(maxbl),zorig(maxbl)
<       dimension xte(mpatch+2,mpatch+2,nsub1),
<      .          yte(mpatch+2,mpatch+2,nsub1),
<      .          zte(mpatch+2,mpatch+2,nsub1)
<       dimension xmi(mpatch+2,mpatch+2,nsub1),
<      .          ymi(mpatch+2,mpatch+2,nsub1),
<      .          zmi(mpatch+2,mpatch+2,nsub1)
<       dimension xmie(mpatch+2,mpatch+2,nsub1),
<      .          ymie(mpatch+2,mpatch+2,nsub1),
<      .          zmie(mpatch+2,mpatch+2,nsub1)
<       dimension jjmax1(nsub1),kkmax1(nsub1)
<       dimension iiint1(nsub1),iiint2(nsub1)
<       dimension jimage(nsub1,mpatch+2,mpatch+2),
<      .          kimage(nsub1,mpatch+2,mpatch+2)
<       dimension jte(nsub1),kte(nsub1)
<       dimension sxie(mpatch+2,mpatch+2,nsub1),
<      .          seta(mpatch+2,mpatch+2,nsub1),
<      .          sxie2(mpatch+2,mpatch+2),
<      .          seta2(mpatch+2,mpatch+2)
<       dimension xie2s(mpatch+2,mpatch+2),eta2s(mpatch+2,mpatch+2)
<       dimension temp((mpatch+2)*(mpatch+2))
<       dimension x2(mpatch+2,mpatch+2),y2(mpatch+2,mpatch+2),
<      .          z2(mpatch+2,mpatch+2)
<       dimension nblk1(mpatch+2),nblk2(mpatch+2)
<       dimension jmm(mpatch+2),kmm(mpatch+2)
<       dimension x1(mpatch+2,mpatch+2),y1(mpatch+2,mpatch+2),
<      .          z1(mpatch+2,mpatch+2)
<       dimension windex(maxxe,2),iindex(intmax,6*nsub1+9),
<      .          llimit(intmax),iitmax(intmax),mmcxie(intmax),
<      .          mmceta(intmax),ncheck(maxbl),iifit(intmax),
<      .          nblkpt(maxxe),iic0(intmax),iiorph(intmax),
<      .          iitoss(intmax),ifiner(intmax)
<       dimension factjlo(intmax,nsub1),factjhi(intmax,nsub1),
<      .          factklo(intmax,nsub1),factkhi(intmax,nsub1),
<      .          ifrom(nsub1)
<       dimension dx(intmax,nsub1),dy(intmax,nsub1),dz(intmax,nsub1),
<      .          dthetx(intmax,nsub1),dthety(intmax,nsub1),
<      .          dthetz(intmax,nsub1)
<       dimension isav_pat(intmax,17),isav_pat_b(intmax,nsub1,6)
<       dimension ireq_ar(intmax*3),mblk2nd(maxbl)
<       dimension is_pat(5),ie_pat(5)
< c
<       pointer (ip_levelg,levelg),(ip_mglevg,mglevg),(ip_nemgl,nemgl)
<       pointer (ip_work,work),(ip_lw,lw),(ip_lw2,lw2)
<       pointer (ip_xorig,xorig),(ip_yorig,yorig),(ip_zorig,zorig)
<       pointer (ip_jtest,jtest),(ip_ktest,ktest),(ip_itest,itest)
<       pointer (ip_ncgg,ncgg),(ip_nblg,nblg),(ip_iemg,iemg)
<       pointer (ip_igridg,igridg),(ip_nblcg,nblcg),(ip_ireq_ar,ireq_ar)
<       pointer (ip_windex,windex),(ip_iindex,iindex),
<      .        (ip_llimit,llimit),(ip_iitmax,iitmax),(ip_mmcxie,mmcxie),
<      .        (ip_mmceta,mmceta),(ip_ncheck,ncheck),(ip_iifit,iifit),
<      .        (ip_nblkpt,nblkpt),(ip_iic0,iic0),(ip_iiorph,iiorph),
<      .        (ip_iitoss,iitoss),(ip_ifiner,ifiner)
<       pointer (ip_dx,dx),(ip_dy,dy),(ip_dz,dz),
<      .        (ip_dthetx,dthetx),(ip_dthety,dthety),
<      .        (ip_dthetz,dthetz)
<       pointer (ip_lout,lout),(ip_xif1,xif1),(ip_xif2,xif2),
<      .        (ip_etf1,etf1),(ip_etf2,etf2),(ip_iiint1,iiint1),
<      .        (ip_iiint2,iiint2),(ip_jjmax1,jjmax1),
<      .        (ip_kkmax1,kkmax1),(ip_jimage,jimage),
<      .        (ip_kimage,kimage),(ip_jte,jte),(ip_kte,kte),
<      .        (ip_jmm,jmm),(ip_kmm,kmm),(ip_nblk1,nblk1),
<      .        (ip_nblk2,nblk2),(ip_xte,xte),(ip_yte,yte),
<      .        (ip_zte,zte),(ip_xmi,xmi),
<      .        (ip_ymi,ymi),(ip_zmi,zmi),
<      .        (ip_xmie,xmie),(ip_ymie,ymie),
<      .        (ip_zmie,zmie),(ip_sxie,sxie),
<      .        (ip_seta,seta),(ip_sxie2,sxie2),
<      .        (ip_seta2,seta2),(ip_xie2s,xie2s),
<      .        (ip_eta2s,eta2s),(ip_temp,temp),
<      .        (ip_x2,x2),(ip_y2,y2),
<      .        (ip_z2,z2),(ip_x1,x1),
<      .        (ip_y1,y1),(ip_z1,z1),
<      .        (ip_factjlo,factjlo),(ip_factjhi,factjhi),
<      .        (ip_factklo,factklo),(ip_factkhi,factkhi),
<      .        (ip_ifrom,ifrom)
<       pointer (ip_isav_pat,isav_pat),(ip_isav_pat_b,isav_pat_b)
<       pointer (ip_idimg,idimg),(ip_jdimg,jdimg),(ip_kdimg,kdimg)
<       pointer (ip_mblk2nd,mblk2nd)
---
> 
>       allocatable :: dthetx(:,:)
>       allocatable :: dthety(:,:)
>       allocatable :: dthetz(:,:)
>       allocatable :: dx(:,:)
>       allocatable :: dy(:,:)
>       allocatable :: dz(:,:)
>       allocatable :: eta2s(:,:)
>       integer, allocatable :: etf1(:)
>       integer, allocatable :: etf2(:)
>       allocatable :: factjhi(:,:)
>       allocatable :: factjlo(:,:)
>       allocatable :: factkhi(:,:)
>       allocatable :: factklo(:,:)
>       allocatable :: idimg(:)
>       allocatable :: iemg(:)
>       allocatable :: ifiner(:)
>       allocatable :: ifrom(:)
>       allocatable :: igridg(:)
>       allocatable :: iic0(:)
>       allocatable :: iifit(:)
>       allocatable :: iiint1(:)
>       allocatable :: iiint2(:)
>       allocatable :: iindex(:,:)
>       allocatable :: iiorph(:)
>       allocatable :: iitmax(:)
>       allocatable :: iitoss(:)
>       allocatable :: ireq_ar(:)
>       allocatable :: isav_pat(:,:)
>       allocatable :: isav_pat_b(:,:,:)
>       allocatable :: itest(:)
>       allocatable :: jdimg(:)
>       allocatable :: jimage(:,:,:)
>       allocatable :: jjmax1(:)
>       allocatable :: jmm(:)
>       allocatable :: jte(:)
>       allocatable :: jtest(:)
>       allocatable :: kdimg(:)
>       allocatable :: kimage(:,:,:)
>       allocatable :: kkmax1(:)
>       allocatable :: kmm(:)
>       allocatable :: kte(:)
>       allocatable :: ktest(:)
>       allocatable :: levelg(:)
>       allocatable :: llimit(:)
>       allocatable :: lout(:)
>       allocatable :: lw(:,:)
>       allocatable :: lw2(:,:)
>       allocatable :: mblk2nd(:)
>       allocatable :: mglevg(:)
>       allocatable :: mmceta(:)
>       allocatable :: mmcxie(:)
>       allocatable :: nblcg(:)
>       allocatable :: nblg(:)
>       allocatable :: nblk1(:)
>       allocatable :: nblk2(:)
>       allocatable :: nblkpt(:)
>       allocatable :: ncgg(:)
>       allocatable :: ncheck(:)
>       allocatable :: nemgl(:)
>       allocatable :: seta(:,:,:)
>       allocatable :: seta2(:,:)
>       allocatable :: sxie(:,:,:)
>       allocatable :: sxie2(:,:)
>       allocatable :: temp(:)
>       allocatable :: windex(:,:)
>       allocatable :: work(:)
>       allocatable :: x1(:,:)
>       allocatable :: x2(:,:)
>       allocatable :: xie2s(:,:)
>       integer, allocatable :: xif1(:)
>       integer, allocatable :: xif2(:)
>       allocatable :: xmi(:,:,:)
>       allocatable :: xmie(:,:,:)
>       allocatable :: xorig(:)
>       allocatable :: xte(:,:,:)
>       allocatable :: y1(:,:)
>       allocatable :: y2(:,:)
>       allocatable :: ymi(:,:,:)
>       allocatable :: ymie(:,:,:)
>       allocatable :: yorig(:)
>       allocatable :: yte(:,:,:)
>       allocatable :: z1(:,:)
>       allocatable :: z2(:,:)
>       allocatable :: zmi(:,:,:)
>       allocatable :: zmie(:,:,:)
>       allocatable :: zorig(:)
>       allocatable :: zte(:,:,:)
> 
137d141
<       icall  = 0
140,226c144,317
<       call umalloc(ip_work,nwork,0,icall,memuse)
<       call umalloc(ip_lw,65*maxbl,1,icall,memuse)
<       call umalloc(ip_lw2,43*maxbl,1,icall,memuse)
<       call umalloc(ip_mglevg,maxbl,1,icall,memuse)
<       call umalloc(ip_nemgl,maxbl,1,icall,memuse)
<       call umalloc(ip_levelg,maxbl,1,icall,memuse)
<       call umalloc(ip_jtest,maxgr,1,icall,memuse)
<       call umalloc(ip_ktest,maxgr,1,icall,memuse)
<       call umalloc(ip_itest,maxgr,1,icall,memuse)
<       call umalloc(ip_nblg,maxgr,1,icall,memuse)
<       call umalloc(ip_iemg,maxgr,1,icall,memuse)
<       call umalloc(ip_igridg,maxbl,1,icall,memuse)
<       call umalloc(ip_jdimg,maxbl,1,icall,memuse)
<       call umalloc(ip_kdimg,maxbl,1,icall,memuse)
<       call umalloc(ip_idimg,maxbl,1,icall,memuse)
<       call umalloc(ip_nblcg,maxbl,1,icall,memuse)
<       call umalloc(ip_ncgg,maxgr,1,icall,memuse)
<       call umalloc(ip_xorig,maxbl,0,icall,memuse)
<       call umalloc(ip_yorig,maxbl,0,icall,memuse)
<       call umalloc(ip_zorig,maxbl,0,icall,memuse)
<       call umalloc(ip_windex,2*maxxe,0,icall,memuse)
<       call umalloc(ip_iindex,intmax*(6*nsub1+9),1,icall,memuse)
<       call umalloc(ip_llimit,intmax,1,icall,memuse)
<       call umalloc(ip_iitmax,intmax,1,icall,memuse)
<       call umalloc(ip_mmcxie,intmax,1,icall,memuse)
<       call umalloc(ip_mmceta,intmax,1,icall,memuse)
<       call umalloc(ip_ncheck,maxbl,1,icall,memuse)
<       call umalloc(ip_iifit,intmax,1,icall,memuse)
<       call umalloc(ip_nblkpt,maxxe,1,icall,memuse)
<       call umalloc(ip_iic0,intmax,1,icall,memuse)
<       call umalloc(ip_iiorph,intmax,1,icall,memuse)
<       call umalloc(ip_iitoss,intmax,1,icall,memuse)
<       call umalloc(ip_ifiner,intmax,1,icall,memuse)
<       call umalloc(ip_dx,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_dy,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_dz,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_dthetx,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_dthety,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_dthetz,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_lout,nsub1,1,icall,memuse)
<       call umalloc(ip_xif1,nsub1,1,icall,memuse)
<       call umalloc(ip_xif2,nsub1,1,icall,memuse)
<       call umalloc(ip_etf1,nsub1,1,icall,memuse)
<       call umalloc(ip_etf2,nsub1,1,icall,memuse)
<       call umalloc(ip_jjmax1,nsub1,1,icall,memuse)
<       call umalloc(ip_kkmax1,nsub1,1,icall,memuse)
<       call umalloc(ip_iiint1,nsub1,1,icall,memuse)
<       call umalloc(ip_iiint2,nsub1,1,icall,memuse)
<       call umalloc(ip_jimage,nsub1*(mpatch+2)*(mpatch+2),1,icall,memuse)
<       call umalloc(ip_kimage,nsub1*(mpatch+2)*(mpatch+2),1,icall,memuse)
<       call umalloc(ip_jte,nsub1,1,icall,memuse)
<       call umalloc(ip_kte,nsub1,1,icall,memuse)
<       call umalloc(ip_jmm,mpatch+2,1,icall,memuse)
<       call umalloc(ip_kmm,mpatch+2,1,icall,memuse)
<       call umalloc(ip_nblk1,mpatch+2,1,icall,memuse)
<       call umalloc(ip_nblk2,mpatch+2,1,icall,memuse)
<       call umalloc(ip_xte,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_yte,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_zte,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_xmi,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_ymi,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_zmi,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_xmie,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_ymie,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_zmie,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_sxie,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_seta,nsub1*(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_sxie2,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_seta2,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_xie2s,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_eta2s,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_temp,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_x2,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_y2,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_z2,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_x1,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_y1,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_z1,(mpatch+2)*(mpatch+2),0,icall,memuse)
<       call umalloc(ip_factjlo,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_factjhi,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_factklo,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_factkhi,intmax*nsub1,0,icall,memuse)
<       call umalloc(ip_ifrom,nsub1,0,icall,memuse)
<       call umalloc(ip_isav_pat,17*intmax,1,icall,memuse)
<       call umalloc(ip_isav_pat_b,6*intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_mblk2nd,maxbl,1,icall,memuse)
<       call umalloc(ip_ireq_ar,intmax*3,1,icall,memuse)
---
>       allocate( dthetx(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'dthetx',memuse,stats)
>       allocate( dthety(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'dthety',memuse,stats)
>       allocate( dthetz(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'dthetz',memuse,stats)
>       allocate( dx(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'dx',memuse,stats)
>       allocate( dy(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'dy',memuse,stats)
>       allocate( dz(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'dx',memuse,stats)
>       allocate( eta2s(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'eta2s',memuse,stats)
>       allocate( etf1(nsub1), stat=stats)
>       call umalloc(nsub1,1,'etf1',memuse,stats)
>       allocate( etf2(nsub1), stat=stats)
>       call umalloc(nsub1,1,'etf2',memuse,stats)
>       allocate( factjhi(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'factjhi',memuse,stats)
>       allocate( factjlo(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'factjlo',memuse,stats)
>       allocate( factkhi(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'factkhi',memuse,stats)
>       allocate( factklo(intmax,nsub1), stat=stats)
>       call umalloc(intmax*nsub1,0,'factklo',memuse,stats)
>       allocate( idimg(maxbl), stat=stats)
>       call umalloc(maxbl,1,'idimg',memuse,stats)
>       allocate( iemg(maxgr), stat=stats)
>       call umalloc(maxgr,1,'iemg',memuse,stats)
>       allocate( ifiner(intmax), stat=stats)
>       call umalloc(intmax,1,'ifiner',memuse,stats)
>       allocate( ifrom(nsub1), stat=stats)
>       call umalloc(nsub1,0,'ifrom',memuse,stats)
>       allocate( igridg(maxbl), stat=stats)
>       call umalloc(maxbl,1,'igridg',memuse,stats)
>       allocate( iic0(intmax), stat=stats)
>       call umalloc(intmax,1,'iic0',memuse,stats)
>       allocate( iifit(intmax), stat=stats)
>       call umalloc(intmax,1,'iifit',memuse,stats)
>       allocate( iiint1(nsub1), stat=stats)
>       call umalloc(nsub1,1,'iiint1',memuse,stats)
>       allocate( iiint2(nsub1), stat=stats)
>       call umalloc(nsub1,1,'iiint2',memuse,stats)
>       allocate( iindex(intmax,6*nsub1+9), stat=stats)
>       call umalloc(intmax*(6*nsub1+9),1,'iindex',memuse,stats)
>       allocate( iiorph(intmax), stat=stats)
>       call umalloc(intmax,1,'iiorph',memuse,stats)
>       allocate( iitmax(intmax), stat=stats)
>       call umalloc(intmax,1,'iitmax',memuse,stats)
>       allocate( iitoss(intmax), stat=stats)
>       call umalloc(intmax,1,'iitoss',memuse,stats)
>       allocate( ireq_ar(intmax*3), stat=stats)
>       call umalloc(intmax*3,1,'ireq_ar',memuse,stats)
>       allocate( isav_pat(intmax,17), stat=stats)
>       call umalloc(intmax*17,1,'isav_pat',memuse,stats)
>       allocate( isav_pat_b(intmax,nsub1,6), stat=stats)
>       call umalloc(intmax*nsub1*6,1,'isav_pat_b',memuse,stats)
>       allocate( itest(maxgr), stat=stats)
>       call umalloc(maxgr,1,'itest',memuse,stats)
>       allocate( jdimg(maxbl), stat=stats)
>       call umalloc(maxbl,1,'jdimg',memuse,stats)
>       allocate( jimage(nsub1,mpatch+2,mpatch+2), stat=stats)
>       call umalloc(nsub1*(mpatch+2)*(mpatch+2),1,'jimage',memuse,stats)
>       allocate( jjmax1(nsub1), stat=stats)
>       call umalloc(nsub1,1,'jjmax1',memuse,stats)
>       allocate( jmm(mpatch+2), stat=stats)
>       call umalloc(mpatch+2,1,'jmm',memuse,stats)
>       allocate( jte(nsub1), stat=stats)
>       call umalloc(nsub1,1,'jte',memuse,stats)
>       allocate( jtest(maxgr), stat=stats)
>       call umalloc(maxgr,1,'jtest',memuse,stats)
>       allocate( kdimg(maxbl), stat=stats)
>       call umalloc(maxbl,1,'kdimg',memuse,stats)
>       allocate( kimage(nsub1,mpatch+2,mpatch+2), stat=stats)
>       call umalloc(nsub1*(mpatch+2)*(mpatch+2),1,'kimage',memuse,stats)
>       allocate( kkmax1(nsub1), stat=stats)
>       call umalloc(nsub1,1,'kkmax1',memuse,stats)
>       allocate( kmm(mpatch+2), stat=stats)
>       call umalloc(mpatch+2,1,'kmm',memuse,stats)
>       allocate( kte(nsub1), stat=stats)
>       call umalloc(nsub1,1,'kte',memuse,stats)
>       allocate( ktest(maxgr), stat=stats)
>       call umalloc(maxgr,1,'ktest',memuse,stats)
>       allocate( levelg(maxbl), stat=stats)
>       call umalloc(maxbl,1,'levelg',memuse,stats)
>       allocate( llimit(intmax), stat=stats)
>       call umalloc(intmax,1,'llimit',memuse,stats)
>       allocate( lout(nsub1), stat=stats)
>       call umalloc(nsub1,1,'lout',memuse,stats)
>       allocate( lw(65,maxbl), stat=stats)
>       call umalloc(65*maxbl,1,'lw',memuse,stats)
>       allocate( lw2(43,maxbl), stat=stats)
>       call umalloc(43*maxbl,1,'lw2',memuse,stats)
>       allocate( mblk2nd(maxbl), stat=stats)
>       call umalloc(maxbl,1,'mblk2nd',memuse,stats)
>       allocate( mglevg(maxbl), stat=stats)
>       call umalloc(maxbl,1,'mglevg',memuse,stats)
>       allocate( mmceta(intmax), stat=stats)
>       call umalloc(intmax,1,'mmceta',memuse,stats)
>       allocate( mmcxie(intmax), stat=stats)
>       call umalloc(intmax,1,'mmcxie',memuse,stats)
>       allocate( nblcg(maxbl), stat=stats)
>       call umalloc(maxbl,1,'nblcg',memuse,stats)
>       allocate( nblg(maxgr), stat=stats)
>       call umalloc(maxgr,1,'nblg',memuse,stats)
>       allocate( nblk1(mpatch+2), stat=stats)
>       call umalloc(mpatch+2,1,'nblk1',memuse,stats)
>       allocate( nblk2(mpatch+2), stat=stats)
>       call umalloc(mpatch+2,1,'nblk2',memuse,stats)
>       allocate( nblkpt(maxxe), stat=stats)
>       call umalloc(maxxe,1,'nblkpt',memuse,stats)
>       allocate( ncgg(maxgr), stat=stats)
>       call umalloc(maxgr,1,'ncgg',memuse,stats)
>       allocate( ncheck(maxbl), stat=stats)
>       call umalloc(maxbl,1,'ncheck',memuse,stats)
>       allocate( nemgl(maxbl), stat=stats)
>       call umalloc(maxbl,1,'nemgl',memuse,stats)
>       allocate( seta(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'seta',memuse,stats)
>       allocate( seta2(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'seta2',memuse,stats)
>       allocate( sxie(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'sxie',memuse,stats)
>       allocate( sxie2(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'sxie2',memuse,stats)
>       allocate( temp((mpatch+2)*(mpatch+2)), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'temp',memuse,stats)
>       allocate( windex(maxxe,2), stat=stats)
>       call umalloc(maxxe*2,0,'windex',memuse,stats)
>       allocate( work(nwork), stat=stats)
>       call umalloc(nwork,0,'work',memuse,stats)
>       allocate( x1(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'x1',memuse,stats)
>       allocate( x2(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'x2',memuse,stats)
>       allocate( xie2s(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'xie2s',memuse,stats)
>       allocate( xif1(nsub1), stat=stats)
>       call umalloc(nsub1,1,'xif1',memuse,stats)
>       allocate( xif2(nsub1), stat=stats)
>       call umalloc(nsub1,1,'xif2',memuse,stats)
>       allocate( xmi(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'xmi',memuse,stats)
>       allocate( xmie(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'xmie',memuse,stats)
>       allocate( xorig(maxbl), stat=stats)
>       call umalloc(maxbl,0,' xorig',memuse,stats)
>       allocate( xte(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'xte',memuse,stats)
>       allocate( y1(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'y1',memuse,stats)
>       allocate( y2(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'y2',memuse,stats)
>       allocate( ymi(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'ymi',memuse,stats)
>       allocate( ymie(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'ymie',memuse,stats)
>       allocate( yorig(maxbl), stat=stats)
>       call umalloc(maxbl,0,'yorig',memuse,stats)
>       allocate( yte(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'yte',memuse,stats)
>       allocate( z1(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'z1',memuse,stats)
>       allocate( z2(mpatch+2,mpatch+2), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2),0,'z2',memuse,stats)
>       allocate( zmi(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'zmi',memuse,stats)
>       allocate( zmie(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'zmie',memuse,stats)
>       allocate( zorig(maxbl), stat=stats)
>       call umalloc(maxbl,0,'zorig',memuse,stats)
>       allocate( zte(mpatch+2,mpatch+2,nsub1), stat=stats)
>       call umalloc((mpatch+2)*(mpatch+2)*nsub1,0,'zte',memuse,stats)
283c374
<  9990 format(2(2h *),43h   VERSION 6.0 :  Computational Fluids Lab,,
---
>  9990 format(2(2h *),43h   VERSION 6.X :  Computational Fluids Lab,,
286c377
<      .3x,2(2h *),/2(2h *),18x,33hRelease Date:    August  8, 2001.,
---
>      .3x,2(2h *),/2(2h *),18x,33hRelease Date:       MMM DD, YYYY.,
692,778c783,869
<          call ufree(ip_work)
<          call ufree(ip_lw)
<          call ufree(ip_lw2)
<          call ufree(ip_mglevg)
<          call ufree(ip_nemgl)
<          call ufree(ip_levelg)
<          call ufree(ip_jtest)
<          call ufree(ip_ktest)
<          call ufree(ip_itest)
<          call ufree(ip_nblg)
<          call ufree(ip_iemg)
<          call ufree(ip_igridg)
<          call ufree(ip_jdimg)
<          call ufree(ip_kdimg)
<          call ufree(ip_idimg)
<          call ufree(ip_nblcg)
<          call ufree(ip_ncgg)
<          call ufree(ip_xorig)
<          call ufree(ip_yorig)
<          call ufree(ip_zorig)
<          call ufree(ip_windex)
<          call ufree(ip_iindex)
<          call ufree(ip_llimit)
<          call ufree(ip_iitmax)
<          call ufree(ip_mmcxie)
<          call ufree(ip_mmceta)
<          call ufree(ip_ncheck)
<          call ufree(ip_iifit)
<          call ufree(ip_nblkpt)
<          call ufree(ip_iic0)
<          call ufree(ip_iiorph)
<          call ufree(ip_iitoss)
<          call ufree(ip_ifiner)
<          call ufree(ip_dx)
<          call ufree(ip_dy)
<          call ufree(ip_dz)
<          call ufree(ip_dthetx)
<          call ufree(ip_dthety)
<          call ufree(ip_dthetz)
<          call ufree(ip_lout)
<          call ufree(ip_xif1)
<          call ufree(ip_xif2)
<          call ufree(ip_etf1)
<          call ufree(ip_etf2)
<          call ufree(ip_jjmax1)
<          call ufree(ip_kkmax1)
<          call ufree(ip_iiint1)
<          call ufree(ip_iiint2)
<          call ufree(ip_jimage)
<          call ufree(ip_kimage)
<          call ufree(ip_jte)
<          call ufree(ip_kte)
<          call ufree(ip_jmm)
<          call ufree(ip_kmm)
<          call ufree(ip_nblk1)
<          call ufree(ip_nblk2)
<          call ufree(ip_xte)
<          call ufree(ip_yte)
<          call ufree(ip_zte)
<          call ufree(ip_xmi)
<          call ufree(ip_ymi)
<          call ufree(ip_zmi)
<          call ufree(ip_xmie)
<          call ufree(ip_ymie)
<          call ufree(ip_zmie)
<          call ufree(ip_sxie)
<          call ufree(ip_seta)
<          call ufree(ip_sxie2)
<          call ufree(ip_seta2)
<          call ufree(ip_xie2s)
<          call ufree(ip_eta2s)
<          call ufree(ip_temp)
<          call ufree(ip_x2)
<          call ufree(ip_y2)
<          call ufree(ip_z2)
<          call ufree(ip_x1)
<          call ufree(ip_y1)
<          call ufree(ip_z1)
<          call ufree(ip_factjlo)
<          call ufree(ip_factjhi)
<          call ufree(ip_factklo)
<          call ufree(ip_factkhi)
<          call ufree(ip_ifrom)
<          call ufree(ip_isav_pat)
<          call ufree(ip_isav_pat_b)
<          call ufree(ip_mblk2nd)
<          call ufree(ip_ireq_ar)
---
>          deallocate(work)
>          deallocate(lw)
>          deallocate(lw2)
>          deallocate(mglevg)
>          deallocate(nemgl)
>          deallocate(levelg)
>          deallocate(jtest)
>          deallocate(ktest)
>          deallocate(itest)
>          deallocate(nblg)
>          deallocate(iemg)
>          deallocate(igridg)
>          deallocate(jdimg)
>          deallocate(kdimg)
>          deallocate(idimg)
>          deallocate(nblcg)
>          deallocate(ncgg)
>          deallocate(xorig)
>          deallocate(yorig)
>          deallocate(zorig)
>          deallocate(windex)
>          deallocate(iindex)
>          deallocate(llimit)
>          deallocate(iitmax)
>          deallocate(mmcxie)
>          deallocate(mmceta)
>          deallocate(ncheck)
>          deallocate(iifit)
>          deallocate(nblkpt)
>          deallocate(iic0)
>          deallocate(iiorph)
>          deallocate(iitoss)
>          deallocate(ifiner)
>          deallocate(dx)
>          deallocate(dy)
>          deallocate(dz)
>          deallocate(dthetx)
>          deallocate(dthety)
>          deallocate(dthetz)
>          deallocate(lout)
>          deallocate(xif1)
>          deallocate(xif2)
>          deallocate(etf1)
>          deallocate(etf2)
>          deallocate(jjmax1)
>          deallocate(kkmax1)
>          deallocate(iiint1)
>          deallocate(iiint2)
>          deallocate(jimage)
>          deallocate(kimage)
>          deallocate(jte)
>          deallocate(kte)
>          deallocate(jmm)
>          deallocate(kmm)
>          deallocate(nblk1)
>          deallocate(nblk2)
>          deallocate(xte)
>          deallocate(yte)
>          deallocate(zte)
>          deallocate(xmi)
>          deallocate(ymi)
>          deallocate(zmi)
>          deallocate(xmie)
>          deallocate(ymie)
>          deallocate(zmie)
>          deallocate(sxie)
>          deallocate(seta)
>          deallocate(sxie2)
>          deallocate(seta2)
>          deallocate(xie2s)
>          deallocate(eta2s)
>          deallocate(temp)
>          deallocate(x2)
>          deallocate(y2)
>          deallocate(z2)
>          deallocate(x1)
>          deallocate(y1)
>          deallocate(z1)
>          deallocate(factjlo)
>          deallocate(factjhi)
>          deallocate(factklo)
>          deallocate(factkhi)
>          deallocate(ifrom)
>          deallocate(isav_pat)
>          deallocate(isav_pat_b)
>          deallocate(mblk2nd)
>          deallocate(ireq_ar)
Index: source/ronnie/sizer.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/ronnie/sizer.F,v
retrieving revision 1.3
retrieving revision 1.6
diff -r1.3 -r1.6
5c5
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
38c38,39
<       integer xif1(nsub10),xif2(nsub10),etf1(nsub10),etf2(nsub10)
---
>       integer etf1,etf2,xif1,xif2
>       integer stats
40,44c41,42
<       dimension levelg(maxbl0)
<       dimension mglevg(maxbl0),nemgl(maxbl0)
<       dimension igridg(maxbl0),
<      .          jdimg(maxbl0),kdimg(maxbl0),idimg(maxbl0),nblcg(maxbl0)
<       dimension ncgg(maxgr0),nblg(maxgr0),iemg(maxgr0)
---
>       dimension ie_pat(5)
>       dimension is_pat(5)
46,58c44,84
<       dimension jjmax1(nsub10),kkmax1(nsub10)
<       dimension iiint1(nsub10),iiint2(nsub10)
<       dimension iindex(intmax0,6*nsub10+9),
<      .          llimit(intmax0),iitmax(intmax0),mmcxie(intmax0),
<      .          mmceta(intmax0),ncheck(maxbl0),iifit(intmax0),
<      .          iic0(intmax0),iiorph(intmax0),
<      .          iitoss(intmax0),ifiner(intmax0),ifrom(nsub10)
<       dimension dx(intmax0,nsub10),dy(intmax0,nsub10),
<      .          dz(intmax0,nsub10),dthetx(intmax0,nsub10),
<      .          dthety(intmax0,nsub10),dthetz(intmax0,nsub10)
<       dimension isav_pat(intmax0,17),isav_pat_b(intmax0,nsub10,6)
<       dimension mblk2nd(maxbl0)
<       dimension is_pat(5),ie_pat(5)
---
> 
>       allocatable :: dthetx(:,:)
>       allocatable :: dthety(:,:)
>       allocatable :: dthetz(:,:)
>       allocatable :: dx(:,:)
>       allocatable :: dy(:,:)
>       allocatable :: dz(:,:)
>       allocatable :: etf1(:)
>       allocatable :: etf2(:)
>       allocatable :: idimg(:)
>       allocatable :: iemg(:)
>       allocatable :: ifiner(:)
>       allocatable :: ifrom(:)
>       allocatable :: igridg(:)
>       allocatable :: iic0(:)
>       allocatable :: iifit(:)
>       allocatable :: iiint1(:)
>       allocatable :: iiint2(:)
>       allocatable :: iindex(:,:)
>       allocatable :: iiorph(:)
>       allocatable :: iitmax(:)
>       allocatable :: iitoss(:)
>       allocatable :: isav_pat(:,:)
>       allocatable :: isav_pat_b(:,:,:)
>       allocatable :: jdimg(:)
>       allocatable :: jjmax1(:)
>       allocatable :: kdimg(:)
>       allocatable :: kkmax1(:)
>       allocatable :: levelg(:)
>       allocatable :: llimit(:)
>       allocatable :: mblk2nd(:)
>       allocatable :: mglevg(:)
>       allocatable :: mmceta(:)
>       allocatable :: mmcxie(:)
>       allocatable :: nblcg(:)
>       allocatable :: nblg(:)
>       allocatable :: ncgg(:)
>       allocatable :: ncheck(:)
>       allocatable :: nemgl(:)
>       allocatable :: xif1(:)
>       allocatable :: xif2(:)
76,92d101
<       pointer (ip_levelg,levelg),(ip_mglevg,mglevg),(ip_nemgl,nemgl)
<       pointer (ip_ncgg,ncgg),(ip_nblg,nblg),(ip_iemg,iemg)
<       pointer (ip_igridg,igridg),(ip_nblcg,nblcg)
<       pointer (ip_iindex,iindex),(ip_iitoss,iitoss),(ip_ifiner,ifiner),
<      .        (ip_llimit,llimit),(ip_iitmax,iitmax),(ip_mmcxie,mmcxie),
<      .        (ip_mmceta,mmceta),(ip_ncheck,ncheck),(ip_iifit,iifit),
<      .        (ip_iic0,iic0),(ip_iiorph,iiorph)
<       pointer (ip_dx,dx),(ip_dy,dy),(ip_dz,dz),
<      .        (ip_dthetx,dthetx),(ip_dthety,dthety),
<      .        (ip_dthetz,dthetz)
<       pointer (ip_xif1,xif1),(ip_xif2,xif2),
<      .        (ip_etf1,etf1),(ip_etf2,etf2),(ip_iiint1,iiint1),
<      .        (ip_iiint2,iiint2),(ip_jjmax1,jjmax1),
<      .        (ip_kkmax1,kkmax1),(ip_ifrom,ifrom)
<       pointer (ip_isav_pat,isav_pat),(ip_isav_pat_b,isav_pat_b)
<       pointer (ip_idimg,idimg),(ip_jdimg,jdimg),(ip_kdimg,kdimg)
<       pointer (ip_mblk2nd,mblk2nd)
96d104
<       icall  = 0
99,138c107,186
<       call umalloc(ip_mglevg,maxbl0,1,icall,memuse)
<       call umalloc(ip_nemgl,maxbl0,1,icall,memuse)
<       call umalloc(ip_levelg,maxbl0,1,icall,memuse)
<       call umalloc(ip_nblg,maxgr0,1,icall,memuse)
<       call umalloc(ip_iemg,maxgr0,1,icall,memuse)
<       call umalloc(ip_igridg,maxbl0,1,icall,memuse)
<       call umalloc(ip_jdimg,maxbl0,1,icall,memuse)
<       call umalloc(ip_kdimg,maxbl0,1,icall,memuse)
<       call umalloc(ip_idimg,maxbl0,1,icall,memuse)
<       call umalloc(ip_nblcg,maxbl0,1,icall,memuse)
<       call umalloc(ip_ncgg,maxgr0,1,icall,memuse)
<       call umalloc(ip_iindex,intmax0*(6*nsub10+9),1,icall,memuse)
<       call umalloc(ip_llimit,intmax0,1,icall,memuse)
<       call umalloc(ip_iitmax,intmax0,1,icall,memuse)
<       call umalloc(ip_mmcxie,intmax0,1,icall,memuse)
<       call umalloc(ip_mmceta,intmax0,1,icall,memuse)
<       call umalloc(ip_ncheck,maxbl0,1,icall,memuse)
<       call umalloc(ip_iifit,intmax0,1,icall,memuse)
<       call umalloc(ip_iic0,intmax0,1,icall,memuse)
<       call umalloc(ip_iiorph,intmax0,1,icall,memuse)
<       call umalloc(ip_iitoss,intmax0,1,icall,memuse)
<       call umalloc(ip_ifiner,intmax0,1,icall,memuse)
<       call umalloc(ip_dx,intmax0*nsub10,0,icall,memuse)
<       call umalloc(ip_dy,intmax0*nsub10,0,icall,memuse)
<       call umalloc(ip_dz,intmax0*nsub10,0,icall,memuse)
<       call umalloc(ip_dthetx,intmax0*nsub10,0,icall,memuse)
<       call umalloc(ip_dthety,intmax0*nsub10,0,icall,memuse)
<       call umalloc(ip_dthetz,intmax0*nsub10,0,icall,memuse)
<       call umalloc(ip_xif1,nsub10,1,icall,memuse)
<       call umalloc(ip_xif2,nsub10,1,icall,memuse)
<       call umalloc(ip_etf1,nsub10,1,icall,memuse)
<       call umalloc(ip_etf2,nsub10,1,icall,memuse)
<       call umalloc(ip_jjmax1,nsub10,1,icall,memuse)
<       call umalloc(ip_kkmax1,nsub10,1,icall,memuse)
<       call umalloc(ip_iiint1,nsub10,1,icall,memuse)
<       call umalloc(ip_iiint2,nsub10,1,icall,memuse)
<       call umalloc(ip_ifrom,nsub10,0,icall,memuse)
<       call umalloc(ip_isav_pat,17*intmax0,1,icall,memuse)
<       call umalloc(ip_isav_pat_b,6*intmax0*nsub10,1,icall,memuse)
<       call umalloc(ip_mblk2nd,maxbl0,1,icall,memuse)
---
>       allocate( dthetx(intmax0,nsub10), stat=stats )
>       call umalloc(intmax0*nsub10,0,'dthetx',memuse,stats)
>       allocate( dthety(intmax0,nsub10), stat=stats )
>       call umalloc(intmax0*nsub10,0,'dthety',memuse,stats)
>       allocate( dthetz(intmax0,nsub10), stat=stats )
>       call umalloc(intmax0*nsub10,0,'dthetz',memuse,stats)
>       allocate( dx(intmax0,nsub10), stat=stats )
>       call umalloc(intmax0*nsub10,0,'dx',memuse,stats)
>       allocate( dy(intmax0,nsub10), stat=stats )
>       call umalloc(intmax0*nsub10,0,'dy',memuse,stats)
>       allocate( dz(intmax0,nsub10), stat=stats )
>       call umalloc(intmax0*nsub10,0,'dz',memuse,stats)
>       allocate( etf1(nsub10), stat=stats )
>       call umalloc(nsub10,1,'etf1',memuse,stats)
>       allocate( etf2(nsub10), stat=stats )
>       call umalloc(nsub10,1,'etf2',memuse,stats)
>       allocate( idimg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'idimg',memuse,stats)
>       allocate( iemg(maxgr0), stat=stats )
>       call umalloc(maxgr0,1,'iemg',memuse,stats)
>       allocate( ifiner(intmax0), stat=stats )
>       call umalloc(intmax0,1,'ifiner',memuse,stats)
>       allocate( ifrom(nsub10), stat=stats )
>       call umalloc(nsub10,0,'ifrom',memuse,stats)
>       allocate( igridg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'igridg',memuse,stats)
>       allocate( iic0(intmax0), stat=stats )
>       call umalloc(intmax0,1,'iic0',memuse,stats)
>       allocate( iifit(intmax0), stat=stats )
>       call umalloc(intmax0,1,'iifit',memuse,stats)
>       allocate( iiint1(nsub10), stat=stats )
>       call umalloc(nsub10,1,'iiint1',memuse,stats)
>       allocate( iiint2(nsub10), stat=stats )
>       call umalloc(nsub10,1,'iiint2',memuse,stats)
>       allocate( iindex(intmax0,6*nsub10+9), stat=stats )
>       call umalloc(intmax0*(6*nsub10+9),1,'iindex',memuse,stats)
>       allocate( iiorph(intmax0), stat=stats )
>       call umalloc(intmax0,1,'iiorph',memuse,stats)
>       allocate( iitmax(intmax0), stat=stats )
>       call umalloc(intmax0,1,'iitmax',memuse,stats)
>       allocate( iitoss(intmax0), stat=stats )
>       call umalloc(intmax0,1,'iitoss',memuse,stats)
>       allocate( isav_pat(intmax0,17), stat=stats )
>       call umalloc(intmax0*17,1,'isav_pat',memuse,stats)
>       allocate( isav_pat_b(intmax0,nsub10,6), stat=stats )
>       call umalloc(intmax0*nsub10*6,1,'isav_pat_b',memuse,stats)
>       allocate( jdimg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'jdimg',memuse,stats)
>       allocate( jjmax1(nsub10), stat=stats )
>       call umalloc(nsub10,1,'jjmax1',memuse,stats)
>       allocate( kdimg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'kdimg',memuse,stats)
>       allocate( kkmax1(nsub10), stat=stats )
>       call umalloc(nsub10,1,'kkmax1',memuse,stats)
>       allocate( levelg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'levelg',memuse,stats)
>       allocate( llimit(intmax0), stat=stats )
>       call umalloc(intmax0,1,'llimit',memuse,stats)
>       allocate( mblk2nd(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'mblk2nd',memuse,stats)
>       allocate( mglevg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'mglevg',memuse,stats)
>       allocate( mmceta(intmax0), stat=stats )
>       call umalloc(intmax0,1,'mmceta',memuse,stats)
>       allocate( mmcxie(intmax0), stat=stats )
>       call umalloc(intmax0,1,'mmcxie',memuse,stats)
>       allocate( nblcg(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nblcg',memuse,stats)
>       allocate( nblg(maxgr0), stat=stats )
>       call umalloc(maxgr0,1,'nblg',memuse,stats)
>       allocate( ncgg(maxgr0), stat=stats )
>       call umalloc(maxgr0,1,'ncgg',memuse,stats)
>       allocate( ncheck(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'ncheck',memuse,stats)
>       allocate( nemgl(maxbl0), stat=stats )
>       call umalloc(maxbl0,1,'nemgl',memuse,stats)
>       allocate( xif1(nsub10), stat=stats )
>       call umalloc(nsub10,1,'xif1',memuse,stats)
>       allocate( xif2(nsub10), stat=stats )
>       call umalloc(nsub10,1,'xif2',memuse,stats)
213c261
<  9990 format(2(2h *),43h   VERSION 6.0 :  Computational Fluids Lab,,
---
>  9990 format(2(2h *),43h   VERSION 6.X :  Computational Fluids Lab,,
216c264
<      .3x,2(2h *),/2(2h *),18x,33hRelease Date:    August  8, 2001.,
---
>      .3x,2(2h *),/2(2h *),18x,33hRelease Date:       MMM DD, YYYY.,
484,523c532,571
<          call ufree(ip_mglevg)
<          call ufree(ip_nemgl)
<          call ufree(ip_levelg)
<          call ufree(ip_nblg)
<          call ufree(ip_iemg)
<          call ufree(ip_igridg)
<          call ufree(ip_jdimg)
<          call ufree(ip_kdimg)
<          call ufree(ip_idimg)
<          call ufree(ip_nblcg)
<          call ufree(ip_ncgg)
<          call ufree(ip_iindex)
<          call ufree(ip_llimit)
<          call ufree(ip_iitmax)
<          call ufree(ip_mmcxie)
<          call ufree(ip_mmceta)
<          call ufree(ip_ncheck)
<          call ufree(ip_iifit)
<          call ufree(ip_iic0)
<          call ufree(ip_iiorph)
<          call ufree(ip_iitoss)
<          call ufree(ip_ifiner)
<          call ufree(ip_dx)
<          call ufree(ip_dy)
<          call ufree(ip_dz)
<          call ufree(ip_dthetx)
<          call ufree(ip_dthety)
<          call ufree(ip_dthetz)
<          call ufree(ip_xif1)
<          call ufree(ip_xif2)
<          call ufree(ip_etf1)
<          call ufree(ip_etf2)
<          call ufree(ip_jjmax1)
<          call ufree(ip_kkmax1)
<          call ufree(ip_iiint1)
<          call ufree(ip_iiint2)
<          call ufree(ip_ifrom)
<          call ufree(ip_isav_pat)
<          call ufree(ip_isav_pat_b)
<          call ufree(ip_mblk2nd)
---
>          deallocate(mglevg)
>          deallocate(nemgl)
>          deallocate(levelg)
>          deallocate(nblg)
>          deallocate(iemg)
>          deallocate(igridg)
>          deallocate(jdimg)
>          deallocate(kdimg)
>          deallocate(idimg)
>          deallocate(nblcg)
>          deallocate(ncgg)
>          deallocate(iindex)
>          deallocate(llimit)
>          deallocate(iitmax)
>          deallocate(mmcxie)
>          deallocate(mmceta)
>          deallocate(ncheck)
>          deallocate(iifit)
>          deallocate(iic0)
>          deallocate(iiorph)
>          deallocate(iitoss)
>          deallocate(ifiner)
>          deallocate(dx)
>          deallocate(dy)
>          deallocate(dz)
>          deallocate(dthetx)
>          deallocate(dthety)
>          deallocate(dthetz)
>          deallocate(xif1)
>          deallocate(xif2)
>          deallocate(etf1)
>          deallocate(etf2)
>          deallocate(jjmax1)
>          deallocate(kkmax1)
>          deallocate(iiint1)
>          deallocate(iiint2)
>          deallocate(ifrom)
>          deallocate(isav_pat)
>          deallocate(isav_pat_b)
>          deallocate(mblk2nd)
Index: source/ronnie/termn8.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/ronnie/termn8.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
105c105
< #   ifdef IBM then
---
> #   ifdef IBM
Index: source/ronnie/usrint.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/ronnie/usrint.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
31c31
< #   ifdef IBM then
---
> #   ifdef IBM
Index: source/splitter/cfl3d_to_tlns3d.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/splitter/cfl3d_to_tlns3d.F,v
retrieving revision 1.3
retrieving revision 1.4
diff -r1.3 -r1.4
17c17
<      .                           ioflag,nou,bou,nbuf,ibufdim)
---
>      .                           ioflag,nou,bou,nbuf,ibufdim,cflout)
19c19
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
90c90
<       character*80 gridindum,sdgridindum
---
>       character*80 gridindum,sdgridindum,cflout
440c440
<       if (isum .gt.0) then
---
>       if (isum .gt.0 .and. cflout .ne. 'null') then
465c465
<       if (isum .gt.0) then
---
>       if (isum .gt.0 .and. cflout .ne. 'null') then
545c545
<       if (ibct(ibloc,iface,iseg).eq.2005) then
---
>       if (ibct(ibloc,iface,iseg).eq.2005 .and. cflout .ne. 'null') then
548c548,549
<       else if (ibct(ibloc,iface,iseg).eq.2006) then
---
>       else if (ibct(ibloc,iface,iseg).eq.2006 
>      .         .and. cflout .ne. 'null') then
580c581
<       if (ibct(ibloc,iface,iseg).eq.2005) then
---
>       if (ibct(ibloc,iface,iseg).eq.2005 .and. cflout .ne. 'null') then
583c584,585
<       else if (ibct(ibloc,iface,iseg).eq.2006) then
---
>       else if (ibct(ibloc,iface,iseg).eq.2006
>      .         .and. cflout .ne. 'null') then
615c617
<       if (ibct(ibloc,iface,iseg).eq.2005) then
---
>       if (ibct(ibloc,iface,iseg).eq.2005 .and. cflout .ne. 'null') then
618c620,621
<       else if (ibct(ibloc,iface,iseg).eq.2006) then
---
>       else if (ibct(ibloc,iface,iseg).eq.2006
>      .         .and. cflout .ne. 'null') then
650c653
<       if (ibct(ibloc,iface,iseg).eq.2005) then
---
>       if (ibct(ibloc,iface,iseg).eq.2005 .and. cflout .ne. 'null') then
653c656,657
<       else if (ibct(ibloc,iface,iseg).eq.2006) then
---
>       else if (ibct(ibloc,iface,iseg).eq.2006
>      .         .and. cflout .ne. 'null') then
685c689
<       if (ibct(ibloc,iface,iseg).eq.2005) then
---
>       if (ibct(ibloc,iface,iseg).eq.2005 .and. cflout .ne. 'null') then
688c692,693
<       else if (ibct(ibloc,iface,iseg).eq.2006) then
---
>       else if (ibct(ibloc,iface,iseg).eq.2006
>      .         .and. cflout .ne. 'null') then
720c725
<       if (ibct(ibloc,iface,iseg).eq.2005) then
---
>       if (ibct(ibloc,iface,iseg).eq.2005 .and. cflout .ne. 'null') then
723c728,729
<       else if (ibct(ibloc,iface,iseg).eq.2006) then
---
>       else if (ibct(ibloc,iface,iseg).eq.2006
>      .         .and. cflout .ne. 'null') then
Index: source/splitter/mapout.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/splitter/mapout.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
95c95
<  2000 format(//,' new block  old block  i0  i1  j0  j1  k0  k1')
---
>  2000 format(/,/,' new block  old block  i0  i1  j0  j1  k0  k1')
Index: source/splitter/sizer.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/splitter/sizer.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
5c5
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
28a29,30
>       integer stats
> c
30,38c32,41
<       dimension isplits(mbloc0),jsplits(mbloc0),ksplits(mbloc0)
<       dimension idimg(mbloc0),jdimg(mbloc0),kdimg(mbloc0)
<       dimension ndirin0(msplt0*mbloc0),isblocin(msplt0*mbloc0),
<      .          ndirin(msplt0*mbloc0)
< c
<       pointer (ip_isplits,isplits),(ip_jsplits,jsplits),
<      .        (ip_ksplits,ksplits),(ip_idimg,idimg),(ip_jdimg,jdimg),
<      .        (ip_kdimg,kdimg),(ip_ndirin0,ndirin0),
<      .        (ip_isblocin,isblocin),(ip_ndirin,ndirin)
---
> c
>       allocatable :: idimg(:)
>       allocatable :: isblocin(:)
>       allocatable :: isplits(:)
>       allocatable :: jdimg(:)
>       allocatable :: jsplits(:)
>       allocatable :: kdimg(:)
>       allocatable :: ksplits(:)
>       allocatable :: ndirin(:)
>       allocatable :: ndirin0(:)
42d44
<       icall  = 0
44,52c46,63
<       call umalloc(ip_isplits,mbloc0,1,icall,memuse)
<       call umalloc(ip_jsplits,mbloc0,1,icall,memuse)
<       call umalloc(ip_ksplits,mbloc0,1,icall,memuse)
<       call umalloc(ip_idimg,mbloc0,1,icall,memuse)
<       call umalloc(ip_jdimg,mbloc0,1,icall,memuse)
<       call umalloc(ip_kdimg,mbloc0,1,icall,memuse)
<       call umalloc(ip_ndirin0,msplt0*mbloc0,1,icall,memuse)
<       call umalloc(ip_ndirin,msplt0*mbloc0,1,icall,memuse)
<       call umalloc(ip_isblocin,msplt0*mbloc0,1,icall,memuse)
---
>       allocate( idimg(mbloc0), stat=stats )
>       call umalloc(mbloc0,1,'idimg',memuse,stats)
>       allocate( isblocin(msplt0*mbloc0), stat=stats )
>       call umalloc(msplt0*mbloc0,1,'isblocin',memuse,stats)
>       allocate( isplits(mbloc0), stat=stats )
>       call umalloc(mbloc0,1,'isplits',memuse,stats)
>       allocate( jdimg(mbloc0), stat=stats )
>       call umalloc(mbloc0,1,'jdimg',memuse,stats)
>       allocate( jsplits(mbloc0), stat=stats )
>       call umalloc(mbloc0,1,'jsplits',memuse,stats)
>       allocate( kdimg(mbloc0), stat=stats )
>       call umalloc(mbloc0,1,'kdimg',memuse,stats)
>       allocate( ksplits(mbloc0), stat=stats )
>       call umalloc(mbloc0,1,'ksplits',memuse,stats)
>       allocate( ndirin(msplt0*mbloc0), stat=stats )
>       call umalloc(msplt0*mbloc0,1,'ndirin',memuse,stats)
>       allocate( ndirin0(msplt0*mbloc0), stat=stats )
>       call umalloc(msplt0*mbloc0,1,'ndirin0',memuse,stats)
237,245c248,256
<       call ufree(ip_isplits)
<       call ufree(ip_jsplits)
<       call ufree(ip_ksplits)
<       call ufree(ip_idimg)
<       call ufree(ip_jdimg)
<       call ufree(ip_kdimg)
<       call ufree(ip_ndirin0)
<       call ufree(ip_ndirin)
<       call ufree(ip_isblocin)
---
>       deallocate(isplits)
>       deallocate(jsplits)
>       deallocate(ksplits)
>       deallocate(idimg)
>       deallocate(jdimg)
>       deallocate(kdimg)
>       deallocate(ndirin0)
>       deallocate(ndirin)
>       deallocate(isblocin)
Index: source/splitter/splitter.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/splitter/splitter.F,v
retrieving revision 1.3
retrieving revision 1.7
diff -r1.3 -r1.7
4c4
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
12,15c12,13
<       integer ifrom(intmax,nsub1),xif1(intmax,nsub1),
<      .        xif2(intmax,nsub1),etf1(intmax,nsub1),
<      .        etf2(intmax,nsub1),ito(intmax),xit1(intmax),
<      .        xit2(intmax),ett1(intmax),ett2(intmax),nfb(intmax)
---
>       integer xif1,xif2,xit1,xit2,etf1,etf2,ett1,ett2
>       integer stats
18,143c16,189
<       dimension iadvance(mbloc),iforce(mbloc)
<       dimension nblkk(2,mxbli),limblk(2,6,mxbli),
<      .          isva(2,2,mxbli),nblon(mxbli)
<       dimension ncgg(mbloc),nblg(mbloc),iemg(mbloc),
<      .          inewgg(mbloc)
<       dimension bcvali(mbloc,maxseg,7,2),
<      .          bcvalj(mbloc,maxseg,7,2),bcvalk(mbloc,maxseg,7,2),
<      .          nbci0(mbloc),nbcidim(mbloc),nbcj0(mbloc),nbcjdim(mbloc),
<      .          nbck0(mbloc),nbckdim(mbloc),ibcinfo(mbloc,maxseg,7,2),
<      .          jbcinfo(mbloc,maxseg,7,2),kbcinfo(mbloc,maxseg,7,2)
<       dimension llimit(intmax),iitmax(intmax),mmcxie(intmax),
<      .          mmceta(intmax),iifit(intmax),iic0(intmax),
<      .          iiorph(intmax)
<       dimension iredundant(mbloc,msegn),iconcat(intmax)
<       dimension cq(msegn,mbloc),cporous(msegn,mbloc),
<      .          cpchamber(msegn,mbloc),cradiation(msegn,mbloc)
<       dimension isblocin(msplt*mbloc),ndirin(msplt*mbloc),
<      .          isin(msplt*mbloc),ndirin0(msplt),isin0(msplt)
<       dimension  nbs(mbloc)
<       dimension imin(mbloc),jmin(mbloc),kmin(mbloc)
<       dimension imax(mbloc),jmax(mbloc),kmax(mbloc)
<       dimension iskp(mbloc),jskp(mbloc),kskp(mbloc)
<       dimension ilo(mbloc),jlo(mbloc),klo(mbloc)
<       dimension iln(mbloc),jln(mbloc),kln(mbloc)
<       dimension ibeg(mbloc),npts(mbloc)
<       dimension x(npmax),y(npmax),z(npmax)
<       dimension ilosd(mbloc),jlosd(mbloc),klosd(mbloc)
<       dimension il(mbloc),jl(mbloc),kl(mbloc),rkap0g(mbloc,3),
<      .          levelg(mbloc),igridg(mbloc),iflimg(mbloc,3),
<      .          ifdsg(mbloc,3),iviscg(mbloc,3),jdimg(mbloc),
<      .          kdimg(mbloc),idimg(mbloc),idiagg(mbloc,3),
<      .          nblcg(mbloc),idegg(mbloc,3),jsg(mbloc),ksg(mbloc),
<      .          isg(mbloc),jeg(mbloc),keg(mbloc),ieg(mbloc),
<      .          mit(5,mbloc),ilamlog(mbloc),ilamhig(mbloc),
<      .          jlamlog(mbloc),jlamhig(mbloc),klamlog(mbloc),
<      .          klamhig(mbloc)
<       dimension imap(msegt,msegn,mbloc),idbloc(mtot),
<      .          ivisb(msegt,mbloc),itrb(7,mbloc),
<      .          val(mtot),xdum(msegt,mtot),
<      .          iold(4,mtot),nxtseg(mtot),intrfc(mtot),
<      .          ipatch(mtot),ni(mbloc),nj(mbloc),nk(mbloc)
<       dimension xdmold(msegt),idmold(msegt)
<       dimension nseg1(mbloc)
<       dimension nsilo(mbloc),nsihi(mbloc),nsjlo(mbloc),
<      .          nsjhi(mbloc),nsklo(mbloc),nskhi(mbloc)
<       dimension nb1(mbloc,6,msegn),ne1(mbloc,6,msegn),
<      .          nb2(mbloc,6,msegn),ne2(mbloc,6,msegn),
<      .          ibct(mbloc,6,msegn)
<       dimension bcval(mbloc,6,msegn,7)
<       dimension iovrlp(mbloc),ifoflg(mbloc,6,msegn),
<      .          ndat(mbloc,6,msegn),xmap(msegt,msegn,mbloc)
<       dimension twotref(msegn,mbloc)
<       dimension itrb1(mbloc),itrb2(mbloc),jtrb1(mbloc),jtrb2(mbloc),
<      .          ktrb1(mbloc),ktrb2(mbloc),iturbb(mbloc)
<       dimension ibif1(mxbli),ibif2(mxbli)
<       dimension nbi1(mxbli),nei1(mxbli),nbj1(mxbli),
<      .          nej1(mxbli),nbk1(mxbli),nek1(mxbli),
<      .          nbi2(mxbli),nei2(mxbli),nbj2(mxbli),
<      .          nej2(mxbli),nbk2(mxbli),nek2(mxbli),
<      .          nd11(mxbli),nd21(mxbli),nd12(mxbli),
<      .          nd22(mxbli)
<       dimension ifsor(mbloc),nb1s(mbloc),ne1s(mbloc),
<      .          nb2s(mbloc),ne2s(mbloc)
<       dimension nsubbl(mbloc),idobl(mbloc),nseg(mbloc),idno(mbloc),
<      .          ijk(6,mbloc),idseg(mbloc),idnext(mbloc)
< c
<       pointer (ip_ifrom,ifrom),(ip_xif1,xif1),(ip_xif2,xif2),
<      .        (ip_etf1,etf1),(ip_etf2,etf2),(ip_ito,ito),(ip_xit1,xit1),
<      .        (ip_xit2,xit2),(ip_ett1,ett1),(ip_ett2,ett2),(ip_nfb,nfb)
<       pointer (ip_iadvance,iadvance),(ip_iforce,iforce),
<      .        (ip_nblkk,nblkk),(ip_limblk,limblk),(ip_isva,isva),
<      .        (ip_nblon,nblon),(ip_ncgg,ncgg),(ip_nblg,nblg),
<      .        (ip_iemg,iemg),(ip_inewgg,inewgg),(ip_bcvali,bcvali),
<      .        (ip_bcvalj,bcvalj),(ip_bcvalk,bcvalk),(ip_nbci0,nbci0),
<      .        (ip_nbcidim,nbcidim),(ip_nbcj0,nbcj0),
<      .        (ip_nbcjdim,nbcjdim),(ip_nbck0,nbck0),
<      .        (ip_nbckdim,nbckdim),(ip_ibcinfo,ibcinfo),
<      .        (ip_jbcinfo,jbcinfo),(ip_kbcinfo,kbcinfo)
<       pointer (ip_llimit,llimit),(ip_iitmax,iitmax),(ip_mmcxie,mmcxie),
<      .        (ip_mmceta,mmceta),(ip_iifit,iifit),(ip_iic0,iic0),
<      .        (ip_iiorph,iiorph),(ip_iredundant,iredundant),
<      .        (ip_iconcat,iconcat),(ip_cq,cq),(ip_cporous,cporous),
<      .        (ip_cpchamber,cpchamber),(ip_cradiation,cradiation),
<      .        (ip_isblocin,isblocin),(ip_ndirin,ndirin),(ip_isin,isin),
<      .        (ip_ndirin0,ndirin0),(ip_isin0,isin0)
<       pointer (ip_nbs,nbs),(ip_imin,imin),(ip_jmin,jmin),(ip_kmin,kmin),
<      .        (ip_imax,imax),(ip_jmax,jmax),(ip_kmax,kmax),
<      .        (ip_iskp,iskp),(ip_jskp,jskp),(ip_kskp,kskp),(ip_ilo,ilo),
<      .        (ip_jlo,jlo),(ip_klo,klo),(ip_iln,iln),(ip_jln,jln),
<      .        (ip_kln,kln),(ip_ibeg,ibeg),(ip_npts,npts),(ip_x,x),
<      .        (ip_y,y),(ip_z,z),(ip_ilosd,ilosd),(ip_jlosd,jlosd),
<      .        (ip_klosd,klosd) 
<       pointer (ip_il,il),(ip_jl,jl),(ip_kl,kl),(ip_rkap0g,rkap0g),
<      .        (ip_levelg,levelg),(ip_igridg,igridg),(ip_iflimg,iflimg),
<      .        (ip_ifdsg,ifdsg),(ip_iviscg,iviscg),(ip_jdimg,jdimg),
<      .        (ip_kdimg,kdimg),(ip_idimg,idimg),(ip_idiagg,idiagg),
<      .        (ip_nblcg,nblcg),(ip_idegg,idegg),(ip_jsg,jsg),
<      .        (ip_ksg,ksg),(ip_isg,isg),(ip_jeg,jeg),(ip_keg,keg),
<      .        (ip_ieg,ieg),(ip_mit,mit),(ip_ilamlog,ilamlog),
<      .        (ip_ilamhig,ilamhig),(ip_jlamlog,jlamlog),
<      .        (ip_jlamhig,jlamhig),(ip_klamlog,klamlog),
<      .        (ip_klamhig,klamhig)
<       pointer (ip_imap,imap),(ip_idbloc,idbloc),(ip_ivisb,ivisb),
<      .        (ip_itrb,itrb),(ip_val,val),(ip_xdum,xdum),
<      .        (ip_iold,iold),(ip_nxtseg,nxtseg),(ip_intrfc,intrfc),
<      .        (ip_ipatch,ipatch),(ip_ni,ni),(ip_nj,nj),(ip_nk,nk),
<      .        (ip_xdmold,xdmold),(ip_idmold,idmold),(ip_nseg1,nseg1)
< 
<       pointer (ip_nsilo,nsilo),(ip_nsihi,nsihi),(ip_nsjlo,nsjlo),
<      .        (ip_nsjhi,nsjhi),(ip_nsklo,nsklo),(ip_nskhi,nskhi),
<      .        (ip_nb1,nb1),(ip_ne1,ne1),(ip_nb2,nb2),(ip_ne2,ne2),
<      .        (ip_ibct,ibct),(ip_bcval,bcval),(ip_iovrlp,iovrlp),
<      .        (ip_ifoflg,ifoflg),(ip_ndat,ndat),(ip_xmap,xmap)
<       pointer (ip_twotref,twotref),(ip_itrb1,itrb1),(ip_itrb2,itrb2),
<      .        (ip_jtrb1,jtrb1),(ip_jtrb2,jtrb2),(ip_ktrb1,ktrb1),
<      .        (ip_ktrb2,ktrb2),(ip_iturbb,iturbb),(ip_ibif1,ibif1),
<      .        (ip_ibif2,ibif2),(ip_nbi1,nbi1),(ip_nei1,nei1),
<      .        (ip_nbj1,nbj1),(ip_nej1,nej1),(ip_nbk1,nbk1),
<      .        (ip_nek1,nek1),(ip_nbi2,nbi2),(ip_nei2,nei2),
<      .        (ip_nbj2,nbj2),(ip_nej2,nej2),(ip_nbk2,nbk2),
<      .        (ip_nek2,nek2),(ip_nd11,nd11),(ip_nd21,nd21),
<      .        (ip_nd12,nd12),(ip_nd22,nd22),(ip_ifsor,ifsor),
<      .        (ip_nb1s,nb1s),(ip_ne1s,ne1s),(ip_nb2s,nb2s),
<      .        (ip_ne2s,ne2s),(ip_nsubbl,nsubbl),(ip_idobl,idobl),
<      .        (ip_nseg,nseg),(ip_idno,idno),(ip_ijk,ijk),
<      .        (ip_idseg,idseg),(ip_idnext,idnext)
---
> c
>       allocatable :: bcval(:,:,:,:)
>       allocatable :: bcvali(:,:,:,:)
>       allocatable :: bcvalj(:,:,:,:)
>       allocatable :: bcvalk(:,:,:,:)
>       allocatable :: cpchamber(:,:)
>       allocatable :: cporous(:,:)
>       allocatable :: cq(:,:)
>       allocatable :: cradiation(:,:)
>       allocatable :: etf1(:,:)
>       allocatable :: etf2(:,:)
>       allocatable :: ett1(:)
>       allocatable :: ett2(:)
>       allocatable :: iadvance(:)
>       allocatable :: ibcinfo(:,:,:,:)
>       allocatable :: ibct(:,:,:)
>       allocatable :: ibeg(:)
>       allocatable :: ibif1(:)
>       allocatable :: ibif2(:)
>       allocatable :: iconcat(:)
>       allocatable :: idbloc(:)
>       allocatable :: idegg(:,:)
>       allocatable :: idiagg(:,:)
>       allocatable :: idimg(:)
>       allocatable :: idmold(:)
>       allocatable :: idnext(:)
>       allocatable :: idno(:)
>       allocatable :: idobl(:)
>       allocatable :: idseg(:)
>       allocatable :: ieg(:)
>       allocatable :: iemg(:)
>       allocatable :: ifdsg(:,:)
>       allocatable :: iflimg(:,:)
>       allocatable :: ifoflg(:,:,:)
>       allocatable :: iforce(:)
>       allocatable :: ifrom(:,:)
>       allocatable :: ifsor(:)
>       allocatable :: igridg(:)
>       allocatable :: iic0(:)
>       allocatable :: iifit(:)
>       allocatable :: iiorph(:)
>       allocatable :: iitmax(:)
>       allocatable :: ijk(:,:)
>       allocatable :: il(:)
>       allocatable :: ilamhig(:)
>       allocatable :: ilamlog(:)
>       allocatable :: iln(:)
>       allocatable :: ilo(:)
>       allocatable :: ilosd(:)
>       allocatable :: imap(:,:,:)
>       allocatable :: imax(:)
>       allocatable :: imin(:)
>       allocatable :: inewgg(:)
>       allocatable :: intrfc(:)
>       allocatable :: iold(:,:)
>       allocatable :: iovrlp(:)
>       allocatable :: ipatch(:)
>       allocatable :: iredundant(:,:)
>       allocatable :: isblocin(:)
>       allocatable :: isg(:)
>       allocatable :: isin(:)
>       allocatable :: isin0(:)
>       allocatable :: iskp(:)
>       allocatable :: isva(:,:,:)
>       allocatable :: ito(:)
>       allocatable :: itrb(:,:)
>       allocatable :: itrb1(:)
>       allocatable :: itrb2(:)
>       allocatable :: iturbb(:)
>       allocatable :: ivisb(:,:)
>       allocatable :: iviscg(:,:)
>       allocatable :: jbcinfo(:,:,:,:)
>       allocatable :: jdimg(:)
>       allocatable :: jeg(:)
>       allocatable :: jl(:)
>       allocatable :: jlamhig(:)
>       allocatable :: jlamlog(:)
>       allocatable :: jln(:)
>       allocatable :: jlo(:)
>       allocatable :: jlosd(:)
>       allocatable :: jmax(:)
>       allocatable :: jmin(:)
>       allocatable :: jsg(:)
>       allocatable :: jskp(:)
>       allocatable :: jtrb1(:)
>       allocatable :: jtrb2(:)
>       allocatable :: kbcinfo(:,:,:,:)
>       allocatable :: kdimg(:)
>       allocatable :: keg(:)
>       allocatable :: kl(:)
>       allocatable :: klamhig(:)
>       allocatable :: klamlog(:)
>       allocatable :: kln(:)
>       allocatable :: klo(:)
>       allocatable :: klosd(:)
>       allocatable :: kmax(:)
>       allocatable :: kmin(:)
>       allocatable :: ksg(:)
>       allocatable :: kskp(:)
>       allocatable :: ktrb1(:)
>       allocatable :: ktrb2(:)
>       allocatable :: levelg(:)
>       allocatable :: limblk(:,:,:)
>       allocatable :: llimit(:)
>       allocatable :: mit(:,:)
>       allocatable :: mmceta(:)
>       allocatable :: mmcxie(:)
>       allocatable :: nb1(:,:,:)
>       allocatable :: nb1s(:)
>       allocatable :: nb2(:,:,:)
>       allocatable :: nb2s(:)
>       allocatable :: nbci0(:)
>       allocatable :: nbcidim(:)
>       allocatable :: nbcj0(:)
>       allocatable :: nbcjdim(:)
>       allocatable :: nbck0(:)
>       allocatable :: nbckdim(:)
>       allocatable :: nbi1(:)
>       allocatable :: nbi2(:)
>       allocatable :: nbj1(:)
>       allocatable :: nbj2(:)
>       allocatable :: nbk1(:)
>       allocatable :: nbk2(:)
>       allocatable :: nblcg(:)
>       allocatable :: nblg(:)
>       allocatable :: nblkk(:,:)
>       allocatable :: nblon(:)
>       allocatable :: nbs(:)
>       allocatable :: ncgg(:)
>       allocatable :: nd11(:)
>       allocatable :: nd12(:)
>       allocatable :: nd21(:)
>       allocatable :: nd22(:)
>       allocatable :: ndat(:,:,:)
>       allocatable :: ndirin(:)
>       allocatable :: ndirin0(:)
>       allocatable :: ne1(:,:,:)
>       allocatable :: ne1s(:)
>       allocatable :: ne2(:,:,:)
>       allocatable :: ne2s(:)
>       allocatable :: nei1(:)
>       allocatable :: nei2(:)
>       allocatable :: nej1(:)
>       allocatable :: nej2(:)
>       allocatable :: nek1(:)
>       allocatable :: nek2(:)
>       allocatable :: nfb(:)
>       allocatable :: ni(:)
>       allocatable :: nj(:)
>       allocatable :: nk(:)
>       allocatable :: npts(:)
>       allocatable :: nseg(:)
>       allocatable :: nseg1(:)
>       allocatable :: nsihi(:)
>       allocatable :: nsilo(:)
>       allocatable :: nsjhi(:)
>       allocatable :: nsjlo(:)
>       allocatable :: nskhi(:)
>       allocatable :: nsklo(:)
>       allocatable :: nsubbl(:)
>       allocatable :: nxtseg(:)
>       allocatable :: rkap0g(:,:)
>       allocatable :: twotref(:,:)
>       allocatable :: val(:)
>       allocatable :: x(:)
>       allocatable :: xdmold(:)
>       allocatable :: xdum(:,:)
>       allocatable :: xif1(:,:)
>       allocatable :: xif2(:,:)
>       allocatable :: xit1(:)
>       allocatable :: xit2(:)
>       allocatable :: xmap(:,:,:)
>       allocatable :: y(:)
>       allocatable :: z(:)
166d211
<       icall  = 0
169,342c214,559
<       call umalloc(ip_ifrom,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_xif1,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_xif2,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_etf1,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_etf2,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_ito,intmax,1,icall,memuse)
<       call umalloc(ip_xit1,intmax,1,icall,memuse)
<       call umalloc(ip_xit2,intmax,1,icall,memuse)
<       call umalloc(ip_ett1,intmax,1,icall,memuse)
<       call umalloc(ip_ett2,intmax,1,icall,memuse)
<       call umalloc(ip_nfb,intmax,1,icall,memuse)
<       call umalloc(ip_iadvance,mbloc,1,icall,memuse)
<       call umalloc(ip_iforce,mbloc,1,icall,memuse)
<       call umalloc(ip_nblkk,2*mxbli,1,icall,memuse)
<       call umalloc(ip_limblk,12*mxbli,1,icall,memuse)
<       call umalloc(ip_isva,4*mxbli,1,icall,memuse)
<       call umalloc(ip_nblon,mxbli,1,icall,memuse)
<       call umalloc(ip_ncgg,mbloc,1,icall,memuse)
<       call umalloc(ip_nblg,mbloc,1,icall,memuse)
<       call umalloc(ip_iemg,mbloc,1,icall,memuse)
<       call umalloc(ip_inewgg,mbloc,1,icall,memuse)
<       call umalloc(ip_bcvali,14*mbloc*maxseg,0,icall,memuse)
<       call umalloc(ip_bcvalj,14*mbloc*maxseg,0,icall,memuse) 
<       call umalloc(ip_bcvalk,14*mbloc*maxseg,0,icall,memuse)
<       call umalloc(ip_nbci0,mbloc,1,icall,memuse)
<       call umalloc(ip_nbcidim,mbloc,1,icall,memuse)
<       call umalloc(ip_nbcj0,mbloc,1,icall,memuse)
<       call umalloc(ip_nbcjdim,mbloc,1,icall,memuse)
<       call umalloc(ip_nbck0,mbloc,1,icall,memuse)
<       call umalloc(ip_nbckdim,mbloc,1,icall,memuse)
<       call umalloc(ip_ibcinfo,14*mbloc*maxseg,1,icall,memuse)
<       call umalloc(ip_jbcinfo,14*mbloc*maxseg,1,icall,memuse)
<       call umalloc(ip_kbcinfo,14*mbloc*maxseg,1,icall,memuse)
<       call umalloc(ip_llimit,intmax,1,icall,memuse)
<       call umalloc(ip_iitmax,intmax,1,icall,memuse)
<       call umalloc(ip_mmcxie,intmax,1,icall,memuse)
<       call umalloc(ip_mmceta,intmax,1,icall,memuse)
<       call umalloc(ip_iifit,intmax,1,icall,memuse)
<       call umalloc(ip_iic0,intmax,1,icall,memuse)
<       call umalloc(ip_iiorph,intmax,1,icall,memuse)
<       call umalloc(ip_iredundant,mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_iconcat,intmax,1,icall,memuse)
<       call umalloc(ip_cq,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_cporous,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_cpchamber,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_cradiation,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_isblocin,msplt*mbloc,1,icall,memuse)
<       call umalloc(ip_ndirin,msplt*mbloc,1,icall,memuse)
<       call umalloc(ip_isin,msplt*mbloc,1,icall,memuse)
<       call umalloc(ip_ndirin0,msplt,1,icall,memuse)
<       call umalloc(ip_isin0,msplt,1,icall,memuse)
<       call umalloc(ip_nbs,mbloc,1,icall,memuse)
<       call umalloc(ip_imin,mbloc,1,icall,memuse)
<       call umalloc(ip_jmin,mbloc,1,icall,memuse)
<       call umalloc(ip_kmin,mbloc,1,icall,memuse)
<       call umalloc(ip_imax,mbloc,1,icall,memuse)
<       call umalloc(ip_jmax,mbloc,1,icall,memuse)
<       call umalloc(ip_kmax,mbloc,1,icall,memuse)
<       call umalloc(ip_iskp,mbloc,1,icall,memuse)
<       call umalloc(ip_jskp,mbloc,1,icall,memuse)
<       call umalloc(ip_kskp,mbloc,1,icall,memuse)
<       call umalloc(ip_ilo,mbloc,1,icall,memuse)
<       call umalloc(ip_jlo,mbloc,1,icall,memuse)
<       call umalloc(ip_klo,mbloc,1,icall,memuse)
<       call umalloc(ip_iln,mbloc,1,icall,memuse)
<       call umalloc(ip_jln,mbloc,1,icall,memuse)
<       call umalloc(ip_kln,mbloc,1,icall,memuse)
<       call umalloc(ip_ibeg,mbloc,1,icall,memuse)
<       call umalloc(ip_npts,mbloc,1,icall,memuse)
<       call umalloc(ip_x,npmax,0,icall,memuse)
<       call umalloc(ip_y,npmax,0,icall,memuse)
<       call umalloc(ip_z,npmax,0,icall,memuse)
<       call umalloc(ip_ilosd,mbloc,1,icall,memuse)
<       call umalloc(ip_jlosd,mbloc,1,icall,memuse)
<       call umalloc(ip_klosd,mbloc,1,icall,memuse)
<       call umalloc(ip_il,mbloc,1,icall,memuse)
<       call umalloc(ip_jl,mbloc,1,icall,memuse)
<       call umalloc(ip_kl,mbloc,1,icall,memuse)
<       call umalloc(ip_rkap0g,3*mbloc,0,icall,memuse)
<       call umalloc(ip_levelg,mbloc,1,icall,memuse)
<       call umalloc(ip_igridg,mbloc,1,icall,memuse)
<       call umalloc(ip_iflimg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_ifdsg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_iviscg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_jdimg,mbloc,1,icall,memuse)
<       call umalloc(ip_kdimg,mbloc,1,icall,memuse)
<       call umalloc(ip_idimg,mbloc,1,icall,memuse)
<       call umalloc(ip_idiagg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_nblcg,mbloc,1,icall,memuse)
<       call umalloc(ip_idegg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_jsg,mbloc,1,icall,memuse)
<       call umalloc(ip_ksg,mbloc,1,icall,memuse)
<       call umalloc(ip_isg,mbloc,1,icall,memuse)
<       call umalloc(ip_jeg,mbloc,1,icall,memuse)
<       call umalloc(ip_keg,mbloc,1,icall,memuse)
<       call umalloc(ip_ieg,mbloc,1,icall,memuse)
<       call umalloc(ip_mit,5*mbloc,1,icall,memuse)
<       call umalloc(ip_ilamlog,mbloc,1,icall,memuse)
<       call umalloc(ip_ilamhig,mbloc,1,icall,memuse)
<       call umalloc(ip_jlamlog,mbloc,1,icall,memuse)
<       call umalloc(ip_jlamhig,mbloc,1,icall,memuse)
<       call umalloc(ip_klamlog,mbloc,1,icall,memuse)
<       call umalloc(ip_klamhig,mbloc,1,icall,memuse)
<       call umalloc(ip_imap,msegt*msegn*mbloc,1,icall,memuse)
<       call umalloc(ip_idbloc,mtot,1,icall,memuse)
<       call umalloc(ip_ivisb,msegt*mtot,1,icall,memuse)
<       call umalloc(ip_itrb,7*mbloc,1,icall,memuse)
<       call umalloc(ip_val,mtot,0,icall,memuse)
<       call umalloc(ip_xdum,msegt*mtot,0,icall,memuse)
<       call umalloc(ip_iold,4*mtot,1,icall,memuse)
<       call umalloc(ip_nxtseg,mtot,1,icall,memuse)
<       call umalloc(ip_intrfc,mtot,1,icall,memuse)
<       call umalloc(ip_ipatch,mtot,1,icall,memuse)
<       call umalloc(ip_ni,mbloc,1,icall,memuse)
<       call umalloc(ip_nj,mbloc,1,icall,memuse)
<       call umalloc(ip_nk,mbloc,1,icall,memuse)
<       call umalloc(ip_xdmold,msegt,0,icall,memuse)
<       call umalloc(ip_idmold,msegt,1,icall,memuse)
<       call umalloc(ip_nseg1,mbloc,1,icall,memuse)
<       call umalloc(ip_nsilo,mbloc,1,icall,memuse)
<       call umalloc(ip_nsihi,mbloc,1,icall,memuse)
<       call umalloc(ip_nsjlo,mbloc,1,icall,memuse)
<       call umalloc(ip_nsjhi,mbloc,1,icall,memuse)
<       call umalloc(ip_nsklo,mbloc,1,icall,memuse)
<       call umalloc(ip_nskhi,mbloc,1,icall,memuse)
<       call umalloc(ip_nb1,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_ne1,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_nb2,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_ne2,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_ibct,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_bcval,42*mbloc*msegn,0,icall,memuse)
<       call umalloc(ip_iovrlp,mbloc,1,icall,memuse)
<       call umalloc(ip_ifoflg,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_ndat,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_xmap,msegt*msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_twotref,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_itrb1,mbloc,1,icall,memuse)
<       call umalloc(ip_itrb2,mbloc,1,icall,memuse)
<       call umalloc(ip_jtrb1,mbloc,1,icall,memuse)
<       call umalloc(ip_jtrb2,mbloc,1,icall,memuse)
<       call umalloc(ip_ktrb1,mbloc,1,icall,memuse)
<       call umalloc(ip_ktrb2,mbloc,1,icall,memuse)
<       call umalloc(ip_iturbb,mbloc,1,icall,memuse)
<       call umalloc(ip_ibif1,mxbli,1,icall,memuse)
<       call umalloc(ip_ibif2,mxbli,1,icall,memuse)
<       call umalloc(ip_nbi1,mxbli,1,icall,memuse)
<       call umalloc(ip_nei1,mxbli,1,icall,memuse)
<       call umalloc(ip_nbj1,mxbli,1,icall,memuse)
<       call umalloc(ip_nej1,mxbli,1,icall,memuse)
<       call umalloc(ip_nbk1,mxbli,1,icall,memuse)
<       call umalloc(ip_nek1,mxbli,1,icall,memuse)
<       call umalloc(ip_nbi2,mxbli,1,icall,memuse)
<       call umalloc(ip_nei2,mxbli,1,icall,memuse)
<       call umalloc(ip_nbj2,mxbli,1,icall,memuse)
<       call umalloc(ip_nej2,mxbli,1,icall,memuse)
<       call umalloc(ip_nbk2,mxbli,1,icall,memuse)
<       call umalloc(ip_nek2,mxbli,1,icall,memuse)
<       call umalloc(ip_nd11,mxbli,1,icall,memuse)
<       call umalloc(ip_nd21,mxbli,1,icall,memuse)
<       call umalloc(ip_nd12,mxbli,1,icall,memuse)
<       call umalloc(ip_nd22,mxbli,1,icall,memuse)
<       call umalloc(ip_ifsor,mbloc,1,icall,memuse)
<       call umalloc(ip_nb1s,mbloc,1,icall,memuse)
<       call umalloc(ip_ne1s,mbloc,1,icall,memuse)
<       call umalloc(ip_nb2s,mbloc,1,icall,memuse)
<       call umalloc(ip_ne2s,mbloc,1,icall,memuse)
<       call umalloc(ip_nsubbl,mbloc,1,icall,memuse)
<       call umalloc(ip_idobl,mbloc,1,icall,memuse)
<       call umalloc(ip_nseg,mbloc,1,icall,memuse)
<       call umalloc(ip_idno,mbloc,1,icall,memuse)
<       call umalloc(ip_ijk,6*mbloc,1,icall,memuse)
<       call umalloc(ip_idseg,mbloc,1,icall,memuse)
<       call umalloc(ip_idnext,mbloc,1,icall,memuse)
< c
---
>       allocate( bcval(mbloc,6,msegn,7), stat=stats )
>       call umalloc(mbloc*6*msegn*7,0,'bcval',memuse,stats)
>       allocate( bcvali(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,0,'bcvali',memuse,stats)
>       allocate( bcvalj(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,0,'bcvalj',memuse,stats)
>       allocate( bcvalk(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,0,'bcvalk',memuse,stats)
>       allocate( cpchamber(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'cpchamber',memuse,stats)
>       allocate( cporous(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'cporous',memuse,stats)
>       allocate( cq(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'cq',memuse,stats)
>       allocate( cradiation(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'cradiation',memuse,stats)
>       allocate( etf1(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'etf1',memuse,stats)
>       allocate( etf2(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'etf2',memuse,stats)
>       allocate( ett1(intmax), stat=stats )
>       call umalloc(intmax,1,'ett1',memuse,stats)
>       allocate( ett2(intmax), stat=stats )
>       call umalloc(intmax,1,'ett2',memuse,stats)
>       allocate( iadvance(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iadvance',memuse,stats)
>       allocate( ibcinfo(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,1,'ibcinfo',memuse,stats)
>       allocate( ibct(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ibct',memuse,stats)
>       allocate( ibeg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ibeg',memuse,stats)
>       allocate( ibif1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'ibif1',memuse,stats)
>       allocate( ibif2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'ibif2',memuse,stats)
>       allocate( iconcat(intmax), stat=stats )
>       call umalloc(intmax,1,'iconcat',memuse,stats)
>       allocate( idbloc(mtot), stat=stats )
>       call umalloc(mtot,1,'idbloc',memuse,stats)
>       allocate( idegg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'idegg',memuse,stats)
>       allocate( idiagg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'idiagg',memuse,stats)
>       allocate( idimg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'idimg',memuse,stats)
>       allocate( idmold(msegt), stat=stats )
>       call umalloc(msegt,1,'idmold',memuse,stats)
>       allocate( idnext(mbloc), stat=stats )
>       call umalloc(mbloc,1,'idnext',memuse,stats)
>       allocate( idno(mbloc), stat=stats )
>       call umalloc(mbloc,1,'dno',memuse,stats)
>       allocate( idobl(mbloc), stat=stats )
>       call umalloc(mbloc,1,'idobl',memuse,stats)
>       allocate( idseg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'idseg',memuse,stats)
>       allocate( ieg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ieg',memuse,stats)
>       allocate( iemg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iemg',memuse,stats)
>       allocate( ifdsg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'ifdsg',memuse,stats)
>       allocate( iflimg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'iflimg',memuse,stats)
>       allocate( ifoflg(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ifoflg',memuse,stats)
>       allocate( iforce(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iforce',memuse,stats)
>       allocate( ifrom(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'ifrom',memuse,stats)
>       allocate( ifsor(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ifsor',memuse,stats)
>       allocate( igridg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'igridg',memuse,stats)
>       allocate( iic0(intmax), stat=stats )
>       call umalloc(intmax,1,'iic0',memuse,stats)
>       allocate( iifit(intmax), stat=stats )
>       call umalloc(intmax,1,'iifit',memuse,stats)
>       allocate( iiorph(intmax), stat=stats )
>       call umalloc(intmax,1,'iiorph',memuse,stats)
>       allocate( iitmax(intmax), stat=stats )
>       call umalloc(intmax,1,'iitmax',memuse,stats)
>       allocate( ijk(6,mbloc), stat=stats )
>       call umalloc(6*mbloc,1,'ijk',memuse,stats)
>       allocate( il(mbloc), stat=stats )
>       call umalloc(mbloc,1,'il',memuse,stats)
>       allocate( ilamhig(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ilamhig',memuse,stats)
>       allocate( ilamlog(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ilamlog',memuse,stats)
>       allocate( iln(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iln',memuse,stats)
>       allocate( ilo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ilo',memuse,stats)
>       allocate( ilosd(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ilosd',memuse,stats)
>       allocate( imap(msegt,msegn,mbloc), stat=stats )
>       call umalloc(msegt*msegn*mbloc,1,'imap',memuse,stats)
>       allocate( imax(mbloc), stat=stats )
>       call umalloc(mbloc,1,'imax',memuse,stats)
>       allocate( imin(mbloc), stat=stats )
>       call umalloc(mbloc,1,'imin',memuse,stats)
>       allocate( inewgg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'inewgg',memuse,stats)
>       allocate( intrfc(mtot), stat=stats )
>       call umalloc(mtot,1,'intrfc',memuse,stats)
>       allocate( iold(4,mtot), stat=stats )
>       call umalloc(4*mtot,1,'iold',memuse,stats)
>       allocate( iovrlp(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iovrlp',memuse,stats)
>       allocate( ipatch(mtot), stat=stats )
>       call umalloc(mtot,1,'ipatch',memuse,stats)
>       allocate( iredundant(mbloc,msegn), stat=stats )
>       call umalloc(mbloc*msegn,1,'iredundant',memuse,stats)
>       allocate( isblocin(msplt*mbloc), stat=stats )
>       call umalloc(msplt*mbloc,1,'isblocin',memuse,stats)
>       allocate( isg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'isg',memuse,stats)
>       allocate( isin(msplt*mbloc), stat=stats )
>       call umalloc(msplt*mbloc,1,'isin',memuse,stats)
>       allocate( isin0(msplt), stat=stats )
>       call umalloc(msplt,1,'isin0',memuse,stats)
>       allocate( iskp(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iskp',memuse,stats)
>       allocate( isva(2,2,mxbli), stat=stats )
>       call umalloc(2*2*mxbli,1,'isva',memuse,stats)
>       allocate( ito(intmax), stat=stats )
>       call umalloc(intmax,1,'ito',memuse,stats)
>       allocate( itrb(7,mbloc), stat=stats )
>       call umalloc(7*mbloc,1,'itrb',memuse,stats)
>       allocate( itrb1(mbloc), stat=stats )
>       call umalloc(mbloc,1,'itrb1',memuse,stats)
>       allocate( itrb2(mbloc), stat=stats )
>       call umalloc(mbloc,1,'itrb2',memuse,stats)
>       allocate( iturbb(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iturbb',memuse,stats)
>       allocate( ivisb(msegt,mbloc), stat=stats )
>       call umalloc(msegt*mbloc,1,'ivisb',memuse,stats)
>       allocate( iviscg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'iviscg',memuse,stats)
>       allocate( jbcinfo(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,1,'jbcinfo',memuse,stats)
>       allocate( jdimg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jdimg',memuse,stats)
>       allocate( jeg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jeg',memuse,stats)
>       allocate( jl(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jl',memuse,stats)
>       allocate( jlamhig(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jlamhig',memuse,stats)
>       allocate( jlamlog(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jlamlog',memuse,stats)
>       allocate( jln(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jln',memuse,stats)
>       allocate( jlo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jlo',memuse,stats)
>       allocate( jlosd(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jlosd',memuse,stats)
>       allocate( jmax(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jmax',memuse,stats)
>       allocate( jmin(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jmin',memuse,stats)
>       allocate( jsg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jsg',memuse,stats)
>       allocate( jskp(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jskp',memuse,stats)
>       allocate( jtrb1(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jtrb1',memuse,stats)
>       allocate( jtrb2(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jtrb2',memuse,stats)
>       allocate( kbcinfo(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,1,'kbcinfo',memuse,stats)
>       allocate( kdimg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kdimg',memuse,stats)
>       allocate( keg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'keg',memuse,stats)
>       allocate( kl(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kl',memuse,stats)
>       allocate( klamhig(mbloc), stat=stats )
>       call umalloc(mbloc,1,'klamhig',memuse,stats)
>       allocate( klamlog(mbloc), stat=stats )
>       call umalloc(mbloc,1,'klamlog',memuse,stats)
>       allocate( kln(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kln',memuse,stats)
>       allocate( klo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'klo',memuse,stats)
>       allocate( klosd(mbloc), stat=stats )
>       call umalloc(mbloc,1,'klosd',memuse,stats)
>       allocate( kmax(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kmax',memuse,stats)
>       allocate( kmin(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kmin',memuse,stats)
>       allocate( ksg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ksg',memuse,stats)
>       allocate( kskp(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kskp',memuse,stats)
>       allocate( ktrb1(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ktrb1',memuse,stats)
>       allocate( ktrb2(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ktrb2',memuse,stats)
>       allocate( levelg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'levelg',memuse,stats)
>       allocate( limblk(2,6,mxbli), stat=stats )
>       call umalloc(2*6*mxbli,1,'limblk',memuse,stats)
>       allocate( llimit(intmax), stat=stats )
>       call umalloc(intmax,1,'llimit',memuse,stats)
>       allocate( mit(5,mbloc), stat=stats )
>       call umalloc(5*mbloc,1,'mit',memuse,stats)
>       allocate( mmceta(intmax), stat=stats )
>       call umalloc(intmax,1,'mmceta',memuse,stats)
>       allocate( mmcxie(intmax), stat=stats )
>       call umalloc(intmax,1,'mmcxie',memuse,stats)
>       allocate( nb1(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'nb1',memuse,stats)
>       allocate( nb1s(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nb1s',memuse,stats)
>       allocate( nb2(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'nb2',memuse,stats)
>       allocate( nb2s(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nb2s',memuse,stats)
>       allocate( nbci0(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbci0',memuse,stats)
>       allocate( nbcidim(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbcidim',memuse,stats)
>       allocate( nbcj0(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbcj0',memuse,stats)
>       allocate( nbcjdim(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbcjdim',memuse,stats)
>       allocate( nbck0(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbck0',memuse,stats)
>       allocate( nbckdim(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbckdim',memuse,stats)
>       allocate( nbi1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbi1',memuse,stats)
>       allocate( nbi2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbi2',memuse,stats)
>       allocate( nbj1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbj1',memuse,stats)
>       allocate( nbj2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbj2',memuse,stats)
>       allocate( nbk1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbk1',memuse,stats)
>       allocate( nbk2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbk2',memuse,stats)
>       allocate( nblcg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nblcg',memuse,stats)
>       allocate( nblg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nblg',memuse,stats)
>       allocate( nblkk(2,mxbli), stat=stats )
>       call umalloc(2*mxbli,1,'nblkk',memuse,stats)
>       allocate( nblon(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nblon',memuse,stats)
>       allocate( nbs(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbs',memuse,stats)
>       allocate( ncgg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ncgg',memuse,stats)
>       allocate( nd11(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nd11',memuse,stats)
>       allocate( nd12(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nd12',memuse,stats)
>       allocate( nd21(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nd21',memuse,stats)
>       allocate( nd22(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nd22',memuse,stats)
>       allocate( ndat(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ndat',memuse,stats)
>       allocate( ndirin(msplt*mbloc), stat=stats )
>       call umalloc(msplt*mbloc,1,'ndirin',memuse,stats)
>       allocate( ndirin0(msplt), stat=stats )
>       call umalloc(msplt,1,'ndirin0',memuse,stats)
>       allocate( ne1(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ne1',memuse,stats)
>       allocate( ne1s(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ne1s',memuse,stats)
>       allocate( ne2(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ne2',memuse,stats)
>       allocate( ne2s(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ne2s',memuse,stats)
>       allocate( nei1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nei1',memuse,stats)
>       allocate( nei2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nei2',memuse,stats)
>       allocate( nej1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nej1',memuse,stats)
>       allocate( nej2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nej2',memuse,stats)
>       allocate( nek1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nek1',memuse,stats)
>       allocate( nek2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nek2',memuse,stats)
>       allocate( nfb(intmax), stat=stats )
>       call umalloc(intmax,1,'nfb',memuse,stats)
>       allocate( ni(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ni',memuse,stats)
>       allocate( nj(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nj',memuse,stats)
>       allocate( nk(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nk',memuse,stats)
>       allocate( npts(mbloc), stat=stats )
>       call umalloc(mbloc,1,'npts',memuse,stats)
>       allocate( nseg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nseg',memuse,stats)
>       allocate( nseg1(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nseg1',memuse,stats)
>       allocate( nsihi(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsihi',memuse,stats)
>       allocate( nsilo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsilo',memuse,stats)
>       allocate( nsjhi(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsjhi',memuse,stats)
>       allocate( nsjlo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsjlo',memuse,stats)
>       allocate( nskhi(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nskhi',memuse,stats)
>       allocate( nsklo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsklo',memuse,stats)
>       allocate( nsubbl(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsubbl',memuse,stats)
>       allocate( nxtseg(mtot), stat=stats )
>       call umalloc(mtot,1,'nxtseg',memuse,stats)
>       allocate( rkap0g(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,0,'rkap0g',memuse,stats)
>       allocate( twotref(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'twotref',memuse,stats)
>       allocate( val(mtot), stat=stats )
>       call umalloc(mtot,0,'val',memuse,stats)
>       allocate( x(npmax), stat=stats )
>       call umalloc(npmax,0,'x',memuse,stats)
>       allocate( xdmold(msegt), stat=stats )
>       call umalloc(msegt,0,'xdmold',memuse,stats)
>       allocate( xdum(msegt,mtot), stat=stats )
>       call umalloc(msegt*mtot,0,'xdum',memuse,stats)
>       allocate( xif1(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'xif1',memuse,stats)
>       allocate( xif2(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'xif2',memuse,stats)
>       allocate( xit1(intmax), stat=stats )
>       call umalloc(intmax,1,'xit1',memuse,stats)
>       allocate( xit2(intmax), stat=stats )
>       call umalloc(intmax,1,'xit2',memuse,stats)
>       allocate( xmap(msegt,msegn,mbloc), stat=stats )
>       call umalloc(msegt*msegn*mbloc,0,'xmap',memuse,stats)
>       allocate( y(npmax), stat=stats )
>       call umalloc(npmax,0,'y',memuse,stats)
>       allocate( z(npmax), stat=stats )
>       call umalloc(npmax,0,'z',memuse,stats)
359c576
<  9990 format(2(2h *),43h   VERSION 6.0 :  Computational Fluids Lab,,
---
>  9990 format(2(2h *),43h   VERSION 6.X :  Computational Fluids Lab,,
362c579
<      .3x,2(2h *),/2(2h *),18x,33hRelease Date:    August  8, 2001.,
---
>      .3x,2(2h *),/2(2h *),18x,33hRelease Date:       MMM DD, YYYY.,
538c755
<      .                     nou,bou,nbuf,ibufdim)
---
>      .                     nou,bou,nbuf,ibufdim,cflout)
1024,1196c1241,1413
<       call ufree(ip_ifrom)
<       call ufree(ip_xif1)
<       call ufree(ip_xif2)
<       call ufree(ip_etf1)
<       call ufree(ip_etf2)
<       call ufree(ip_ito)
<       call ufree(ip_xit1)
<       call ufree(ip_xit2)
<       call ufree(ip_ett1)
<       call ufree(ip_ett2)
<       call ufree(ip_nfb)
<       call ufree(ip_iadvance)
<       call ufree(ip_iforce)
<       call ufree(ip_nblkk)
<       call ufree(ip_limblk)
<       call ufree(ip_isva)
<       call ufree(ip_nblon)
<       call ufree(ip_ncgg)
<       call ufree(ip_nblg)
<       call ufree(ip_iemg)
<       call ufree(ip_inewgg)
<       call ufree(ip_bcvali)
<       call ufree(ip_bcvalj)
<       call ufree(ip_bcvalk)
<       call ufree(ip_nbci0)
<       call ufree(ip_nbcidim)
<       call ufree(ip_nbcj0)
<       call ufree(ip_nbcjdim)
<       call ufree(ip_nbck0)
<       call ufree(ip_nbckdim)
<       call ufree(ip_ibcinfo)
<       call ufree(ip_jbcinfo)
<       call ufree(ip_kbcinfo)
<       call ufree(ip_llimit)
<       call ufree(ip_iitmax)
<       call ufree(ip_mmcxie)
<       call ufree(ip_mmceta)
<       call ufree(ip_iifit)
<       call ufree(ip_iic0)
<       call ufree(ip_iiorph)
<       call ufree(ip_iredundant)
<       call ufree(ip_iconcat)
<       call ufree(ip_cq)
<       call ufree(ip_cporous)
<       call ufree(ip_cpchamber)
<       call ufree(ip_cradiation)
<       call ufree(ip_isblocin)
<       call ufree(ip_ndirin)
<       call ufree(ip_isin)
<       call ufree(ip_ndirin0)
<       call ufree(ip_isin0)
<       call ufree(ip_nbs)
<       call ufree(ip_imin)
<       call ufree(ip_jmin)
<       call ufree(ip_kmin)
<       call ufree(ip_imax)
<       call ufree(ip_jmax)
<       call ufree(ip_kmax)
<       call ufree(ip_iskp)
<       call ufree(ip_jskp)
<       call ufree(ip_kskp)
<       call ufree(ip_ilo)
<       call ufree(ip_jlo)
<       call ufree(ip_klo)
<       call ufree(ip_iln)
<       call ufree(ip_jln)
<       call ufree(ip_kln)
<       call ufree(ip_ibeg)
<       call ufree(ip_npts)
<       call ufree(ip_x)
<       call ufree(ip_y)
<       call ufree(ip_z)
<       call ufree(ip_ilosd)
<       call ufree(ip_jlosd)
<       call ufree(ip_klosd)
<       call ufree(ip_il)
<       call ufree(ip_jl)
<       call ufree(ip_kl)
<       call ufree(ip_rkap0g)
<       call ufree(ip_levelg)
<       call ufree(ip_igridg)
<       call ufree(ip_iflimg)
<       call ufree(ip_ifdsg)
<       call ufree(ip_iviscg)
<       call ufree(ip_jdimg)
<       call ufree(ip_kdimg)
<       call ufree(ip_idimg)
<       call ufree(ip_idiagg)
<       call ufree(ip_nblcg)
<       call ufree(ip_idegg)
<       call ufree(ip_jsg)
<       call ufree(ip_ksg)
<       call ufree(ip_isg)
<       call ufree(ip_jeg)
<       call ufree(ip_keg)
<       call ufree(ip_ieg)
<       call ufree(ip_mit)
<       call ufree(ip_ilamlog)
<       call ufree(ip_ilamhig)
<       call ufree(ip_jlamlog)
<       call ufree(ip_jlamhig)
<       call ufree(ip_klamlog)
<       call ufree(ip_klamhig)
<       call ufree(ip_imap)
<       call ufree(ip_idbloc)
<       call ufree(ip_ivisb)
<       call ufree(ip_itrb)
<       call ufree(ip_val)
<       call ufree(ip_xdum)
<       call ufree(ip_iold)
<       call ufree(ip_nxtseg)
<       call ufree(ip_intrfc)
<       call ufree(ip_ipatch)
<       call ufree(ip_ni)
<       call ufree(ip_nj)
<       call ufree(ip_nk)
<       call ufree(ip_xdmold)
<       call ufree(ip_idmold)
<       call ufree(ip_nseg1)
<       call ufree(ip_nsilo)
<       call ufree(ip_nsihi)
<       call ufree(ip_nsjlo)
<       call ufree(ip_nsjhi)
<       call ufree(ip_nsklo)
<       call ufree(ip_nskhi)
<       call ufree(ip_nb1)
<       call ufree(ip_ne1)
<       call ufree(ip_nb2)
<       call ufree(ip_ne2)
<       call ufree(ip_ibct)
<       call ufree(ip_bcval)
<       call ufree(ip_iovrlp)
<       call ufree(ip_ifoflg)
<       call ufree(ip_ndat)
<       call ufree(ip_xmap)
<       call ufree(ip_twotref)
<       call ufree(ip_itrb1)
<       call ufree(ip_itrb2)
<       call ufree(ip_jtrb1)
<       call ufree(ip_jtrb2)
<       call ufree(ip_ktrb1)
<       call ufree(ip_ktrb2)
<       call ufree(ip_iturbb)
<       call ufree(ip_ibif1)
<       call ufree(ip_ibif2)
<       call ufree(ip_nbi1)
<       call ufree(ip_nei1)
<       call ufree(ip_nbj1)
<       call ufree(ip_nej1)
<       call ufree(ip_nbk1)
<       call ufree(ip_nek1)
<       call ufree(ip_nbi2)
<       call ufree(ip_nei2)
<       call ufree(ip_nbj2)
<       call ufree(ip_nej2)
<       call ufree(ip_nbk2)
<       call ufree(ip_nek2)
<       call ufree(ip_nd11)
<       call ufree(ip_nd21)
<       call ufree(ip_nd12)
<       call ufree(ip_nd22)
<       call ufree(ip_ifsor)
<       call ufree(ip_nb1s)
<       call ufree(ip_ne1s)
<       call ufree(ip_nb2s)
<       call ufree(ip_ne2s)
<       call ufree(ip_nsubbl)
<       call ufree(ip_idobl)
<       call ufree(ip_nseg)
<       call ufree(ip_idno)
<       call ufree(ip_ijk)
<       call ufree(ip_idseg)
<       call ufree(ip_idnext)
---
>       deallocate(ifrom)
>       deallocate(xif1)
>       deallocate(xif2)
>       deallocate(etf1)
>       deallocate(etf2)
>       deallocate(ito)
>       deallocate(xit1)
>       deallocate(xit2)
>       deallocate(ett1)
>       deallocate(ett2)
>       deallocate(nfb)
>       deallocate(iadvance)
>       deallocate(iforce)
>       deallocate(nblkk)
>       deallocate(limblk)
>       deallocate(isva)
>       deallocate(nblon)
>       deallocate(ncgg)
>       deallocate(nblg)
>       deallocate(iemg)
>       deallocate(inewgg)
>       deallocate(bcvali)
>       deallocate(bcvalj)
>       deallocate(bcvalk)
>       deallocate(nbci0)
>       deallocate(nbcidim)
>       deallocate(nbcj0)
>       deallocate(nbcjdim)
>       deallocate(nbck0)
>       deallocate(nbckdim)
>       deallocate(ibcinfo)
>       deallocate(jbcinfo)
>       deallocate(kbcinfo)
>       deallocate(llimit)
>       deallocate(iitmax)
>       deallocate(mmcxie)
>       deallocate(mmceta)
>       deallocate(iifit)
>       deallocate(iic0)
>       deallocate(iiorph)
>       deallocate(iredundant)
>       deallocate(iconcat)
>       deallocate(cq)
>       deallocate(cporous)
>       deallocate(cpchamber)
>       deallocate(cradiation)
>       deallocate(isblocin)
>       deallocate(ndirin)
>       deallocate(isin)
>       deallocate(ndirin0)
>       deallocate(isin0)
>       deallocate(nbs)
>       deallocate(imin)
>       deallocate(jmin)
>       deallocate(kmin)
>       deallocate(imax)
>       deallocate(jmax)
>       deallocate(kmax)
>       deallocate(iskp)
>       deallocate(jskp)
>       deallocate(kskp)
>       deallocate(ilo)
>       deallocate(jlo)
>       deallocate(klo)
>       deallocate(iln)
>       deallocate(jln)
>       deallocate(kln)
>       deallocate(ibeg)
>       deallocate(npts)
>       deallocate(x)
>       deallocate(y)
>       deallocate(z)
>       deallocate(ilosd)
>       deallocate(jlosd)
>       deallocate(klosd)
>       deallocate(il)
>       deallocate(jl)
>       deallocate(kl)
>       deallocate(rkap0g)
>       deallocate(levelg)
>       deallocate(igridg)
>       deallocate(iflimg)
>       deallocate(ifdsg)
>       deallocate(iviscg)
>       deallocate(jdimg)
>       deallocate(kdimg)
>       deallocate(idimg)
>       deallocate(idiagg)
>       deallocate(nblcg)
>       deallocate(idegg)
>       deallocate(jsg)
>       deallocate(ksg)
>       deallocate(isg)
>       deallocate(jeg)
>       deallocate(keg)
>       deallocate(ieg)
>       deallocate(mit)
>       deallocate(ilamlog)
>       deallocate(ilamhig)
>       deallocate(jlamlog)
>       deallocate(jlamhig)
>       deallocate(klamlog)
>       deallocate(klamhig)
>       deallocate(imap)
>       deallocate(idbloc)
>       deallocate(ivisb)
>       deallocate(itrb)
>       deallocate(val)
>       deallocate(xdum)
>       deallocate(iold)
>       deallocate(nxtseg)
>       deallocate(intrfc)
>       deallocate(ipatch)
>       deallocate(ni)
>       deallocate(nj)
>       deallocate(nk)
>       deallocate(xdmold)
>       deallocate(idmold)
>       deallocate(nseg1)
>       deallocate(nsilo)
>       deallocate(nsihi)
>       deallocate(nsjlo)
>       deallocate(nsjhi)
>       deallocate(nsklo)
>       deallocate(nskhi)
>       deallocate(nb1)
>       deallocate(ne1)
>       deallocate(nb2)
>       deallocate(ne2)
>       deallocate(ibct)
>       deallocate(bcval)
>       deallocate(iovrlp)
>       deallocate(ifoflg)
>       deallocate(ndat)
>       deallocate(xmap)
>       deallocate(twotref)
>       deallocate(itrb1)
>       deallocate(itrb2)
>       deallocate(jtrb1)
>       deallocate(jtrb2)
>       deallocate(ktrb1)
>       deallocate(ktrb2)
>       deallocate(iturbb)
>       deallocate(ibif1)
>       deallocate(ibif2)
>       deallocate(nbi1)
>       deallocate(nei1)
>       deallocate(nbj1)
>       deallocate(nej1)
>       deallocate(nbk1)
>       deallocate(nek1)
>       deallocate(nbi2)
>       deallocate(nei2)
>       deallocate(nbj2)
>       deallocate(nej2)
>       deallocate(nbk2)
>       deallocate(nek2)
>       deallocate(nd11)
>       deallocate(nd21)
>       deallocate(nd12)
>       deallocate(nd22)
>       deallocate(ifsor)
>       deallocate(nb1s)
>       deallocate(ne1s)
>       deallocate(nb2s)
>       deallocate(ne2s)
>       deallocate(nsubbl)
>       deallocate(idobl)
>       deallocate(nseg)
>       deallocate(idno)
>       deallocate(ijk)
>       deallocate(idseg)
>       deallocate(idnext)
Index: source/splitter/splitter_cmplx.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/splitter/splitter_cmplx.F,v
retrieving revision 1.3
retrieving revision 1.7
diff -r1.3 -r1.7
5c5
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
13,16c13,14
<       integer ifrom(intmax,nsub1),xif1(intmax,nsub1),
<      .        xif2(intmax,nsub1),etf1(intmax,nsub1),
<      .        etf2(intmax,nsub1),ito(intmax),xit1(intmax),
<      .        xit2(intmax),ett1(intmax),ett2(intmax),nfb(intmax)
---
>       integer xif1,xif2,xit1,xit2,etf1,etf2,ett1,ett2
>       integer stats
19,144c17,190
<       dimension iadvance(mbloc),iforce(mbloc)
<       dimension nblkk(2,mxbli),limblk(2,6,mxbli),
<      .          isva(2,2,mxbli),nblon(mxbli)
<       dimension ncgg(mbloc),nblg(mbloc),iemg(mbloc),
<      .          inewgg(mbloc)
<       dimension bcvali(mbloc,maxseg,7,2),
<      .          bcvalj(mbloc,maxseg,7,2),bcvalk(mbloc,maxseg,7,2),
<      .          nbci0(mbloc),nbcidim(mbloc),nbcj0(mbloc),nbcjdim(mbloc),
<      .          nbck0(mbloc),nbckdim(mbloc),ibcinfo(mbloc,maxseg,7,2),
<      .          jbcinfo(mbloc,maxseg,7,2),kbcinfo(mbloc,maxseg,7,2)
<       dimension llimit(intmax),iitmax(intmax),mmcxie(intmax),
<      .          mmceta(intmax),iifit(intmax),iic0(intmax),
<      .          iiorph(intmax)
<       dimension iredundant(mbloc,msegn),iconcat(intmax)
<       dimension cq(msegn,mbloc),cporous(msegn,mbloc),
<      .          cpchamber(msegn,mbloc),cradiation(msegn,mbloc)
<       dimension isblocin(msplt*mbloc),ndirin(msplt*mbloc),
<      .          isin(msplt*mbloc),ndirin0(msplt),isin0(msplt)
<       dimension  nbs(mbloc)
<       dimension imin(mbloc),jmin(mbloc),kmin(mbloc)
<       dimension imax(mbloc),jmax(mbloc),kmax(mbloc)
<       dimension iskp(mbloc),jskp(mbloc),kskp(mbloc)
<       dimension ilo(mbloc),jlo(mbloc),klo(mbloc)
<       dimension iln(mbloc),jln(mbloc),kln(mbloc)
<       dimension ibeg(mbloc),npts(mbloc)
<       complex   x(npmax),y(npmax),z(npmax)
<       dimension ilosd(mbloc),jlosd(mbloc),klosd(mbloc)
<       dimension il(mbloc),jl(mbloc),kl(mbloc),rkap0g(mbloc,3),
<      .          levelg(mbloc),igridg(mbloc),iflimg(mbloc,3),
<      .          ifdsg(mbloc,3),iviscg(mbloc,3),jdimg(mbloc),
<      .          kdimg(mbloc),idimg(mbloc),idiagg(mbloc,3),
<      .          nblcg(mbloc),idegg(mbloc,3),jsg(mbloc),ksg(mbloc),
<      .          isg(mbloc),jeg(mbloc),keg(mbloc),ieg(mbloc),
<      .          mit(5,mbloc),ilamlog(mbloc),ilamhig(mbloc),
<      .          jlamlog(mbloc),jlamhig(mbloc),klamlog(mbloc),
<      .          klamhig(mbloc)
<       dimension imap(msegt,msegn,mbloc),idbloc(mtot),
<      .          ivisb(msegt,mbloc),itrb(7,mbloc),
<      .          val(mtot),xdum(msegt,mtot),
<      .          iold(4,mtot),nxtseg(mtot),intrfc(mtot),
<      .          ipatch(mtot),ni(mbloc),nj(mbloc),nk(mbloc)
<       dimension xdmold(msegt),idmold(msegt)
<       dimension nseg1(mbloc)
<       dimension nsilo(mbloc),nsihi(mbloc),nsjlo(mbloc),
<      .          nsjhi(mbloc),nsklo(mbloc),nskhi(mbloc)
<       dimension nb1(mbloc,6,msegn),ne1(mbloc,6,msegn),
<      .          nb2(mbloc,6,msegn),ne2(mbloc,6,msegn),
<      .          ibct(mbloc,6,msegn)
<       dimension bcval(mbloc,6,msegn,7)
<       dimension iovrlp(mbloc),ifoflg(mbloc,6,msegn),
<      .          ndat(mbloc,6,msegn),xmap(msegt,msegn,mbloc)
<       dimension twotref(msegn,mbloc)
<       dimension itrb1(mbloc),itrb2(mbloc),jtrb1(mbloc),jtrb2(mbloc),
<      .          ktrb1(mbloc),ktrb2(mbloc),iturbb(mbloc)
<       dimension ibif1(mxbli),ibif2(mxbli)
<       dimension nbi1(mxbli),nei1(mxbli),nbj1(mxbli),
<      .          nej1(mxbli),nbk1(mxbli),nek1(mxbli),
<      .          nbi2(mxbli),nei2(mxbli),nbj2(mxbli),
<      .          nej2(mxbli),nbk2(mxbli),nek2(mxbli),
<      .          nd11(mxbli),nd21(mxbli),nd12(mxbli),
<      .          nd22(mxbli)
<       dimension ifsor(mbloc),nb1s(mbloc),ne1s(mbloc),
<      .          nb2s(mbloc),ne2s(mbloc)
<       dimension nsubbl(mbloc),idobl(mbloc),nseg(mbloc),idno(mbloc),
<      .          ijk(6,mbloc),idseg(mbloc),idnext(mbloc)
< c
<       pointer (ip_ifrom,ifrom),(ip_xif1,xif1),(ip_xif2,xif2),
<      .        (ip_etf1,etf1),(ip_etf2,etf2),(ip_ito,ito),(ip_xit1,xit1),
<      .        (ip_xit2,xit2),(ip_ett1,ett1),(ip_ett2,ett2),(ip_nfb,nfb)
<       pointer (ip_iadvance,iadvance),(ip_iforce,iforce),
<      .        (ip_nblkk,nblkk),(ip_limblk,limblk),(ip_isva,isva),
<      .        (ip_nblon,nblon),(ip_ncgg,ncgg),(ip_nblg,nblg),
<      .        (ip_iemg,iemg),(ip_inewgg,inewgg),(ip_bcvali,bcvali),
<      .        (ip_bcvalj,bcvalj),(ip_bcvalk,bcvalk),(ip_nbci0,nbci0),
<      .        (ip_nbcidim,nbcidim),(ip_nbcj0,nbcj0),
<      .        (ip_nbcjdim,nbcjdim),(ip_nbck0,nbck0),
<      .        (ip_nbckdim,nbckdim),(ip_ibcinfo,ibcinfo),
<      .        (ip_jbcinfo,jbcinfo),(ip_kbcinfo,kbcinfo)
<       pointer (ip_llimit,llimit),(ip_iitmax,iitmax),(ip_mmcxie,mmcxie),
<      .        (ip_mmceta,mmceta),(ip_iifit,iifit),(ip_iic0,iic0),
<      .        (ip_iiorph,iiorph),(ip_iredundant,iredundant),
<      .        (ip_iconcat,iconcat),(ip_cq,cq),(ip_cporous,cporous),
<      .        (ip_cpchamber,cpchamber),(ip_cradiation,cradiation),
<      .        (ip_isblocin,isblocin),(ip_ndirin,ndirin),(ip_isin,isin),
<      .        (ip_ndirin0,ndirin0),(ip_isin0,isin0)
<       pointer (ip_nbs,nbs),(ip_imin,imin),(ip_jmin,jmin),(ip_kmin,kmin),
<      .        (ip_imax,imax),(ip_jmax,jmax),(ip_kmax,kmax),
<      .        (ip_iskp,iskp),(ip_jskp,jskp),(ip_kskp,kskp),(ip_ilo,ilo),
<      .        (ip_jlo,jlo),(ip_klo,klo),(ip_iln,iln),(ip_jln,jln),
<      .        (ip_kln,kln),(ip_ibeg,ibeg),(ip_npts,npts),(ip_x,x),
<      .        (ip_y,y),(ip_z,z),(ip_ilosd,ilosd),(ip_jlosd,jlosd),
<      .        (ip_klosd,klosd) 
<       pointer (ip_il,il),(ip_jl,jl),(ip_kl,kl),(ip_rkap0g,rkap0g),
<      .        (ip_levelg,levelg),(ip_igridg,igridg),(ip_iflimg,iflimg),
<      .        (ip_ifdsg,ifdsg),(ip_iviscg,iviscg),(ip_jdimg,jdimg),
<      .        (ip_kdimg,kdimg),(ip_idimg,idimg),(ip_idiagg,idiagg),
<      .        (ip_nblcg,nblcg),(ip_idegg,idegg),(ip_jsg,jsg),
<      .        (ip_ksg,ksg),(ip_isg,isg),(ip_jeg,jeg),(ip_keg,keg),
<      .        (ip_ieg,ieg),(ip_mit,mit),(ip_ilamlog,ilamlog),
<      .        (ip_ilamhig,ilamhig),(ip_jlamlog,jlamlog),
<      .        (ip_jlamhig,jlamhig),(ip_klamlog,klamlog),
<      .        (ip_klamhig,klamhig)
<       pointer (ip_imap,imap),(ip_idbloc,idbloc),(ip_ivisb,ivisb),
<      .        (ip_itrb,itrb),(ip_val,val),(ip_xdum,xdum),
<      .        (ip_iold,iold),(ip_nxtseg,nxtseg),(ip_intrfc,intrfc),
<      .        (ip_ipatch,ipatch),(ip_ni,ni),(ip_nj,nj),(ip_nk,nk),
<      .        (ip_xdmold,xdmold),(ip_idmold,idmold),(ip_nseg1,nseg1)
< 
<       pointer (ip_nsilo,nsilo),(ip_nsihi,nsihi),(ip_nsjlo,nsjlo),
<      .        (ip_nsjhi,nsjhi),(ip_nsklo,nsklo),(ip_nskhi,nskhi),
<      .        (ip_nb1,nb1),(ip_ne1,ne1),(ip_nb2,nb2),(ip_ne2,ne2),
<      .        (ip_ibct,ibct),(ip_bcval,bcval),(ip_iovrlp,iovrlp),
<      .        (ip_ifoflg,ifoflg),(ip_ndat,ndat),(ip_xmap,xmap)
<       pointer (ip_twotref,twotref),(ip_itrb1,itrb1),(ip_itrb2,itrb2),
<      .        (ip_jtrb1,jtrb1),(ip_jtrb2,jtrb2),(ip_ktrb1,ktrb1),
<      .        (ip_ktrb2,ktrb2),(ip_iturbb,iturbb),(ip_ibif1,ibif1),
<      .        (ip_ibif2,ibif2),(ip_nbi1,nbi1),(ip_nei1,nei1),
<      .        (ip_nbj1,nbj1),(ip_nej1,nej1),(ip_nbk1,nbk1),
<      .        (ip_nek1,nek1),(ip_nbi2,nbi2),(ip_nei2,nei2),
<      .        (ip_nbj2,nbj2),(ip_nej2,nej2),(ip_nbk2,nbk2),
<      .        (ip_nek2,nek2),(ip_nd11,nd11),(ip_nd21,nd21),
<      .        (ip_nd12,nd12),(ip_nd22,nd22),(ip_ifsor,ifsor),
<      .        (ip_nb1s,nb1s),(ip_ne1s,ne1s),(ip_nb2s,nb2s),
<      .        (ip_ne2s,ne2s),(ip_nsubbl,nsubbl),(ip_idobl,idobl),
<      .        (ip_nseg,nseg),(ip_idno,idno),(ip_ijk,ijk),
<      .        (ip_idseg,idseg),(ip_idnext,idnext)
---
> c
>       allocatable :: bcval(:,:,:,:)
>       allocatable :: bcvali(:,:,:,:)
>       allocatable :: bcvalj(:,:,:,:)
>       allocatable :: bcvalk(:,:,:,:)
>       allocatable :: cpchamber(:,:)
>       allocatable :: cporous(:,:)
>       allocatable :: cq(:,:)
>       allocatable :: cradiation(:,:)
>       allocatable :: etf1(:,:)
>       allocatable :: etf2(:,:)
>       allocatable :: ett1(:)
>       allocatable :: ett2(:)
>       allocatable :: iadvance(:)
>       allocatable :: ibcinfo(:,:,:,:)
>       allocatable :: ibct(:,:,:)
>       allocatable :: ibeg(:)
>       allocatable :: ibif1(:)
>       allocatable :: ibif2(:)
>       allocatable :: iconcat(:)
>       allocatable :: idbloc(:)
>       allocatable :: idegg(:,:)
>       allocatable :: idiagg(:,:)
>       allocatable :: idimg(:)
>       allocatable :: idmold(:)
>       allocatable :: idnext(:)
>       allocatable :: idno(:)
>       allocatable :: idobl(:)
>       allocatable :: idseg(:)
>       allocatable :: ieg(:)
>       allocatable :: iemg(:)
>       allocatable :: ifdsg(:,:)
>       allocatable :: iflimg(:,:)
>       allocatable :: ifoflg(:,:,:)
>       allocatable :: iforce(:)
>       allocatable :: ifrom(:,:)
>       allocatable :: ifsor(:)
>       allocatable :: igridg(:)
>       allocatable :: iic0(:)
>       allocatable :: iifit(:)
>       allocatable :: iiorph(:)
>       allocatable :: iitmax(:)
>       allocatable :: ijk(:,:)
>       allocatable :: il(:)
>       allocatable :: ilamhig(:)
>       allocatable :: ilamlog(:)
>       allocatable :: iln(:)
>       allocatable :: ilo(:)
>       allocatable :: ilosd(:)
>       allocatable :: imap(:,:,:)
>       allocatable :: imax(:)
>       allocatable :: imin(:)
>       allocatable :: inewgg(:)
>       allocatable :: intrfc(:)
>       allocatable :: iold(:,:)
>       allocatable :: iovrlp(:)
>       allocatable :: ipatch(:)
>       allocatable :: iredundant(:,:)
>       allocatable :: isblocin(:)
>       allocatable :: isg(:)
>       allocatable :: isin(:)
>       allocatable :: isin0(:)
>       allocatable :: iskp(:)
>       allocatable :: isva(:,:,:)
>       allocatable :: ito(:)
>       allocatable :: itrb(:,:)
>       allocatable :: itrb1(:)
>       allocatable :: itrb2(:)
>       allocatable :: iturbb(:)
>       allocatable :: ivisb(:,:)
>       allocatable :: iviscg(:,:)
>       allocatable :: jbcinfo(:,:,:,:)
>       allocatable :: jdimg(:)
>       allocatable :: jeg(:)
>       allocatable :: jl(:)
>       allocatable :: jlamhig(:)
>       allocatable :: jlamlog(:)
>       allocatable :: jln(:)
>       allocatable :: jlo(:)
>       allocatable :: jlosd(:)
>       allocatable :: jmax(:)
>       allocatable :: jmin(:)
>       allocatable :: jsg(:)
>       allocatable :: jskp(:)
>       allocatable :: jtrb1(:)
>       allocatable :: jtrb2(:)
>       allocatable :: kbcinfo(:,:,:,:)
>       allocatable :: kdimg(:)
>       allocatable :: keg(:)
>       allocatable :: kl(:)
>       allocatable :: klamhig(:)
>       allocatable :: klamlog(:)
>       allocatable :: kln(:)
>       allocatable :: klo(:)
>       allocatable :: klosd(:)
>       allocatable :: kmax(:)
>       allocatable :: kmin(:)
>       allocatable :: ksg(:)
>       allocatable :: kskp(:)
>       allocatable :: ktrb1(:)
>       allocatable :: ktrb2(:)
>       allocatable :: levelg(:)
>       allocatable :: limblk(:,:,:)
>       allocatable :: llimit(:)
>       allocatable :: mit(:,:)
>       allocatable :: mmceta(:)
>       allocatable :: mmcxie(:)
>       allocatable :: nb1(:,:,:)
>       allocatable :: nb1s(:)
>       allocatable :: nb2(:,:,:)
>       allocatable :: nb2s(:)
>       allocatable :: nbci0(:)
>       allocatable :: nbcidim(:)
>       allocatable :: nbcj0(:)
>       allocatable :: nbcjdim(:)
>       allocatable :: nbck0(:)
>       allocatable :: nbckdim(:)
>       allocatable :: nbi1(:)
>       allocatable :: nbi2(:)
>       allocatable :: nbj1(:)
>       allocatable :: nbj2(:)
>       allocatable :: nbk1(:)
>       allocatable :: nbk2(:)
>       allocatable :: nblcg(:)
>       allocatable :: nblg(:)
>       allocatable :: nblkk(:,:)
>       allocatable :: nblon(:)
>       allocatable :: nbs(:)
>       allocatable :: ncgg(:)
>       allocatable :: nd11(:)
>       allocatable :: nd12(:)
>       allocatable :: nd21(:)
>       allocatable :: nd22(:)
>       allocatable :: ndat(:,:,:)
>       allocatable :: ndirin(:)
>       allocatable :: ndirin0(:)
>       allocatable :: ne1(:,:,:)
>       allocatable :: ne1s(:)
>       allocatable :: ne2(:,:,:)
>       allocatable :: ne2s(:)
>       allocatable :: nei1(:)
>       allocatable :: nei2(:)
>       allocatable :: nej1(:)
>       allocatable :: nej2(:)
>       allocatable :: nek1(:)
>       allocatable :: nek2(:)
>       allocatable :: nfb(:)
>       allocatable :: ni(:)
>       allocatable :: nj(:)
>       allocatable :: nk(:)
>       allocatable :: npts(:)
>       allocatable :: nseg(:)
>       allocatable :: nseg1(:)
>       allocatable :: nsihi(:)
>       allocatable :: nsilo(:)
>       allocatable :: nsjhi(:)
>       allocatable :: nsjlo(:)
>       allocatable :: nskhi(:)
>       allocatable :: nsklo(:)
>       allocatable :: nsubbl(:)
>       allocatable :: nxtseg(:)
>       allocatable :: rkap0g(:,:)
>       allocatable :: twotref(:,:)
>       allocatable :: val(:)
>       complex, allocatable :: x(:)
>       allocatable :: xdmold(:)
>       allocatable :: xdum(:,:)
>       allocatable :: xif1(:,:)
>       allocatable :: xif2(:,:)
>       allocatable :: xit1(:)
>       allocatable :: xit2(:)
>       allocatable :: xmap(:,:,:)
>       complex, allocatable :: y(:)
>       complex, allocatable :: z(:)
167d212
<       icall  = 0
170,343c215,560
<       call umalloc(ip_ifrom,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_xif1,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_xif2,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_etf1,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_etf2,intmax*nsub1,1,icall,memuse)
<       call umalloc(ip_ito,intmax,1,icall,memuse)
<       call umalloc(ip_xit1,intmax,1,icall,memuse)
<       call umalloc(ip_xit2,intmax,1,icall,memuse)
<       call umalloc(ip_ett1,intmax,1,icall,memuse)
<       call umalloc(ip_ett2,intmax,1,icall,memuse)
<       call umalloc(ip_nfb,intmax,1,icall,memuse)
<       call umalloc(ip_iadvance,mbloc,1,icall,memuse)
<       call umalloc(ip_iforce,mbloc,1,icall,memuse)
<       call umalloc(ip_nblkk,2*mxbli,1,icall,memuse)
<       call umalloc(ip_limblk,12*mxbli,1,icall,memuse)
<       call umalloc(ip_isva,4*mxbli,1,icall,memuse)
<       call umalloc(ip_nblon,mxbli,1,icall,memuse)
<       call umalloc(ip_ncgg,mbloc,1,icall,memuse)
<       call umalloc(ip_nblg,mbloc,1,icall,memuse)
<       call umalloc(ip_iemg,mbloc,1,icall,memuse)
<       call umalloc(ip_inewgg,mbloc,1,icall,memuse)
<       call umalloc(ip_bcvali,14*mbloc*maxseg,0,icall,memuse)
<       call umalloc(ip_bcvalj,14*mbloc*maxseg,0,icall,memuse) 
<       call umalloc(ip_bcvalk,14*mbloc*maxseg,0,icall,memuse)
<       call umalloc(ip_nbci0,mbloc,1,icall,memuse)
<       call umalloc(ip_nbcidim,mbloc,1,icall,memuse)
<       call umalloc(ip_nbcj0,mbloc,1,icall,memuse)
<       call umalloc(ip_nbcjdim,mbloc,1,icall,memuse)
<       call umalloc(ip_nbck0,mbloc,1,icall,memuse)
<       call umalloc(ip_nbckdim,mbloc,1,icall,memuse)
<       call umalloc(ip_ibcinfo,14*mbloc*maxseg,1,icall,memuse)
<       call umalloc(ip_jbcinfo,14*mbloc*maxseg,1,icall,memuse)
<       call umalloc(ip_kbcinfo,14*mbloc*maxseg,1,icall,memuse)
<       call umalloc(ip_llimit,intmax,1,icall,memuse)
<       call umalloc(ip_iitmax,intmax,1,icall,memuse)
<       call umalloc(ip_mmcxie,intmax,1,icall,memuse)
<       call umalloc(ip_mmceta,intmax,1,icall,memuse)
<       call umalloc(ip_iifit,intmax,1,icall,memuse)
<       call umalloc(ip_iic0,intmax,1,icall,memuse)
<       call umalloc(ip_iiorph,intmax,1,icall,memuse)
<       call umalloc(ip_iredundant,mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_iconcat,intmax,1,icall,memuse)
<       call umalloc(ip_cq,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_cporous,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_cpchamber,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_cradiation,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_isblocin,msplt*mbloc,1,icall,memuse)
<       call umalloc(ip_ndirin,msplt*mbloc,1,icall,memuse)
<       call umalloc(ip_isin,msplt*mbloc,1,icall,memuse)
<       call umalloc(ip_ndirin0,msplt,1,icall,memuse)
<       call umalloc(ip_isin0,msplt,1,icall,memuse)
<       call umalloc(ip_nbs,mbloc,1,icall,memuse)
<       call umalloc(ip_imin,mbloc,1,icall,memuse)
<       call umalloc(ip_jmin,mbloc,1,icall,memuse)
<       call umalloc(ip_kmin,mbloc,1,icall,memuse)
<       call umalloc(ip_imax,mbloc,1,icall,memuse)
<       call umalloc(ip_jmax,mbloc,1,icall,memuse)
<       call umalloc(ip_kmax,mbloc,1,icall,memuse)
<       call umalloc(ip_iskp,mbloc,1,icall,memuse)
<       call umalloc(ip_jskp,mbloc,1,icall,memuse)
<       call umalloc(ip_kskp,mbloc,1,icall,memuse)
<       call umalloc(ip_ilo,mbloc,1,icall,memuse)
<       call umalloc(ip_jlo,mbloc,1,icall,memuse)
<       call umalloc(ip_klo,mbloc,1,icall,memuse)
<       call umalloc(ip_iln,mbloc,1,icall,memuse)
<       call umalloc(ip_jln,mbloc,1,icall,memuse)
<       call umalloc(ip_kln,mbloc,1,icall,memuse)
<       call umalloc(ip_ibeg,mbloc,1,icall,memuse)
<       call umalloc(ip_npts,mbloc,1,icall,memuse)
<       call umalloc_c(ip_x,npmax,0,icall,memuse)
<       call umalloc_c(ip_y,npmax,0,icall,memuse)
<       call umalloc_c(ip_z,npmax,0,icall,memuse)
<       call umalloc(ip_ilosd,mbloc,1,icall,memuse)
<       call umalloc(ip_jlosd,mbloc,1,icall,memuse)
<       call umalloc(ip_klosd,mbloc,1,icall,memuse)
<       call umalloc(ip_il,mbloc,1,icall,memuse)
<       call umalloc(ip_jl,mbloc,1,icall,memuse)
<       call umalloc(ip_kl,mbloc,1,icall,memuse)
<       call umalloc(ip_rkap0g,3*mbloc,0,icall,memuse)
<       call umalloc(ip_levelg,mbloc,1,icall,memuse)
<       call umalloc(ip_igridg,mbloc,1,icall,memuse)
<       call umalloc(ip_iflimg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_ifdsg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_iviscg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_jdimg,mbloc,1,icall,memuse)
<       call umalloc(ip_kdimg,mbloc,1,icall,memuse)
<       call umalloc(ip_idimg,mbloc,1,icall,memuse)
<       call umalloc(ip_idiagg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_nblcg,mbloc,1,icall,memuse)
<       call umalloc(ip_idegg,3*mbloc,1,icall,memuse)
<       call umalloc(ip_jsg,mbloc,1,icall,memuse)
<       call umalloc(ip_ksg,mbloc,1,icall,memuse)
<       call umalloc(ip_isg,mbloc,1,icall,memuse)
<       call umalloc(ip_jeg,mbloc,1,icall,memuse)
<       call umalloc(ip_keg,mbloc,1,icall,memuse)
<       call umalloc(ip_ieg,mbloc,1,icall,memuse)
<       call umalloc(ip_mit,5*mbloc,1,icall,memuse)
<       call umalloc(ip_ilamlog,mbloc,1,icall,memuse)
<       call umalloc(ip_ilamhig,mbloc,1,icall,memuse)
<       call umalloc(ip_jlamlog,mbloc,1,icall,memuse)
<       call umalloc(ip_jlamhig,mbloc,1,icall,memuse)
<       call umalloc(ip_klamlog,mbloc,1,icall,memuse)
<       call umalloc(ip_klamhig,mbloc,1,icall,memuse)
<       call umalloc(ip_imap,msegt*msegn*mbloc,1,icall,memuse)
<       call umalloc(ip_idbloc,mtot,1,icall,memuse)
<       call umalloc(ip_ivisb,msegt*mtot,1,icall,memuse)
<       call umalloc(ip_itrb,7*mbloc,1,icall,memuse)
<       call umalloc(ip_val,mtot,0,icall,memuse)
<       call umalloc(ip_xdum,msegt*mtot,0,icall,memuse)
<       call umalloc(ip_iold,4*mtot,1,icall,memuse)
<       call umalloc(ip_nxtseg,mtot,1,icall,memuse)
<       call umalloc(ip_intrfc,mtot,1,icall,memuse)
<       call umalloc(ip_ipatch,mtot,1,icall,memuse)
<       call umalloc(ip_ni,mbloc,1,icall,memuse)
<       call umalloc(ip_nj,mbloc,1,icall,memuse)
<       call umalloc(ip_nk,mbloc,1,icall,memuse)
<       call umalloc(ip_xdmold,msegt,0,icall,memuse)
<       call umalloc(ip_idmold,msegt,1,icall,memuse)
<       call umalloc(ip_nseg1,mbloc,1,icall,memuse)
<       call umalloc(ip_nsilo,mbloc,1,icall,memuse)
<       call umalloc(ip_nsihi,mbloc,1,icall,memuse)
<       call umalloc(ip_nsjlo,mbloc,1,icall,memuse)
<       call umalloc(ip_nsjhi,mbloc,1,icall,memuse)
<       call umalloc(ip_nsklo,mbloc,1,icall,memuse)
<       call umalloc(ip_nskhi,mbloc,1,icall,memuse)
<       call umalloc(ip_nb1,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_ne1,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_nb2,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_ne2,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_ibct,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_bcval,42*mbloc*msegn,0,icall,memuse)
<       call umalloc(ip_iovrlp,mbloc,1,icall,memuse)
<       call umalloc(ip_ifoflg,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_ndat,6*mbloc*msegn,1,icall,memuse)
<       call umalloc(ip_xmap,msegt*msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_twotref,msegn*mbloc,0,icall,memuse)
<       call umalloc(ip_itrb1,mbloc,1,icall,memuse)
<       call umalloc(ip_itrb2,mbloc,1,icall,memuse)
<       call umalloc(ip_jtrb1,mbloc,1,icall,memuse)
<       call umalloc(ip_jtrb2,mbloc,1,icall,memuse)
<       call umalloc(ip_ktrb1,mbloc,1,icall,memuse)
<       call umalloc(ip_ktrb2,mbloc,1,icall,memuse)
<       call umalloc(ip_iturbb,mbloc,1,icall,memuse)
<       call umalloc(ip_ibif1,mxbli,1,icall,memuse)
<       call umalloc(ip_ibif2,mxbli,1,icall,memuse)
<       call umalloc(ip_nbi1,mxbli,1,icall,memuse)
<       call umalloc(ip_nei1,mxbli,1,icall,memuse)
<       call umalloc(ip_nbj1,mxbli,1,icall,memuse)
<       call umalloc(ip_nej1,mxbli,1,icall,memuse)
<       call umalloc(ip_nbk1,mxbli,1,icall,memuse)
<       call umalloc(ip_nek1,mxbli,1,icall,memuse)
<       call umalloc(ip_nbi2,mxbli,1,icall,memuse)
<       call umalloc(ip_nei2,mxbli,1,icall,memuse)
<       call umalloc(ip_nbj2,mxbli,1,icall,memuse)
<       call umalloc(ip_nej2,mxbli,1,icall,memuse)
<       call umalloc(ip_nbk2,mxbli,1,icall,memuse)
<       call umalloc(ip_nek2,mxbli,1,icall,memuse)
<       call umalloc(ip_nd11,mxbli,1,icall,memuse)
<       call umalloc(ip_nd21,mxbli,1,icall,memuse)
<       call umalloc(ip_nd12,mxbli,1,icall,memuse)
<       call umalloc(ip_nd22,mxbli,1,icall,memuse)
<       call umalloc(ip_ifsor,mbloc,1,icall,memuse)
<       call umalloc(ip_nb1s,mbloc,1,icall,memuse)
<       call umalloc(ip_ne1s,mbloc,1,icall,memuse)
<       call umalloc(ip_nb2s,mbloc,1,icall,memuse)
<       call umalloc(ip_ne2s,mbloc,1,icall,memuse)
<       call umalloc(ip_nsubbl,mbloc,1,icall,memuse)
<       call umalloc(ip_idobl,mbloc,1,icall,memuse)
<       call umalloc(ip_nseg,mbloc,1,icall,memuse)
<       call umalloc(ip_idno,mbloc,1,icall,memuse)
<       call umalloc(ip_ijk,6*mbloc,1,icall,memuse)
<       call umalloc(ip_idseg,mbloc,1,icall,memuse)
<       call umalloc(ip_idnext,mbloc,1,icall,memuse)
< c
---
>       allocate( bcval(mbloc,6,msegn,7), stat=stats )
>       call umalloc(mbloc*6*msegn*7,0,'bcval',memuse,stats)
>       allocate( bcvali(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,0,'bcvali',memuse,stats)
>       allocate( bcvalj(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,0,'bcvalj',memuse,stats)
>       allocate( bcvalk(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,0,'bcvalk',memuse,stats)
>       allocate( cpchamber(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'cpchamber',memuse,stats)
>       allocate( cporous(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'cporous',memuse,stats)
>       allocate( cq(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'cq',memuse,stats)
>       allocate( cradiation(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'cradiation',memuse,stats)
>       allocate( etf1(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'etf1',memuse,stats)
>       allocate( etf2(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'etf2',memuse,stats)
>       allocate( ett1(intmax), stat=stats )
>       call umalloc(intmax,1,'ett1',memuse,stats)
>       allocate( ett2(intmax), stat=stats )
>       call umalloc(intmax,1,'ett2',memuse,stats)
>       allocate( iadvance(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iadvance',memuse,stats)
>       allocate( ibcinfo(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,1,'ibcinfo',memuse,stats)
>       allocate( ibct(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ibct',memuse,stats)
>       allocate( ibeg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ibeg',memuse,stats)
>       allocate( ibif1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'ibif1',memuse,stats)
>       allocate( ibif2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'ibif2',memuse,stats)
>       allocate( iconcat(intmax), stat=stats )
>       call umalloc(intmax,1,'iconcat',memuse,stats)
>       allocate( idbloc(mtot), stat=stats )
>       call umalloc(mtot,1,'idbloc',memuse,stats)
>       allocate( idegg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'idegg',memuse,stats)
>       allocate( idiagg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'idiagg',memuse,stats)
>       allocate( idimg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'idimg',memuse,stats)
>       allocate( idmold(msegt), stat=stats )
>       call umalloc(msegt,1,'idmold',memuse,stats)
>       allocate( idnext(mbloc), stat=stats )
>       call umalloc(mbloc,1,'idnext',memuse,stats)
>       allocate( idno(mbloc), stat=stats )
>       call umalloc(mbloc,1,'dno',memuse,stats)
>       allocate( idobl(mbloc), stat=stats )
>       call umalloc(mbloc,1,'idobl',memuse,stats)
>       allocate( idseg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'idseg',memuse,stats)
>       allocate( ieg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ieg',memuse,stats)
>       allocate( iemg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iemg',memuse,stats)
>       allocate( ifdsg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'ifdsg',memuse,stats)
>       allocate( iflimg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'iflimg',memuse,stats)
>       allocate( ifoflg(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ifoflg',memuse,stats)
>       allocate( iforce(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iforce',memuse,stats)
>       allocate( ifrom(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'ifrom',memuse,stats)
>       allocate( ifsor(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ifsor',memuse,stats)
>       allocate( igridg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'igridg',memuse,stats)
>       allocate( iic0(intmax), stat=stats )
>       call umalloc(intmax,1,'iic0',memuse,stats)
>       allocate( iifit(intmax), stat=stats )
>       call umalloc(intmax,1,'iifit',memuse,stats)
>       allocate( iiorph(intmax), stat=stats )
>       call umalloc(intmax,1,'iiorph',memuse,stats)
>       allocate( iitmax(intmax), stat=stats )
>       call umalloc(intmax,1,'iitmax',memuse,stats)
>       allocate( ijk(6,mbloc), stat=stats )
>       call umalloc(6*mbloc,1,'ijk',memuse,stats)
>       allocate( il(mbloc), stat=stats )
>       call umalloc(mbloc,1,'il',memuse,stats)
>       allocate( ilamhig(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ilamhig',memuse,stats)
>       allocate( ilamlog(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ilamlog',memuse,stats)
>       allocate( iln(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iln',memuse,stats)
>       allocate( ilo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ilo',memuse,stats)
>       allocate( ilosd(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ilosd',memuse,stats)
>       allocate( imap(msegt,msegn,mbloc), stat=stats )
>       call umalloc(msegt*msegn*mbloc,1,'imap',memuse,stats)
>       allocate( imax(mbloc), stat=stats )
>       call umalloc(mbloc,1,'imax',memuse,stats)
>       allocate( imin(mbloc), stat=stats )
>       call umalloc(mbloc,1,'imin',memuse,stats)
>       allocate( inewgg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'inewgg',memuse,stats)
>       allocate( intrfc(mtot), stat=stats )
>       call umalloc(mtot,1,'intrfc',memuse,stats)
>       allocate( iold(4,mtot), stat=stats )
>       call umalloc(4*mtot,1,'iold',memuse,stats)
>       allocate( iovrlp(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iovrlp',memuse,stats)
>       allocate( ipatch(mtot), stat=stats )
>       call umalloc(mtot,1,'ipatch',memuse,stats)
>       allocate( iredundant(mbloc,msegn), stat=stats )
>       call umalloc(mbloc*msegn,1,'iredundant',memuse,stats)
>       allocate( isblocin(msplt*mbloc), stat=stats )
>       call umalloc(msplt*mbloc,1,'isblocin',memuse,stats)
>       allocate( isg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'isg',memuse,stats)
>       allocate( isin(msplt*mbloc), stat=stats )
>       call umalloc(msplt*mbloc,1,'isin',memuse,stats)
>       allocate( isin0(msplt), stat=stats )
>       call umalloc(msplt,1,'isin0',memuse,stats)
>       allocate( iskp(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iskp',memuse,stats)
>       allocate( isva(2,2,mxbli), stat=stats )
>       call umalloc(2*2*mxbli,1,'isva',memuse,stats)
>       allocate( ito(intmax), stat=stats )
>       call umalloc(intmax,1,'ito',memuse,stats)
>       allocate( itrb(7,mbloc), stat=stats )
>       call umalloc(7*mbloc,1,'itrb',memuse,stats)
>       allocate( itrb1(mbloc), stat=stats )
>       call umalloc(mbloc,1,'itrb1',memuse,stats)
>       allocate( itrb2(mbloc), stat=stats )
>       call umalloc(mbloc,1,'itrb2',memuse,stats)
>       allocate( iturbb(mbloc), stat=stats )
>       call umalloc(mbloc,1,'iturbb',memuse,stats)
>       allocate( ivisb(msegt,mbloc), stat=stats )
>       call umalloc(msegt*mbloc,1,'ivisb',memuse,stats)
>       allocate( iviscg(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,1,'iviscg',memuse,stats)
>       allocate( jbcinfo(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,1,'jbcinfo',memuse,stats)
>       allocate( jdimg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jdimg',memuse,stats)
>       allocate( jeg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jeg',memuse,stats)
>       allocate( jl(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jl',memuse,stats)
>       allocate( jlamhig(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jlamhig',memuse,stats)
>       allocate( jlamlog(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jlamlog',memuse,stats)
>       allocate( jln(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jln',memuse,stats)
>       allocate( jlo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jlo',memuse,stats)
>       allocate( jlosd(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jlosd',memuse,stats)
>       allocate( jmax(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jmax',memuse,stats)
>       allocate( jmin(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jmin',memuse,stats)
>       allocate( jsg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jsg',memuse,stats)
>       allocate( jskp(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jskp',memuse,stats)
>       allocate( jtrb1(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jtrb1',memuse,stats)
>       allocate( jtrb2(mbloc), stat=stats )
>       call umalloc(mbloc,1,'jtrb2',memuse,stats)
>       allocate( kbcinfo(mbloc,maxseg,7,2), stat=stats )
>       call umalloc(mbloc*maxseg*7*2,1,'kbcinfo',memuse,stats)
>       allocate( kdimg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kdimg',memuse,stats)
>       allocate( keg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'keg',memuse,stats)
>       allocate( kl(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kl',memuse,stats)
>       allocate( klamhig(mbloc), stat=stats )
>       call umalloc(mbloc,1,'klamhig',memuse,stats)
>       allocate( klamlog(mbloc), stat=stats )
>       call umalloc(mbloc,1,'klamlog',memuse,stats)
>       allocate( kln(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kln',memuse,stats)
>       allocate( klo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'klo',memuse,stats)
>       allocate( klosd(mbloc), stat=stats )
>       call umalloc(mbloc,1,'klosd',memuse,stats)
>       allocate( kmax(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kmax',memuse,stats)
>       allocate( kmin(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kmin',memuse,stats)
>       allocate( ksg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ksg',memuse,stats)
>       allocate( kskp(mbloc), stat=stats )
>       call umalloc(mbloc,1,'kskp',memuse,stats)
>       allocate( ktrb1(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ktrb1',memuse,stats)
>       allocate( ktrb2(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ktrb2',memuse,stats)
>       allocate( levelg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'levelg',memuse,stats)
>       allocate( limblk(2,6,mxbli), stat=stats )
>       call umalloc(2*6*mxbli,1,'limblk',memuse,stats)
>       allocate( llimit(intmax), stat=stats )
>       call umalloc(intmax,1,'llimit',memuse,stats)
>       allocate( mit(5,mbloc), stat=stats )
>       call umalloc(5*mbloc,1,'mit',memuse,stats)
>       allocate( mmceta(intmax), stat=stats )
>       call umalloc(intmax,1,'mmceta',memuse,stats)
>       allocate( mmcxie(intmax), stat=stats )
>       call umalloc(intmax,1,'mmcxie',memuse,stats)
>       allocate( nb1(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'nb1',memuse,stats)
>       allocate( nb1s(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nb1s',memuse,stats)
>       allocate( nb2(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'nb2',memuse,stats)
>       allocate( nb2s(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nb2s',memuse,stats)
>       allocate( nbci0(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbci0',memuse,stats)
>       allocate( nbcidim(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbcidim',memuse,stats)
>       allocate( nbcj0(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbcj0',memuse,stats)
>       allocate( nbcjdim(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbcjdim',memuse,stats)
>       allocate( nbck0(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbck0',memuse,stats)
>       allocate( nbckdim(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbckdim',memuse,stats)
>       allocate( nbi1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbi1',memuse,stats)
>       allocate( nbi2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbi2',memuse,stats)
>       allocate( nbj1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbj1',memuse,stats)
>       allocate( nbj2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbj2',memuse,stats)
>       allocate( nbk1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbk1',memuse,stats)
>       allocate( nbk2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nbk2',memuse,stats)
>       allocate( nblcg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nblcg',memuse,stats)
>       allocate( nblg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nblg',memuse,stats)
>       allocate( nblkk(2,mxbli), stat=stats )
>       call umalloc(2*mxbli,1,'nblkk',memuse,stats)
>       allocate( nblon(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nblon',memuse,stats)
>       allocate( nbs(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nbs',memuse,stats)
>       allocate( ncgg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ncgg',memuse,stats)
>       allocate( nd11(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nd11',memuse,stats)
>       allocate( nd12(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nd12',memuse,stats)
>       allocate( nd21(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nd21',memuse,stats)
>       allocate( nd22(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nd22',memuse,stats)
>       allocate( ndat(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ndat',memuse,stats)
>       allocate( ndirin(msplt*mbloc), stat=stats )
>       call umalloc(msplt*mbloc,1,'ndirin',memuse,stats)
>       allocate( ndirin0(msplt), stat=stats )
>       call umalloc(msplt,1,'ndirin0',memuse,stats)
>       allocate( ne1(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ne1',memuse,stats)
>       allocate( ne1s(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ne1s',memuse,stats)
>       allocate( ne2(mbloc,6,msegn), stat=stats )
>       call umalloc(mbloc*6*msegn,1,'ne2',memuse,stats)
>       allocate( ne2s(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ne2s',memuse,stats)
>       allocate( nei1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nei1',memuse,stats)
>       allocate( nei2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nei2',memuse,stats)
>       allocate( nej1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nej1',memuse,stats)
>       allocate( nej2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nej2',memuse,stats)
>       allocate( nek1(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nek1',memuse,stats)
>       allocate( nek2(mxbli), stat=stats )
>       call umalloc(mxbli,1,'nek2',memuse,stats)
>       allocate( nfb(intmax), stat=stats )
>       call umalloc(intmax,1,'nfb',memuse,stats)
>       allocate( ni(mbloc), stat=stats )
>       call umalloc(mbloc,1,'ni',memuse,stats)
>       allocate( nj(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nj',memuse,stats)
>       allocate( nk(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nk',memuse,stats)
>       allocate( npts(mbloc), stat=stats )
>       call umalloc(mbloc,1,'npts',memuse,stats)
>       allocate( nseg(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nseg',memuse,stats)
>       allocate( nseg1(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nseg1',memuse,stats)
>       allocate( nsihi(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsihi',memuse,stats)
>       allocate( nsilo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsilo',memuse,stats)
>       allocate( nsjhi(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsjhi',memuse,stats)
>       allocate( nsjlo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsjlo',memuse,stats)
>       allocate( nskhi(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nskhi',memuse,stats)
>       allocate( nsklo(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsklo',memuse,stats)
>       allocate( nsubbl(mbloc), stat=stats )
>       call umalloc(mbloc,1,'nsubbl',memuse,stats)
>       allocate( nxtseg(mtot), stat=stats )
>       call umalloc(mtot,1,'nxtseg',memuse,stats)
>       allocate( rkap0g(mbloc,3), stat=stats )
>       call umalloc(mbloc*3,0,'rkap0g',memuse,stats)
>       allocate( twotref(msegn,mbloc), stat=stats )
>       call umalloc(msegn*mbloc,0,'twotref',memuse,stats)
>       allocate( val(mtot), stat=stats )
>       call umalloc(mtot,0,'val',memuse,stats)
>       allocate( x(npmax), stat=stats )
>       call umalloc(npmax,0,'x',memuse,stats)
>       allocate( xdmold(msegt), stat=stats )
>       call umalloc(msegt,0,'xdmold',memuse,stats)
>       allocate( xdum(msegt,mtot), stat=stats )
>       call umalloc(msegt*mtot,0,'xdum',memuse,stats)
>       allocate( xif1(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'xif1',memuse,stats)
>       allocate( xif2(intmax,nsub1), stat=stats )
>       call umalloc(intmax*nsub1,1,'xif2',memuse,stats)
>       allocate( xit1(intmax), stat=stats )
>       call umalloc(intmax,1,'xit1',memuse,stats)
>       allocate( xit2(intmax), stat=stats )
>       call umalloc(intmax,1,'xit2',memuse,stats)
>       allocate( xmap(msegt,msegn,mbloc), stat=stats )
>       call umalloc(msegt*msegn*mbloc,0,'xmap',memuse,stats)
>       allocate( y(npmax), stat=stats )
>       call umalloc(npmax,0,'y',memuse,stats)
>       allocate( z(npmax), stat=stats )
>       call umalloc(npmax,0,'z',memuse,stats)
360c577
<  9990 format(2(2h *),43h   VERSION 6.0 :  Computational Fluids Lab,,
---
>  9990 format(2(2h *),43h   VERSION 6.X :  Computational Fluids Lab,,
363c580
<      .3x,2(2h *),/2(2h *),18x,33hRelease Date:    August  8, 2001.,
---
>      .3x,2(2h *),/2(2h *),18x,33hRelease Date:       MMM DD, YYYY.,
539c756
<      .                     nou,bou,nbuf,ibufdim)
---
>      .                     nou,bou,nbuf,ibufdim,cflout)
1026,1198c1243,1415
<       call ufree(ip_ifrom)
<       call ufree(ip_xif1)
<       call ufree(ip_xif2)
<       call ufree(ip_etf1)
<       call ufree(ip_etf2)
<       call ufree(ip_ito)
<       call ufree(ip_xit1)
<       call ufree(ip_xit2)
<       call ufree(ip_ett1)
<       call ufree(ip_ett2)
<       call ufree(ip_nfb)
<       call ufree(ip_iadvance)
<       call ufree(ip_iforce)
<       call ufree(ip_nblkk)
<       call ufree(ip_limblk)
<       call ufree(ip_isva)
<       call ufree(ip_nblon)
<       call ufree(ip_ncgg)
<       call ufree(ip_nblg)
<       call ufree(ip_iemg)
<       call ufree(ip_inewgg)
<       call ufree(ip_bcvali)
<       call ufree(ip_bcvalj)
<       call ufree(ip_bcvalk)
<       call ufree(ip_nbci0)
<       call ufree(ip_nbcidim)
<       call ufree(ip_nbcj0)
<       call ufree(ip_nbcjdim)
<       call ufree(ip_nbck0)
<       call ufree(ip_nbckdim)
<       call ufree(ip_ibcinfo)
<       call ufree(ip_jbcinfo)
<       call ufree(ip_kbcinfo)
<       call ufree(ip_llimit)
<       call ufree(ip_iitmax)
<       call ufree(ip_mmcxie)
<       call ufree(ip_mmceta)
<       call ufree(ip_iifit)
<       call ufree(ip_iic0)
<       call ufree(ip_iiorph)
<       call ufree(ip_iredundant)
<       call ufree(ip_iconcat)
<       call ufree(ip_cq)
<       call ufree(ip_cporous)
<       call ufree(ip_cpchamber)
<       call ufree(ip_cradiation)
<       call ufree(ip_isblocin)
<       call ufree(ip_ndirin)
<       call ufree(ip_isin)
<       call ufree(ip_ndirin0)
<       call ufree(ip_isin0)
<       call ufree(ip_nbs)
<       call ufree(ip_imin)
<       call ufree(ip_jmin)
<       call ufree(ip_kmin)
<       call ufree(ip_imax)
<       call ufree(ip_jmax)
<       call ufree(ip_kmax)
<       call ufree(ip_iskp)
<       call ufree(ip_jskp)
<       call ufree(ip_kskp)
<       call ufree(ip_ilo)
<       call ufree(ip_jlo)
<       call ufree(ip_klo)
<       call ufree(ip_iln)
<       call ufree(ip_jln)
<       call ufree(ip_kln)
<       call ufree(ip_ibeg)
<       call ufree(ip_npts)
<       call ufree(ip_x)
<       call ufree(ip_y)
<       call ufree(ip_z)
<       call ufree(ip_ilosd)
<       call ufree(ip_jlosd)
<       call ufree(ip_klosd)
<       call ufree(ip_il)
<       call ufree(ip_jl)
<       call ufree(ip_kl)
<       call ufree(ip_rkap0g)
<       call ufree(ip_levelg)
<       call ufree(ip_igridg)
<       call ufree(ip_iflimg)
<       call ufree(ip_ifdsg)
<       call ufree(ip_iviscg)
<       call ufree(ip_jdimg)
<       call ufree(ip_kdimg)
<       call ufree(ip_idimg)
<       call ufree(ip_idiagg)
<       call ufree(ip_nblcg)
<       call ufree(ip_idegg)
<       call ufree(ip_jsg)
<       call ufree(ip_ksg)
<       call ufree(ip_isg)
<       call ufree(ip_jeg)
<       call ufree(ip_keg)
<       call ufree(ip_ieg)
<       call ufree(ip_mit)
<       call ufree(ip_ilamlog)
<       call ufree(ip_ilamhig)
<       call ufree(ip_jlamlog)
<       call ufree(ip_jlamhig)
<       call ufree(ip_klamlog)
<       call ufree(ip_klamhig)
<       call ufree(ip_imap)
<       call ufree(ip_idbloc)
<       call ufree(ip_ivisb)
<       call ufree(ip_itrb)
<       call ufree(ip_val)
<       call ufree(ip_xdum)
<       call ufree(ip_iold)
<       call ufree(ip_nxtseg)
<       call ufree(ip_intrfc)
<       call ufree(ip_ipatch)
<       call ufree(ip_ni)
<       call ufree(ip_nj)
<       call ufree(ip_nk)
<       call ufree(ip_xdmold)
<       call ufree(ip_idmold)
<       call ufree(ip_nseg1)
<       call ufree(ip_nsilo)
<       call ufree(ip_nsihi)
<       call ufree(ip_nsjlo)
<       call ufree(ip_nsjhi)
<       call ufree(ip_nsklo)
<       call ufree(ip_nskhi)
<       call ufree(ip_nb1)
<       call ufree(ip_ne1)
<       call ufree(ip_nb2)
<       call ufree(ip_ne2)
<       call ufree(ip_ibct)
<       call ufree(ip_bcval)
<       call ufree(ip_iovrlp)
<       call ufree(ip_ifoflg)
<       call ufree(ip_ndat)
<       call ufree(ip_xmap)
<       call ufree(ip_twotref)
<       call ufree(ip_itrb1)
<       call ufree(ip_itrb2)
<       call ufree(ip_jtrb1)
<       call ufree(ip_jtrb2)
<       call ufree(ip_ktrb1)
<       call ufree(ip_ktrb2)
<       call ufree(ip_iturbb)
<       call ufree(ip_ibif1)
<       call ufree(ip_ibif2)
<       call ufree(ip_nbi1)
<       call ufree(ip_nei1)
<       call ufree(ip_nbj1)
<       call ufree(ip_nej1)
<       call ufree(ip_nbk1)
<       call ufree(ip_nek1)
<       call ufree(ip_nbi2)
<       call ufree(ip_nei2)
<       call ufree(ip_nbj2)
<       call ufree(ip_nej2)
<       call ufree(ip_nbk2)
<       call ufree(ip_nek2)
<       call ufree(ip_nd11)
<       call ufree(ip_nd21)
<       call ufree(ip_nd12)
<       call ufree(ip_nd22)
<       call ufree(ip_ifsor)
<       call ufree(ip_nb1s)
<       call ufree(ip_ne1s)
<       call ufree(ip_nb2s)
<       call ufree(ip_ne2s)
<       call ufree(ip_nsubbl)
<       call ufree(ip_idobl)
<       call ufree(ip_nseg)
<       call ufree(ip_idno)
<       call ufree(ip_ijk)
<       call ufree(ip_idseg)
<       call ufree(ip_idnext)
---
>       deallocate(ifrom)
>       deallocate(xif1)
>       deallocate(xif2)
>       deallocate(etf1)
>       deallocate(etf2)
>       deallocate(ito)
>       deallocate(xit1)
>       deallocate(xit2)
>       deallocate(ett1)
>       deallocate(ett2)
>       deallocate(nfb)
>       deallocate(iadvance)
>       deallocate(iforce)
>       deallocate(nblkk)
>       deallocate(limblk)
>       deallocate(isva)
>       deallocate(nblon)
>       deallocate(ncgg)
>       deallocate(nblg)
>       deallocate(iemg)
>       deallocate(inewgg)
>       deallocate(bcvali)
>       deallocate(bcvalj)
>       deallocate(bcvalk)
>       deallocate(nbci0)
>       deallocate(nbcidim)
>       deallocate(nbcj0)
>       deallocate(nbcjdim)
>       deallocate(nbck0)
>       deallocate(nbckdim)
>       deallocate(ibcinfo)
>       deallocate(jbcinfo)
>       deallocate(kbcinfo)
>       deallocate(llimit)
>       deallocate(iitmax)
>       deallocate(mmcxie)
>       deallocate(mmceta)
>       deallocate(iifit)
>       deallocate(iic0)
>       deallocate(iiorph)
>       deallocate(iredundant)
>       deallocate(iconcat)
>       deallocate(cq)
>       deallocate(cporous)
>       deallocate(cpchamber)
>       deallocate(cradiation)
>       deallocate(isblocin)
>       deallocate(ndirin)
>       deallocate(isin)
>       deallocate(ndirin0)
>       deallocate(isin0)
>       deallocate(nbs)
>       deallocate(imin)
>       deallocate(jmin)
>       deallocate(kmin)
>       deallocate(imax)
>       deallocate(jmax)
>       deallocate(kmax)
>       deallocate(iskp)
>       deallocate(jskp)
>       deallocate(kskp)
>       deallocate(ilo)
>       deallocate(jlo)
>       deallocate(klo)
>       deallocate(iln)
>       deallocate(jln)
>       deallocate(kln)
>       deallocate(ibeg)
>       deallocate(npts)
>       deallocate(x)
>       deallocate(y)
>       deallocate(z)
>       deallocate(ilosd)
>       deallocate(jlosd)
>       deallocate(klosd)
>       deallocate(il)
>       deallocate(jl)
>       deallocate(kl)
>       deallocate(rkap0g)
>       deallocate(levelg)
>       deallocate(igridg)
>       deallocate(iflimg)
>       deallocate(ifdsg)
>       deallocate(iviscg)
>       deallocate(jdimg)
>       deallocate(kdimg)
>       deallocate(idimg)
>       deallocate(idiagg)
>       deallocate(nblcg)
>       deallocate(idegg)
>       deallocate(jsg)
>       deallocate(ksg)
>       deallocate(isg)
>       deallocate(jeg)
>       deallocate(keg)
>       deallocate(ieg)
>       deallocate(mit)
>       deallocate(ilamlog)
>       deallocate(ilamhig)
>       deallocate(jlamlog)
>       deallocate(jlamhig)
>       deallocate(klamlog)
>       deallocate(klamhig)
>       deallocate(imap)
>       deallocate(idbloc)
>       deallocate(ivisb)
>       deallocate(itrb)
>       deallocate(val)
>       deallocate(xdum)
>       deallocate(iold)
>       deallocate(nxtseg)
>       deallocate(intrfc)
>       deallocate(ipatch)
>       deallocate(ni)
>       deallocate(nj)
>       deallocate(nk)
>       deallocate(xdmold)
>       deallocate(idmold)
>       deallocate(nseg1)
>       deallocate(nsilo)
>       deallocate(nsihi)
>       deallocate(nsjlo)
>       deallocate(nsjhi)
>       deallocate(nsklo)
>       deallocate(nskhi)
>       deallocate(nb1)
>       deallocate(ne1)
>       deallocate(nb2)
>       deallocate(ne2)
>       deallocate(ibct)
>       deallocate(bcval)
>       deallocate(iovrlp)
>       deallocate(ifoflg)
>       deallocate(ndat)
>       deallocate(xmap)
>       deallocate(twotref)
>       deallocate(itrb1)
>       deallocate(itrb2)
>       deallocate(jtrb1)
>       deallocate(jtrb2)
>       deallocate(ktrb1)
>       deallocate(ktrb2)
>       deallocate(iturbb)
>       deallocate(ibif1)
>       deallocate(ibif2)
>       deallocate(nbi1)
>       deallocate(nei1)
>       deallocate(nbj1)
>       deallocate(nej1)
>       deallocate(nbk1)
>       deallocate(nek1)
>       deallocate(nbi2)
>       deallocate(nei2)
>       deallocate(nbj2)
>       deallocate(nej2)
>       deallocate(nbk2)
>       deallocate(nek2)
>       deallocate(nd11)
>       deallocate(nd21)
>       deallocate(nd12)
>       deallocate(nd22)
>       deallocate(ifsor)
>       deallocate(nb1s)
>       deallocate(ne1s)
>       deallocate(nb2s)
>       deallocate(ne2s)
>       deallocate(nsubbl)
>       deallocate(idobl)
>       deallocate(nseg)
>       deallocate(idno)
>       deallocate(ijk)
>       deallocate(idseg)
>       deallocate(idnext)
Index: source/splitter/spltsg.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/splitter/spltsg.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
6c6
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
46c46
<          else if (ix1.eq.2) then
---
>          else if (ix1.eq.3) then
Index: source/splitter/tlns3d_to_cfl3d.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/splitter/tlns3d_to_cfl3d.F,v
retrieving revision 1.3
retrieving revision 1.5
diff -r1.3 -r1.5
17c17
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
907a908,956
> c
>          if (ifs.lt.0) then
>             itemp = isva(2,1,nbli)
>             isva(2,1,nbli) = isva(2,2,nbli)
>             isva(2,2,nbli) = itemp
>          end if
> c
> c        check order of side 1 against the order of side 2,
> c        set via isva array
> c
>          irange1 = abs(limblk(1,4,nbli) - limblk(1,1,nbli))
>          irange2 = abs(limblk(2,4,nbli) - limblk(2,1,nbli))
>          jrange1 = abs(limblk(1,5,nbli) - limblk(1,2,nbli))
>          jrange2 = abs(limblk(2,5,nbli) - limblk(2,2,nbli))
>          krange1 = abs(limblk(1,6,nbli) - limblk(1,3,nbli))
>          krange2 = abs(limblk(2,6,nbli) - limblk(2,3,nbli))
>          if (isva(1,1,nbli) .eq. 1) then
>             llrange11 = irange1
>          else if (isva(1,1,nbli) .eq. 2) then
>             llrange11 = jrange1
>          else if (isva(1,1,nbli) .eq. 3) then
>             llrange11 = krange1
>          end if
>          if (isva(1,2,nbli) .eq. 1) then
>             llrange12 = irange1
>          else if (isva(1,2,nbli) .eq. 2) then
>             llrange12 = jrange1
>          else if (isva(1,2,nbli) .eq. 3) then
>             llrange12 = krange1
>          end if
>          if (isva(2,1,nbli) .eq. 1) then
>             llrange21 = irange2
>          else if (isva(2,1,nbli) .eq. 2) then
>             llrange21 = jrange2
>          else if (isva(2,1,nbli) .eq. 3) then
>             llrange21 = krange2
>          end if
>          if (isva(2,2,nbli) .eq. 1) then
>             llrange22 = irange2
>          else if (isva(2,2,nbli) .eq. 2) then
>             llrange22 = jrange2
>          else if (isva(2,2,nbli) .eq. 3) then
>             llrange22 = krange2
>          end if
>          if (llrange11.ne.llrange21 .or. llrange12.ne.llrange22) then
>             itemp = isva(2,1,nbli)
>             isva(2,1,nbli) = isva(2,2,nbli)
>             isva(2,2,nbli) = itemp
>          end if
1499c1548
<       nwrest = 100
---
>       nwrest = 9999
Index: source/tools/Get_FD.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/Get_FD.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
33a34,35
>       write(6,*)'enter 2 to output convergence of all ',
>      .          'force/moment derivatives'
70,85c72,73
<       dimension rms1(ncycarg),clw1(ncycarg),
<      .          cdw1(ncycarg),cdpw1(ncycarg),
<      .          cdvw1(ncycarg),cxw1(ncycarg),
<      .          cyw1(ncycarg),czw1(ncycarg),
<      .          cmxw1(ncycarg),cmyw1(ncycarg),
<      .          cmzw1(ncycarg),fmdotw1(ncycarg),
<      .          cftmomw1(ncycarg),cftpw1(ncycarg),
<      .          cftvw1(ncycarg),cfttotw1(ncycarg)
<       dimension rms2(ncycarg),clw2(ncycarg),
<      .          cdw2(ncycarg),cdpw2(ncycarg),
<      .          cdvw2(ncycarg),cxw2(ncycarg),
<      .          cyw2(ncycarg),czw2(ncycarg),
<      .          cmxw2(ncycarg),cmyw2(ncycarg),
<      .          cmzw2(ncycarg),fmdotw2(ncycarg),
<      .          cftmomw2(ncycarg),cftpw2(ncycarg),
<      .          cftvw2(ncycarg),cfttotw2(ncycarg)
---
>       integer stats
> c
87a76,108
>       allocatable :: cdpw1(:)
>       allocatable :: cdpw2(:)
>       allocatable :: cdvw1(:)
>       allocatable :: cdvw2(:)
>       allocatable :: cdw1(:)
>       allocatable :: cdw2(:)
>       allocatable :: cftmomw1(:)
>       allocatable :: cftmomw2(:)
>       allocatable :: cftpw1(:)
>       allocatable :: cftpw2(:)
>       allocatable :: cfttotw1(:)
>       allocatable :: cfttotw2(:)
>       allocatable :: cftvw1(:)
>       allocatable :: cftvw2(:)
>       allocatable :: clw1(:)
>       allocatable :: clw2(:)
>       allocatable :: cmxw1(:)
>       allocatable :: cmxw2(:)
>       allocatable :: cmyw1(:)
>       allocatable :: cmyw2(:)
>       allocatable :: cmzw1(:)
>       allocatable :: cmzw2(:)
>       allocatable :: cxw1(:)
>       allocatable :: cxw2(:)
>       allocatable :: cyw1(:)
>       allocatable :: cyw2(:)
>       allocatable :: czw1(:)
>       allocatable :: czw2(:)
>       allocatable :: fmdotw1(:)
>       allocatable :: fmdotw2(:)
>       allocatable :: rms1(:)
>       allocatable :: rms2(:)
> c
92,104d112
<       pointer (ip_rms1,rms1),(ip_clw1,clw1),(ip_cdw1,cdw1),
<      .        (ip_cdpw1,cdpw1),(ip_cdvw1,cdvw1),(ip_cxw1,cxw1),
<      .        (ip_cyw1,cyw1),(ip_czw1,czw1),(ip_cmxw1,cmxw1),
<      .        (ip_cmyw1,cmyw1),(ip_cmzw1,cmzw1),(ip_fmdotw1,fmdotw1),
<      .        (ip_cftmomw1,cftmomw1),(ip_cftpw1,cftpw1),
<      .        (ip_cftvw1,cftvw1),(ip_cfttotw1,cfttotw1)
<       pointer (ip_rms2,rms2),(ip_clw2,clw2),(ip_cdw2,cdw2),
<      .        (ip_cdpw2,cdpw2),(ip_cdvw2,cdvw2),(ip_cxw2,cxw2),
<      .        (ip_cyw2,cyw2),(ip_czw2,czw2),(ip_cmxw2,cmxw2),
<      .        (ip_cmyw2,cmyw2),(ip_cmzw2,cmzw2),(ip_fmdotw2,fmdotw2),
<      .        (ip_cftmomw2,cftmomw2),(ip_cftpw2,cftpw2),
<      .        (ip_cftvw2,cftvw2),(ip_cfttotw2,cfttotw2)
< c
125d132
<       icall  = 0
127,158c134,197
<       call umalloc_r(ip_rms1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_clw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cdw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cdpw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cdvw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cxw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cyw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_czw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cmxw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cmyw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cmzw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_fmdotw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cftmomw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cftpw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cftvw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cfttotw1,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_rms2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_clw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cdw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cdpw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cdvw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cxw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cyw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_czw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cmxw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cmyw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cmzw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_fmdotw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cftmomw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cftpw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cftvw2,ncycarg,0,icall,memuse)
<       call umalloc_r(ip_cfttotw2,ncycarg,0,icall,memuse)
---
>       allocate( cdpw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cdpw1',memuse,stats)
>       allocate( cdpw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cdpw2',memuse,stats)
>       allocate( cdvw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cdvw1',memuse,stats)
>       allocate( cdvw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cdvw2',memuse,stats)
>       allocate( cdw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cdw1',memuse,stats)
>       allocate( cdw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cdw2',memuse,stats)
>       allocate( cftmomw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cftmomw1',memuse,stats)
>       allocate( cftmomw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cftmomw2',memuse,stats)
>       allocate( cftpw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cftpw1',memuse,stats)
>       allocate( cftpw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cftpw2',memuse,stats)
>       allocate( cfttotw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cfttotw1',memuse,stats)
>       allocate( cfttotw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cfttotw2',memuse,stats)
>       allocate( cftvw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cftvw1',memuse,stats)
>       allocate( cftvw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cftvw2',memuse,stats)
>       allocate( clw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'clw1',memuse,stats)
>       allocate( clw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'clw2',memuse,stats)
>       allocate( cmxw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cmxw1',memuse,stats)
>       allocate( cmxw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cmxw2',memuse,stats)
>       allocate( cmyw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cmyw1',memuse,stats)
>       allocate( cmyw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cmyw2',memuse,stats)
>       allocate( cmzw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cmzw1',memuse,stats)
>       allocate( cmzw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cmzw2',memuse,stats)
>       allocate( cxw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cxw1',memuse,stats)
>       allocate( cxw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cxw2',memuse,stats)
>       allocate( cyw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cyw1',memuse,stats)
>       allocate( cyw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'cyw2',memuse,stats)
>       allocate( czw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'czw1',memuse,stats)
>       allocate( czw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'czw2',memuse,stats)
>       allocate( fmdotw1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'fmdotw1',memuse,stats)
>       allocate( fmdotw2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'fmdotw2',memuse,stats)
>       allocate( rms1(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'rms1',memuse,stats)
>       allocate( rms2(ncycarg), stat=stats )
>       call umalloc_r(ncycarg,0,'rms2',memuse,stats)
187,194d225
<       write(8,'(''DERIVATIVES VIA CENTRAL DIFFERENCES, '',
<      .          ''WITH STEP SIZE = '',e12.4)') stepsize
<       write(8,'('' '')')
<       write(8,'(''dcl/ddv = '',e13.5)') 
<      .            (clw1(ntr1)-clw2(ntr2))/stepsize/2.
<       write(8,'('' '')')
<       write(8,'(''dcd/ddv = '',e13.5)') 
<      .            (cdw1(ntr1)-cdw2(ntr2))/stepsize/2.
196,206c227,234
<       write(8,'(''dcy/ddv = '',e13.5)') 
<      .            (cyw1(ntr1)-cyw2(ntr2))/stepsize/2.
<       write(8,'('' '')')
<       write(8,'(''dcmy/ddv = '',e13.5)') 
<      .            (cmyw1(ntr1)-cmyw2(ntr2))/stepsize/2.
<       write(8,'('' '')')
<       write(8,'(''dcz/ddv = '',e13.5)')
<      .            (czw1(ntr1)-czw2(ntr2))/stepsize/2.
<       write(8,'('' '')')
<       write(8,'(''dcmz/ddv = '',e13.5)')
<      .            (cmzw1(ntr1)-cmzw2(ntr2))/stepsize/2.
---
>       write(8,'(''***********************************************'',
>      .  ''********************************'')')
>       write(8,'(''                     derivatives via central '',
>      . ''differences '')')
>       write(8,'(''                        with step size = '',
>      . e12.5)') stepsize
>       write(8,'(''***********************************************'',
>      .  ''********************************'')')
207a236,250
>       write(8,2) (titlw(i),i=1,20)
>     2 format(20a4)
>       write(8,'('' Mach='',e12.4,'', alpha='',e12.4,
>      . '', ReUe='',e12.4)') xmachw,alphw,reuew
>       write(8,'('' Final d/d() of cl,cd       ='',2e13.5)')
>      .          (clw1(ntr1)-clw2(ntr2))/stepsize/2.,
>      .          (cdw1(ntr1)-cdw2(ntr2))/stepsize/2.
>       write(8,'('' Final d/d() of cx,cy,cz    ='',3e13.5)')
>      .          (cxw1(ntr1)-cxw2(ntr2))/stepsize/2.,
>      .          (cyw1(ntr1)-cyw2(ntr2))/stepsize/2.,
>      .          (czw1(ntr1)-czw2(ntr2))/stepsize/2.
>       write(8,'('' Final d/d() of cmx,cmy,cmz ='',3e13.5)')
>      .          (cmxw1(ntr1)-cmxw2(ntr2))/stepsize/2.,
>      .          (cmyw1(ntr1)-cmyw2(ntr2))/stepsize/2.,
>      .          (cmzw1(ntr1)-cmzw2(ntr2))/stepsize/2. 
212,213d254
<       write(8,'(''derivative convergence history'')')
<       write(8,'('' '')')
217c258
<       else
---
>       else if (ialph.eq.0) then
219a261,265
>       else
>          write(8,'(''    it     residual    d(cl)/d()'',
>      .   ''    d(cd)/d()    d(cx)/d()    d(cy)/d()    d(cz)/d()'',
>      .   ''   d(cmx)/d()   d(cmy)/d()   d(cmz)/d()'')')
>          write(8,'('' '')')
233c279
<       else
---
>       else if (ialph.eq.1) then
240a287,298
>       else
>          do n=1,ntr1
>             write(8,'(i6,9e13.5)') n,1.,
>      .                             (clw1(n)-clw2(n))/stepsize/2.,
>      .                             (cdw1(n)-cdw2(n))/stepsize/2.,
>      .                             (cxw1(n)-cxw2(n))/stepsize/2.,
>      .                             (cyw1(n)-cyw2(n))/stepsize/2.,
>      .                             (czw1(n)-czw2(n))/stepsize/2.,
>      .                             (cmxw1(n)-cmxw2(n))/stepsize/2.,
>      .                             (cmyw1(n)-cmyw2(n))/stepsize/2.,
>      .                             (cmzw1(n)-cmzw2(n))/stepsize/2.
>         end do
245,276c303,334
<       call ufree_r(ip_rms1)
<       call ufree_r(ip_clw1)
<       call ufree_r(ip_cdw1)
<       call ufree_r(ip_cdpw1)
<       call ufree_r(ip_cdvw1)
<       call ufree_r(ip_cxw1)
<       call ufree_r(ip_cyw1)
<       call ufree_r(ip_czw1)
<       call ufree_r(ip_cmxw1)
<       call ufree_r(ip_cmyw1)
<       call ufree_r(ip_cmzw1)
<       call ufree_r(ip_fmdotw1)
<       call ufree_r(ip_cftmomw1)
<       call ufree_r(ip_cftpw1)
<       call ufree_r(ip_cftvw1)
<       call ufree_r(ip_cfttotw1)
<       call ufree_r(ip_rms2)
<       call ufree_r(ip_clw2)
<       call ufree_r(ip_cdw2)
<       call ufree_r(ip_cdpw2)
<       call ufree_r(ip_cdvw2)
<       call ufree_r(ip_cxw2)
<       call ufree_r(ip_cyw2)
<       call ufree_r(ip_czw2)
<       call ufree_r(ip_cmxw2)
<       call ufree_r(ip_cmyw2)
<       call ufree_r(ip_cmzw2)
<       call ufree_r(ip_fmdotw2)
<       call ufree_r(ip_cftmomw2)
<       call ufree_r(ip_cftpw2)
<       call ufree_r(ip_cftvw2)
<       call ufree_r(ip_cfttotw2)
---
>       deallocate(rms1)
>       deallocate(clw1)
>       deallocate(cdw1)
>       deallocate(cdpw1)
>       deallocate(cdvw1)
>       deallocate(cxw1)
>       deallocate(cyw1)
>       deallocate(czw1)
>       deallocate(cmxw1)
>       deallocate(cmyw1)
>       deallocate(cmzw1)
>       deallocate(fmdotw1)
>       deallocate(cftmomw1)
>       deallocate(cftpw1)
>       deallocate(cftvw1)
>       deallocate(cfttotw1)
>       deallocate(rms2)
>       deallocate(clw2)
>       deallocate(cdw2)
>       deallocate(cdpw2)
>       deallocate(cdvw2)
>       deallocate(cxw2)
>       deallocate(cyw2)
>       deallocate(czw2)
>       deallocate(cmxw2)
>       deallocate(cmyw2)
>       deallocate(cmzw2)
>       deallocate(fmdotw2)
>       deallocate(cftmomw2)
>       deallocate(cftpw2)
>       deallocate(cftvw2)
>       deallocate(cfttotw2)
Index: source/tools/INGRID_to_p3d.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/INGRID_to_p3d.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
114,115c114
<       dimension jdim(maxbl),kdim(maxbl),ldim(maxbl),iphntm(maxbl)
<       dimension x(jmax,kmax,lmax),y(jmax,kmax,lmax),z(jmax,kmax,lmax)
---
>       integer stats
117,118c116,122
<       pointer (ip_x,x),(ip_y,y),(ip_z,z),(ip_ldim,ldim),(ip_jdim,jdim),
<      .        (ip_kdim,kdim),(ip_iphntm,iphntm)
---
>       allocatable :: iphntm(:)
>       allocatable :: jdim(:)
>       allocatable :: kdim(:)
>       allocatable :: ldim(:)
>       allocatable :: x(:,:,:)
>       allocatable :: y(:,:,:)
>       allocatable :: z(:,:,:)
122d125
<       icall  = 0
124,130c127,140
<       call umalloc_r(ip_x,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_y,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_z,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_ldim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_jdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_kdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_iphntm,maxbl,1,icall,memuse)
---
>       allocate( iphntm(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'iphntm',memuse,stats)
>       allocate( jdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jdim',memuse,stats)
>       allocate( kdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'kdim',memuse,stats)
>       allocate( ldim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'ldim',memuse,stats)
>       allocate( x(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,0,'x',memuse,stats)
>       allocate( y(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,0,'y',memuse,stats)
>       allocate( z(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,0,'z',memuse,stats)
249,254c259,264
<          call ufree_r(ip_x)
<          call ufree_r(ip_y)
<          call ufree_r(ip_z)
<          call ufree_r(ip_ldim)
<          call ufree_r(ip_jdim)
<          call ufree_r(ip_kdim)
---
>          deallocate(x)
>          deallocate(y)
>          deallocate(z)
>          deallocate(ldim)
>          deallocate(jdim)
>          deallocate(kdim)
Index: source/tools/XINTOUT_to_ovrlp.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/XINTOUT_to_ovrlp.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
208,209c208
<       dimension ldim(maxbl),jdim(maxbl),kdim(maxbl),iisptr(maxbl),
<      .          iieptr(maxbl)
---
>       integer stats
211,212c210,241
<       dimension x(jmax,kmax,lmax),y(jmax,kmax,lmax),
<      .          z(jmax,kmax,lmax)
---
>       dimension iieptr(maxbl)
>       dimension iisptr(maxbl)
>       dimension jdim(maxbl)
>       dimension kdim(maxbl)
>       dimension ldim(maxbl)
> c
>       allocatable :: dj(:)
>       allocatable :: dk(:)
>       allocatable :: dl(:)
>       allocatable :: ibblk(:)
>       allocatable :: ibc(:)
>       allocatable :: ibeptr(:)
>       allocatable :: iblank(:,:,:)
>       allocatable :: ibpnts(:)
>       allocatable :: ibsptr(:)
>       allocatable :: igorph(:)
>       allocatable :: iiblk(:)
>       allocatable :: iipnts(:)
>       allocatable :: intpts(:,:)
>       allocatable :: jb(:)
>       allocatable :: jborph(:)
>       allocatable :: ji(:)
>       allocatable :: kb(:)
>       allocatable :: kborph(:)
>       allocatable :: ki(:)
>       allocatable :: lb(:)
>       allocatable :: lborph(:)
>       allocatable :: li(:)
>       allocatable :: norph(:)
>       allocatable :: x(:,:,:)
>       allocatable :: y(:,:,:)
>       allocatable :: z(:,:,:)
214,234c243
< c     for input pegsus data
< c
<       dimension ibpnts(maxbl),iipnts(maxbl),ji(iitot),ki(iitot),
<      .          li(iitot),jb(iitot),kb(iitot),lb(iitot),ibc(iitot),
<      .          iblank(jmax,kmax,lmax)
<       dimension dj(iitot),dk(iitot),dl(iitot)
<       dimension ibeptr(maxbl),ibsptr(maxbl),iiblk(iitot),
<      .          ibblk(iitot)
<       dimension lborph(iitot),jborph(iitot),kborph(iitot)
<       dimension igorph(iitot),norph(maxbl)
<       dimension intpts(maxbl,4)
< c
<       pointer (ip_x,x),(ip_y,y),(ip_z,z)
<       pointer (ip_ibpnts,ibpnts),(ip_iipnts,iipnts),
<      .        (ip_ji,ji),(ip_ki,ki),(ip_li,li),(ip_jb,jb),
<      .        (ip_kb,kb),(ip_lb,lb),(ip_ibc,ibc),
<      .        (ip_iblank,iblank),(ip_dj,dj),(ip_dk,dk),
<      .        (ip_dl,dl),(ip_ibeptr,ibeptr),(ip_ibsptr,ibsptr),
<      .        (ip_iiblk,iiblk),(ip_ibblk,ibblk)
<       pointer (ip_lborph,lborph),(ip_jborph,jborph),(ip_kborph,kborph),
<      .        (ip_igorph,igorph),(ip_norph,norph),(ip_intpts,intpts)
---
>       character*80 header
240d248
<       icall  = 0
242,267c250,301
<       call umalloc_r(ip_x,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_y,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_z,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_ibpnts,maxbl,1,icall,memuse)
<       call umalloc_r(ip_iipnts,maxbl,1,icall,memuse)
<       call umalloc_r(ip_ji,iitot,1,icall,memuse)
<       call umalloc_r(ip_ki,iitot,1,icall,memuse)
<       call umalloc_r(ip_li,iitot,1,icall,memuse)
<       call umalloc_r(ip_jb,iitot,1,icall,memuse)
<       call umalloc_r(ip_kb,iitot,1,icall,memuse)
<       call umalloc_r(ip_lb,iitot,1,icall,memuse)
<       call umalloc_r(ip_ibc,iitot,1,icall,memuse)
<       call umalloc_r(ip_iblank,lmax*jmax*kmax,1,icall,memuse)
<       call umalloc_r(ip_dj,iitot,0,icall,memuse)
<       call umalloc_r(ip_dk,iitot,0,icall,memuse)
<       call umalloc_r(ip_dl,iitot,0,icall,memuse)
<       call umalloc_r(ip_ibeptr,maxbl,1,icall,memuse)
<       call umalloc_r(ip_ibsptr,maxbl,1,icall,memuse)
<       call umalloc_r(ip_iiblk,iitot,1,icall,memuse)
<       call umalloc_r(ip_ibblk,iitot,1,icall,memuse)
<       call umalloc_r(ip_lborph,iitot,1,icall,memuse)
<       call umalloc_r(ip_jborph,iitot,1,icall,memuse)
<       call umalloc_r(ip_kborph,iitot,1,icall,memuse)
<       call umalloc_r(ip_igorph,iitot,1,icall,memuse)
<       call umalloc_r(ip_norph,maxbl,1,icall,memuse)
<       call umalloc_r(ip_intpts,maxbl*4,1,icall,memuse)
---
>       allocate( dj(iitot), stat=stats )
>       call umalloc_r(iitot,0,'dj',memuse,stats)
>       allocate( dk(iitot), stat=stats )
>       call umalloc_r(iitot,0,'dk',memuse,stats)
>       allocate( dl(iitot), stat=stats )
>       call umalloc_r(iitot,0,'dl',memuse,stats)
>       allocate( ibblk(iitot), stat=stats )
>       call umalloc_r(iitot,1,'ibblk',memuse,stats)
>       allocate( ibc(iitot), stat=stats )
>       call umalloc_r(iitot,1,'ibc',memuse,stats)
>       allocate( ibeptr(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'ibeptr',memuse,stats)
>       allocate( iblank(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,1,'iblank',memuse,stats)
>       allocate( ibpnts(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'ibpnts',memuse,stats)
>       allocate( ibsptr(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'ibsptr',memuse,stats)
>       allocate( igorph(iitot), stat=stats )
>       call umalloc_r(iitot,1,'igorph',memuse,stats)
>       allocate( iiblk(iitot), stat=stats )
>       call umalloc_r(iitot,1,'iiblk',memuse,stats)
>       allocate( iipnts(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'iipnts',memuse,stats)
>       allocate( intpts(maxbl,4), stat=stats )
>       call umalloc_r(maxbl*4,1,'intpts',memuse,stats)
>       allocate( jb(iitot), stat=stats )
>       call umalloc_r(iitot,1,'jb',memuse,stats)
>       allocate( jborph(iitot), stat=stats )
>       call umalloc_r(iitot,1,'jborph',memuse,stats)
>       allocate( ji(iitot), stat=stats )
>       call umalloc_r(iitot,1,'ji',memuse,stats)
>       allocate( kb(iitot), stat=stats )
>       call umalloc_r(iitot,1,'kb',memuse,stats)
>       allocate( kborph(iitot), stat=stats )
>       call umalloc_r(iitot,1,'kborph',memuse,stats)
>       allocate( ki(iitot), stat=stats )
>       call umalloc_r(iitot,1,'ki',memuse,stats)
>       allocate( lb(iitot), stat=stats )
>       call umalloc_r(iitot,1,'lb',memuse,stats)
>       allocate( lborph(iitot), stat=stats )
>       call umalloc_r(iitot,1,'lborph',memuse,stats)
>       allocate( li(iitot), stat=stats )
>       call umalloc_r(iitot,1,'li',memuse,stats)
>       allocate( norph(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'norph',memuse,stats)
>       allocate( x(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,0,'x',memuse,stats)
>       allocate( y(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,0,'y',memuse,stats)
>       allocate( z(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,0,'z',memuse,stats)
332,340c366,416
<          if (ig .eq. 1) then
<             norpht0 = 0
<             do n=1,iitot
<                read(8,*,end=888) igorph(n),jborph(n),kborph(n),
<      .                           lborph(n)
<                norpht0 = norpht0 + 1
<                norph(igorph(n)) = norph(igorph(n)) + 1
<             end do
<  888        continue
---
>          if (ipeg.eq.4) then
>             if (ig .eq. 1) then
>                norpht0 = 0
>                do n=1,iitot
>                   read(8,*,end=888) igorph(n),jborph(n),kborph(n),
>      .                              lborph(n)
>                   norpht0 = norpht0 + 1
>                   norph(igorph(n)) = norph(igorph(n)) + 1
>                end do
>  888           continue
>          end if
>          else
>             if (ig .eq. 1) then
>                istop = 1
>                norpht0 = 0
>                do ng=1,ngrid
>                   norph(ng) = 0
>                   read(8,'(a60)',end=7777) header
>                   istop = 0
>                   read(8,'(a60)') header
>                   read(8,'(a60)') header
>                   read(8,'(a60)') header
>                   read(8,'(a60)',end=777) header
>                   backspace 8
>                   if (header.eq.'                    ') then
>                      go to 77
>                   end if
>                   do n = 1,iitot
>                      read(8,'(a60)',end=777) header
>                      backspace 8
>                      if (header.ne.'                    ') then
>                         norpht0 = norpht0 + 1
>                         read(8,*) idum,jborph(norpht0),kborph(norpht0),
>      .                            lborph(norpht0)
>                         igorph(norpht0) = ng
>                         norph(ng) = norph(ng) + 1
>                      else
>                         go to 77
>                      end if
>                   end do
>   77              continue
>                end do
>  777           continue
> 7777           continue
>                if (istop .ne. 0) then
>                   write(6,'(''ORPHAN file is empty...you must run '',
>      .                      ''peg_orph'',/,''choose option 4, then '',
>      .                      ''option 2, and name the file ORPHAN'')')
>                   stop
>                end if
>             end if
616c692
<      .              i2d,ipeg)
---
>      .              i2d,ipeg,maxbl)
624,649c700,725
<          call ufree_r(ip_x)
<          call ufree_r(ip_y)
<          call ufree_r(ip_z)
<          call ufree_r(ip_ibpnts)
<          call ufree_r(ip_iipnts)
<          call ufree_r(ip_ji)
<          call ufree_r(ip_ki)
<          call ufree_r(ip_li)
<          call ufree_r(ip_jb)
<          call ufree_r(ip_kb)
<          call ufree_r(ip_lb)
<          call ufree_r(ip_ibc)
<          call ufree_r(ip_iblank)
<          call ufree_r(ip_dj)
<          call ufree_r(ip_dk)
<          call ufree_r(ip_dl)
<          call ufree_r(ip_ibeptr)
<          call ufree_r(ip_ibsptr)
<          call ufree_r(ip_iiblk)
<          call ufree_r(ip_ibblk)
<          call ufree_r(ip_lborph)
<          call ufree_r(ip_jborph)
<          call ufree_r(ip_kborph)
<          call ufree_r(ip_igorph)
<          call ufree_r(ip_norph)
<          call ufree_r(ip_intpts)
---
>          deallocate(x)
>          deallocate(y)
>          deallocate(z)
>          deallocate(ibpnts)
>          deallocate(iipnts)
>          deallocate(ji)
>          deallocate(ki)
>          deallocate(li)
>          deallocate(jb)
>          deallocate(kb)
>          deallocate(lb)
>          deallocate(ibc)
>          deallocate(iblank)
>          deallocate(dj)
>          deallocate(dk)
>          deallocate(dl)
>          deallocate(ibeptr)
>          deallocate(ibsptr)
>          deallocate(iiblk)
>          deallocate(ibblk)
>          deallocate(lborph)
>          deallocate(jborph)
>          deallocate(kborph)
>          deallocate(igorph)
>          deallocate(norph)
>          deallocate(intpts)
926,929c1002,1003
<       dimension x(jmax,kmax,lmax),y(jmax,kmax,lmax),
<      .          z(jmax,kmax,lmax)
<       real*4    xout(jmax,kmax,lmax),yout(jmax,kmax,lmax),
<      .          zout(jmax,kmax,lmax)
---
>       integer stats
> c
931c1005,1011
<       pointer (ip_xout,xout),(ip_yout,yout),(ip_zout,zout)
---
>       dimension x(jmax,kmax,lmax)
>       dimension y(jmax,kmax,lmax)
>       dimension z(jmax,kmax,lmax)
> c
>       real(4), allocatable :: xout(:,:,:)
>       real(4), allocatable :: yout(:,:,:)
>       real(4), allocatable :: zout(:,:,:)
933d1012
<       icall  = 0
935,937c1014,1019
<       call umalloc_r(ip_xout,lmax*jmax*kmax,-1,icall,memuse)
<       call umalloc_r(ip_yout,lmax*jmax*kmax,-1,icall,memuse)
<       call umalloc_r(ip_zout,lmax*jmax*kmax,-1,icall,memuse)
---
>       allocate( xout(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,-1,'xout',memuse,stats)
>       allocate( yout(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,-1,'yout',memuse,stats)
>       allocate( zout(jmax,kmax,lmax), stat=stats )
>       call umalloc_r(jmax*kmax*lmax,-1,'zout',memuse,stats)
967,969c1049,1051
<       call ufree_r(ip_xout)
<       call ufree_r(ip_yout)
<       call ufree_r(ip_zout)
---
>       deallocate(xout)
>       deallocate(yout)
>       deallocate(zout)
976c1058,1060
<      .                 lunit,nppblk,i2d,ipeg)
---
>      .                 lunit,nppblk,i2d,ipeg,maxbl)
> c
>       integer stats
978,985c1062,1077
<       dimension xin(jmax,kmax,lmax),yin(jmax,kmax,lmax),
<      .          zin(jmax,kmax,lmax)
<       dimension lborph(*),jborph(*),kborph(*),igorph(*),norph(*)
<       dimension idim(nbmax),jdim(nbmax),kdim(nbmax),ldim(nbmax)
<       real*4    xout(lomax),yout(lomax),zout(lomax)
<       pointer (ip_xout,xout),(ip_yout,yout),(ip_zout,zout)
<       pointer (ip_idim,idim),(ip_jdim,jdim),(ip_kdim,kdim),
<      .        (ip_ldim,ldim)
---
>       dimension igorph(*)
>       dimension jborph(*)
>       dimension kborph(*)
>       dimension lborph(*)
>       dimension norph(*)
>       dimension xin(jmax,kmax,lmax)
>       dimension yin(jmax,kmax,lmax)
>       dimension zin(jmax,kmax,lmax)
> c
>       allocatable :: idim(:)
>       allocatable :: jdim(:)
>       allocatable :: kdim(:)
>       allocatable :: ldim(:)
>       real(4), allocatable :: xout(:)
>       real(4), allocatable :: yout(:)
>       real(4), allocatable :: zout(:)
987d1078
<       icall  = 0
989,995c1080,1093
<       call umalloc_r(ip_xout,lomax,-1,icall,memuse)
<       call umalloc_r(ip_yout,lomax,-1,icall,memuse)
<       call umalloc_r(ip_zout,lomax,-1,icall,memuse)
<       call umalloc_r(ip_idim,nbmax, 1,icall,memuse)
<       call umalloc_r(ip_jdim,nbmax, 1,icall,memuse)
<       call umalloc_r(ip_kdim,nbmax, 1,icall,memuse)
<       call umalloc_r(ip_ldim,nbmax, 1,icall,memuse)
---
>       allocate( idim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'idim',memuse,stats)
>       allocate( jdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jdim',memuse,stats)
>       allocate( kdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'kdim',memuse,stats)
>       allocate( ldim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'ldim',memuse,stats)
>       allocate( xout(lomax), stat=stats )
>       call umalloc_r(lomax,-1,'xout',memuse,stats)
>       allocate( yout(lomax), stat=stats )
>       call umalloc_r(lomax,-1,'yout',memuse,stats)
>       allocate( zout(lomax), stat=stats )
>       call umalloc_r(lomax,-1,'zout',memuse,stats)
1016c1114
<      .                      '' contains orphans from grid'',i3,
---
>      .                      '' contains orphans from grid'',i3
1100,1106c1198,1204
<       call ufree_r(ip_xout)
<       call ufree_r(ip_yout)
<       call ufree_r(ip_zout)
<       call ufree_r(ip_idim)
<       call ufree_r(ip_jdim)
<       call ufree_r(ip_kdim)
<       call ufree_r(ip_ldim)
---
>       deallocate(xout)
>       deallocate(yout)
>       deallocate(zout)
>       deallocate(idim)
>       deallocate(jdim)
>       deallocate(kdim)
>       deallocate(ldim)
Index: source/tools/cfl3d_to_pegbc.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/cfl3d_to_pegbc.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
166a167,168
>       integer stats
> c
168,199c170,204
<       dimension nbci0(maxbl),nbcidim(maxbl),nbcj0(maxbl),
<      .          nbcjdim(maxbl),nbck0(maxbl),nbckdim(maxbl),
<      .          jbcinfo(maxbl,maxseg,7,2),ibcinfo(maxbl,maxseg,7,2),
<      .          kbcinfo(maxbl,maxseg,7,2),jdimg(maxbl),kdimg(maxbl),
<      .          ldimg(maxbl),igridg(maxbl),levelg(maxbl)
<       dimension isym(maxbl),itype(maxseg*6+2*mxbli+intmax),
<      .          idir(maxseg*6+2*mxbli+intmax),
<      .          jbcs(maxseg*6+2*mxbli+intmax),
<      .          jbce(maxseg*6+2*mxbli+intmax),
<      .          kbcs(maxseg*6+2*mxbli+intmax),
<      .          kbce(maxseg*6+2*mxbli+intmax),
<      .          lbcs(maxseg*6+2*mxbli+intmax),
<      .          lbce(maxseg*6+2*mxbli+intmax)
<       dimension nblk(2,mxbli),limblk(2,6,mxbli),
<      .          isva(2,2,mxbli),nblon(mxbli),iovrlp(maxbl)
<       dimension nbl_to(intmax),nm_to(intmax),jxie_s(intmax),
<      .          jxie_e(intmax),keta_s(intmax),keta_e(intmax)
< c
<       pointer (ip_nbci0,nbci0),(ip_nbcidim,nbcidim),(ip_nbcj0,nbcj0),
<      .         (ip_nbcjdim,nbcjdim),(ip_nbck0,nbck0),
<      .         (ip_nbckdim,nbckdim),(ip_jbcinfo,jbcinfo),
<      .         (ip_ibcinfo,ibcinfo),(ip_kbcinfo,kbcinfo),
<      .         (ip_jdimg,jdimg),(ip_kdimg,kdimg),(ip_ldimg,ldimg),
<      .         (ip_nblk,nblk),(ip_limblk,limblk),(ip_isva,isva),
<      .         (ip_nblon,nblon),(ip_iovrlp,iovrlp),(ip_igridg,igridg),
<      .         (ip_levelg,levelg)
<       pointer  (ip_nbl_to,nbl_to),(ip_nm_to,nm_to),(ip_jxie_s,jxie_s),
<      .         (ip_jxie_e,jxie_e),(ip_keta_s,keta_s),(ip_keta_e,keta_e)
<       pointer  (ip_isym,isym),(ip_itype,itype),(ip_idir,idir),
<      .         (ip_jbcs,jbcs),(ip_jbce,jbce),
<      .         (ip_kbcs,kbcs),(ip_kbce,kbce),
<      .         (ip_lbcs,lbcs),(ip_lbce,lbce)
---
> c
>       allocatable :: ibcinfo(:,:,:,:)
>       allocatable :: idir(:)
>       allocatable :: igridg(:)
>       allocatable :: iovrlp(:)
>       allocatable :: isva(:,:,:)
>       allocatable :: isym(:)
>       allocatable :: itype(:)
>       allocatable :: jbce(:)
>       allocatable :: jbcinfo(:,:,:,:)
>       allocatable :: jbcs(:)
>       allocatable :: jdimg(:)
>       allocatable :: jxie_e(:)
>       allocatable :: jxie_s(:)
>       allocatable :: kbce(:)
>       allocatable :: kbcinfo(:,:,:,:)
>       allocatable :: kbcs(:)
>       allocatable :: kdimg(:)
>       allocatable :: keta_e(:)
>       allocatable :: keta_s(:)
>       allocatable :: lbce(:)
>       allocatable :: lbcs(:)
>       allocatable :: ldimg(:)
>       allocatable :: levelg(:)
>       allocatable :: limblk(:,:,:)
>       allocatable :: nbci0(:)
>       allocatable :: nbcidim(:)
>       allocatable :: nbcj0(:)
>       allocatable :: nbcjdim(:)
>       allocatable :: nbck0(:)
>       allocatable :: nbckdim(:)
>       allocatable :: nbl_to(:)
>       allocatable :: nblk(:,:)
>       allocatable :: nblon(:)
>       allocatable :: nm_to(:)
205d209
<       icall  = 0
207,240c211,278
<       call umalloc_r(ip_jdimg,maxbl,1,icall,memuse)
<       call umalloc_r(ip_kdimg,maxbl,1,icall,memuse)
<       call umalloc_r(ip_ldimg,maxbl,1,icall,memuse)
<       call umalloc_r(ip_nbci0,maxbl,1,icall,memuse)
<       call umalloc_r(ip_nbcj0,maxbl,1,icall,memuse)
<       call umalloc_r(ip_nbck0,maxbl,1,icall,memuse)
<       call umalloc_r(ip_nbcidim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_nbcjdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_nbckdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_ibcinfo,14*maxseg*maxbl,1,icall,memuse)
<       call umalloc_r(ip_jbcinfo,14*maxseg*maxbl,1,icall,memuse)
<       call umalloc_r(ip_kbcinfo,14*maxseg*maxbl,1,icall,memuse)
<       call umalloc_r(ip_nblk,2*mxbli,1,icall,memuse)
<       call umalloc_r(ip_limblk,12*mxbli,1,icall,memuse)
<       call umalloc_r(ip_isva,4*mxbli,1,icall,memuse)
<       call umalloc_r(ip_nblon,mxbli,1,icall,memuse)
<       call umalloc_r(ip_iovrlp,maxbl,1,icall,memuse)
<       call umalloc_r(ip_isym,maxbl,1,icall,memuse)
<       call umalloc_r(ip_itype,maxseg*6+2*mxbli+intmax,1,icall,memuse)
<       call umalloc_r(ip_idir,maxseg*6+2*mxbli+intmax,1,icall,memuse)
<       call umalloc_r(ip_jbcs,maxseg*6+2*mxbli+intmax,1,icall,memuse)
<       call umalloc_r(ip_jbce,maxseg*6+2*mxbli+intmax,1,icall,memuse)
<       call umalloc_r(ip_kbcs,maxseg*6+2*mxbli+intmax,1,icall,memuse)
<       call umalloc_r(ip_kbce,maxseg*6+2*mxbli+intmax,1,icall,memuse)
<       call umalloc_r(ip_lbcs,maxseg*6+2*mxbli+intmax,1,icall,memuse)
<       call umalloc_r(ip_lbce,maxseg*6+2*mxbli+intmax,1,icall,memuse)
<       call umalloc_r(ip_nbl_to,intmax,1,icall,memuse)
<       call umalloc_r(ip_nm_to,intmax,1,icall,memuse)
<       call umalloc_r(ip_jxie_s,intmax,1,icall,memuse)
<       call umalloc_r(ip_jxie_e,intmax,1,icall,memuse)
<       call umalloc_r(ip_keta_s,intmax,1,icall,memuse)
<       call umalloc_r(ip_keta_e,intmax,1,icall,memuse)
<       call umalloc_r(ip_igridg,maxbl,1,icall,memuse)
<       call umalloc_r(ip_levelg,maxbl,1,icall,memuse)
---
>       allocate( ibcinfo(maxbl,maxseg,7,2), stat=stats )
>       call umalloc_r(maxbl*maxseg*7*2,1,'ibcinfo',memuse,stats)
>       allocate( idir(maxseg*6+2*mxbli+intmax), stat=stats )
>       call umalloc_r((maxseg*6+2*mxbli+intmax),1,'idir',memuse,stats)
>       allocate( igridg(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'igridg',memuse,stats)
>       allocate( iovrlp(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'iovrlp',memuse,stats)
>       allocate( isva(2,2,mxbli), stat=stats )
>       call umalloc_r(2*2*mxbli,1,'isva',memuse,stats)
>       allocate( isym(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'isym',memuse,stats)
>       allocate( itype(maxseg*6+2*mxbli+intmax), stat=stats )
>       call umalloc_r((maxseg*6+2*mxbli+intmax),1,'itype',memuse,stats)
>       allocate( jbce(maxseg*6+2*mxbli+intmax), stat=stats )
>       call umalloc_r((maxseg*6+2*mxbli+intmax),1,'jbce',memuse,stats)
>       allocate( jbcinfo(maxbl,maxseg,7,2), stat=stats )
>       call umalloc_r(maxbl*maxseg*7*2,1,'jbcinfo',memuse,stats)
>       allocate( jbcs(maxseg*6+2*mxbli+intmax), stat=stats )
>       call umalloc_r((maxseg*6+2*mxbli+intmax),1,'jbcs',memuse,stats)
>       allocate( jdimg(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jdimg',memuse,stats)
>       allocate( jxie_e(intmax), stat=stats )
>       call umalloc_r(intmax,1,'jxie_e',memuse,stats)
>       allocate( jxie_s(intmax), stat=stats )
>       call umalloc_r(intmax,1,'jxie_s',memuse,stats)
>       allocate( kbce(maxseg*6+2*mxbli+intmax), stat=stats )
>       call umalloc_r((maxseg*6+2*mxbli+intmax),1,'kbce',memuse,stats)
>       allocate( kbcinfo(maxbl,maxseg,7,2), stat=stats )
>       call umalloc_r(maxbl*maxseg*7*2,1,'kbcinfo',memuse,stats)
>       allocate( kbcs(maxseg*6+2*mxbli+intmax), stat=stats )
>       call umalloc_r((maxseg*6+2*mxbli+intmax),1,'kbcs',memuse,stats)
>       allocate( kdimg(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'kdimg',memuse,stats)
>       allocate( keta_e(intmax), stat=stats )
>       call umalloc_r(intmax,1,'keta_e',memuse,stats)
>       allocate( keta_s(intmax), stat=stats )
>       call umalloc_r(intmax,1,'keta_s',memuse,stats)
>       allocate( lbce(maxseg*6+2*mxbli+intmax), stat=stats )
>       call umalloc_r((maxseg*6+2*mxbli+intmax),1,'lbce',memuse,stats)
>       allocate( lbcs(maxseg*6+2*mxbli+intmax), stat=stats )
>       call umalloc_r((maxseg*6+2*mxbli+intmax),1,'lbcs',memuse,stats)
>       allocate( ldimg(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'ldimg',memuse,stats)
>       allocate( levelg(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'levelg',memuse,stats)
>       allocate( limblk(2,6,mxbli), stat=stats )
>       call umalloc_r(2*6*mxbli,1,'limblk',memuse,stats)
>       allocate( nbci0(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'nbci0',memuse,stats)
>       allocate( nbcidim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'nbcidim',memuse,stats)
>       allocate( nbcj0(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'nbcj0',memuse,stats)
>       allocate( nbcjdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'nbcjdim',memuse,stats)
>       allocate( nbck0(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'nbck0',memuse,stats)
>       allocate( nbckdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'nbckdim',memuse,stats)
>       allocate( nbl_to(intmax), stat=stats )
>       call umalloc_r(intmax,1,'nbl_to',memuse,stats)
>       allocate( nblk(2,mxbli), stat=stats )
>       call umalloc_r(2*mxbli,1,'nblk',memuse,stats)
>       allocate( nblon(mxbli), stat=stats )
>       call umalloc_r(mxbli,1,'nblon',memuse,stats)
>       allocate( nm_to(intmax), stat=stats )
>       call umalloc_r(intmax,1,'nm_to',memuse,stats)
843,876c881,914
<       call ufree_r(ip_jdimg)
<       call ufree_r(ip_kdimg)
<       call ufree_r(ip_ldimg)
<       call ufree_r(ip_nbci0)
<       call ufree_r(ip_nbcj0)
<       call ufree_r(ip_nbck0)
<       call ufree_r(ip_nbcidim)
<       call ufree_r(ip_nbcjdim)
<       call ufree_r(ip_nbckdim)
<       call ufree_r(ip_ibcinfo)
<       call ufree_r(ip_jbcinfo)
<       call ufree_r(ip_kbcinfo)
<       call ufree_r(ip_nblk)
<       call ufree_r(ip_limblk)
<       call ufree_r(ip_isva)
<       call ufree_r(ip_nblon)
<       call ufree_r(ip_iovrlp)
<       call ufree_r(ip_isym)
<       call ufree_r(ip_itype)
<       call ufree_r(ip_idir)
<       call ufree_r(ip_jbcs)
<       call ufree_r(ip_jbce)
<       call ufree_r(ip_kbcs)
<       call ufree_r(ip_kbce)
<       call ufree_r(ip_lbcs)
<       call ufree_r(ip_lbce)
<       call ufree_r(ip_nbl_to)
<       call ufree_r(ip_nm_to)
<       call ufree_r(ip_jxie_s)
<       call ufree_r(ip_jxie_e)
<       call ufree_r(ip_keta_s)
<       call ufree_r(ip_keta_e)
<       call ufree_r(ip_igridg)
<       call ufree_r(ip_levelg)
---
>       deallocate(jdimg)
>       deallocate(kdimg)
>       deallocate(ldimg)
>       deallocate(nbci0)
>       deallocate(nbcj0)
>       deallocate(nbck0)
>       deallocate(nbcidim)
>       deallocate(nbcjdim)
>       deallocate(nbckdim)
>       deallocate(ibcinfo)
>       deallocate(jbcinfo)
>       deallocate(kbcinfo)
>       deallocate(nblk)
>       deallocate(limblk)
>       deallocate(isva)
>       deallocate(nblon)
>       deallocate(iovrlp)
>       deallocate(isym)
>       deallocate(itype)
>       deallocate(idir)
>       deallocate(jbcs)
>       deallocate(jbce)
>       deallocate(kbcs)
>       deallocate(kbce)
>       deallocate(lbcs)
>       deallocate(lbce)
>       deallocate(nbl_to)
>       deallocate(nm_to)
>       deallocate(jxie_s)
>       deallocate(jxie_e)
>       deallocate(keta_s)
>       deallocate(keta_e)
>       deallocate(igridg)
>       deallocate(levelg)
Index: source/tools/everyother_xyz.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/everyother_xyz.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
11c11
< c     f90 -64 -r8 everyother_xyz.f umalloc_r.o ufree_r.o -o everyother_xyz
---
> c     f90 -64 -r8 everyother_xyz.f umalloc_r.o -o everyother_xyz
158,160c158
<       dimension idim(nbb),jdim(nbb),kdim(nbb)
<       dimension idim2(nbb),jdim2(nbb),kdim2(nbb)
<       dimension x(imax,jmax,kmax),y(imax,jmax,kmax),z(imax,jmax,kmax)
---
>       integer stats
162c160,169
<       pointer (ip_x,x),(ip_y,y),(ip_z,z)
---
>       dimension idim(nbb)
>       dimension idim2(nbb)
>       dimension jdim(nbb)
>       dimension jdim2(nbb)
>       dimension kdim(nbb)
>       dimension kdim2(nbb)
> c
>       allocatable :: x(:,:,:)
>       allocatable :: y(:,:,:)
>       allocatable :: z(:,:,:)
166d172
<       icall  = 0
168,170c174,180
<       call umalloc_r(ip_x,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_y,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_z,imax*jmax*kmax,0,icall,memuse)
---
>       allocate( x(imax,jmax,kmax), stat=stats )
>       call umalloc_r(imax*jmax*kmax,0,'x',memuse,stats)
>       allocate( y(imax,jmax,kmax), stat=stats )
>       call umalloc_r(imax*jmax*kmax,0,'y',memuse,stats)
>       allocate( z(imax,jmax,kmax), stat=stats )
>       call umalloc_r(imax*jmax*kmax,0,'z',memuse,stats)
> 
324,329c334,336
<       ifree = 1
<       if (ifree.gt.0) then
<          call ufree_r(ip_x)
<          call ufree_r(ip_y)
<          call ufree_r(ip_z)
<       end if
---
>       deallocate(x)
>       deallocate(y)
>       deallocate(z)
Index: source/tools/grid_perturb.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/grid_perturb.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
133c133
<       dimension itemp(maxbl),jtemp(maxbl),ktemp(maxbl)
---
>       integer stats
135c135,137
<       pointer (ip_itemp,itemp),(ip_jtemp,jtemp),(ip_ktemp,ktemp)
---
>       allocatable :: itemp(:)
>       allocatable :: jtemp(:)
>       allocatable :: ktemp(:)
140,143c142,147
<       icall  = 0
<       call umalloc_r(ip_itemp,maxbl,1,icall,memuse)
<       call umalloc_r(ip_jtemp,maxbl,1,icall,memuse)
<       call umalloc_r(ip_ktemp,maxbl,1,icall,memuse)
---
>       allocate( itemp(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'itemp',memuse,stats)
>       allocate( jtemp(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jtemp',memuse,stats)
>       allocate( ktemp(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'ktemp',memuse,stats)
162,164c166,168
<       call ufree_r(ip_itemp)
<       call ufree_r(ip_jtemp)
<       call ufree_r(ip_ktemp)
---
>       deallocate(itemp)
>       deallocate(jtemp)
>       deallocate(ktemp)
176,185c180,197
<       real x1(jmax,kmax,imax),y1(jmax,kmax,imax),
<      .          z1(jmax,kmax,imax)
<       real g_x(ndvmx,jmax,kmax,imax),g_y(ndvmx,jmax,kmax,imax),
<      .          g_z(ndvmx,jmax,kmax,imax)
< c
<       dimension x2(jmax,kmax,imax),y2(jmax,kmax,imax),
<      .          z2(jmax,kmax,imax)
<       dimension idim(maxbl),jdim(maxbl),kdim(maxbl)
<       dimension idimsd(maxbl),jdimsd(maxbl),kdimsd(maxbl)
< c
---
>       integer stats
> 
>       real, allocatable :: g_x(:,:,:,:)
>       real, allocatable :: g_y(:,:,:,:)
>       real, allocatable :: g_z(:,:,:,:)
>       allocatable :: idim(:)
>       allocatable :: idimsd(:)
>       allocatable :: jdim(:)
>       allocatable :: jdimsd(:)
>       allocatable :: kdim(:)
>       allocatable :: kdimsd(:)
>       real, allocatable :: x1(:,:,:)
>       allocatable :: x2(:,:,:)
>       real, allocatable :: y1(:,:,:)
>       allocatable :: y2(:,:,:)
>       real, allocatable :: z1(:,:,:)
>       allocatable :: z2(:,:,:)
> 
189,195d200
<       pointer (ip_x1,x1),(ip_y1,y1),(ip_z1,z1),
<      .        (ip_x2,x2),(ip_y2,y2),(ip_z2,z2),
<      .        (ip_g_x,g_x),(ip_g_y,g_y),(ip_g_z,g_z),
<      .        (ip_idim,idim),(ip_jdim,jdim),(ip_kdim,kdim),
<      .        (ip_idimsd,idimsd),(ip_jdimsd,jdimsd),
<      .        (ip_kdimsd,kdimsd)
< c
197d201
<       icall  = 0
201,215c205,234
<       call umalloc_r(ip_idim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_jdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_kdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_idimsd,maxbl,1,icall,memuse)
<       call umalloc_r(ip_jdimsd,maxbl,1,icall,memuse)
<       call umalloc_r(ip_kdimsd,maxbl,1,icall,memuse)
<       call umalloc_r(ip_x1,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_y1,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_z1,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_x2,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_y2,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_z2,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_g_x,ndvmx*imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_g_y,ndvmx*imax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_g_z,ndvmx*imax*jmax*kmax,0,icall,memuse)
---
>       allocate( g_x(ndvmx,jmax,kmax,imax), stat=stats )
>       call umalloc_r(ndvmx*jmax*kmax*imax,0,'g_x',memuse,stats)
>       allocate( g_y(ndvmx,jmax,kmax,imax), stat=stats )
>       call umalloc_r(ndvmx*jmax*kmax*imax,0,'g_y',memuse,stats)
>       allocate( g_z(ndvmx,jmax,kmax,imax), stat=stats )
>       call umalloc_r(ndvmx*jmax*kmax*imax,0,'g_z',memuse,stats)
>       allocate( idim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'idim',memuse,stats)
>       allocate( idimsd(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'idimsd',memuse,stats)
>       allocate( jdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jdim',memuse,stats)
>       allocate( jdimsd(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jdimsd',memuse,stats)
>       allocate( kdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'kdim',memuse,stats)
>       allocate( kdimsd(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'kdimsd',memuse,stats)
>       allocate( x1(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'x1',memuse,stats)
>       allocate( x2(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'x2',memuse,stats)
>       allocate( y1(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'y1',memuse,stats)
>       allocate( y2(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'y2',memuse,stats)
>       allocate( z1(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'z1',memuse,stats)
>       allocate( z2(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'z2',memuse,stats)
358,372c377,391
<       call ufree_r(ip_idim)
<       call ufree_r(ip_jdim)
<       call ufree_r(ip_kdim)
<       call ufree_r(ip_idimsd)
<       call ufree_r(ip_jdimsd)
<       call ufree_r(ip_kdimsd)
<       call ufree_r(ip_x1)
<       call ufree_r(ip_y1)
<       call ufree_r(ip_z1)
<       call ufree_r(ip_x2)
<       call ufree_r(ip_y2)
<       call ufree_r(ip_z2)
<       call ufree_r(ip_g_x)
<       call ufree_r(ip_g_y)
<       call ufree_r(ip_g_z)
---
>       deallocate(idim)
>       deallocate(jdim)
>       deallocate(kdim)
>       deallocate(idimsd)
>       deallocate(jdimsd)
>       deallocate(kdimsd)
>       deallocate(x1)
>       deallocate(y1)
>       deallocate(z1)
>       deallocate(x2)
>       deallocate(y2)
>       deallocate(z2)
>       deallocate(g_x)
>       deallocate(g_y)
>       deallocate(g_z)
Index: source/tools/grid_perturb_cmplx.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/grid_perturb_cmplx.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
133,135c133,137
<       dimension itemp(maxbl),jtemp(maxbl),ktemp(maxbl)
< c
<       pointer (ip_itemp,itemp),(ip_jtemp,jtemp),(ip_ktemp,ktemp)
---
>       integer stats
> 
>       allocatable :: itemp(:)
>       allocatable :: jtemp(:)
>       allocatable :: ktemp(:)
140,143c142,147
<       icall  = 0
<       call umalloc_c(ip_itemp,maxbl,1,icall,memuse)
<       call umalloc_c(ip_jtemp,maxbl,1,icall,memuse)
<       call umalloc_c(ip_ktemp,maxbl,1,icall,memuse)
---
>       allocate( itemp(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'itemp',memuse,stats)
>       allocate( jtemp(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'jtemp',memuse,stats)
>       allocate( ktemp(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'ktemp',memuse,stats)
162,164c166,168
<       call ufree_c(ip_itemp)
<       call ufree_c(ip_jtemp)
<       call ufree_c(ip_ktemp)
---
>       deallocate(itemp)
>       deallocate(jtemp)
>       deallocate(ktemp)
178,187c182,199
<       real x1(jmax,kmax,imax),y1(jmax,kmax,imax),
<      .          z1(jmax,kmax,imax)
<       real g_x(ndvmx,jmax,kmax,imax),g_y(ndvmx,jmax,kmax,imax),
<      .          g_z(ndvmx,jmax,kmax,imax)
< c
<       dimension x2(jmax,kmax,imax),y2(jmax,kmax,imax),
<      .          z2(jmax,kmax,imax)
<       dimension idim(maxbl),jdim(maxbl),kdim(maxbl)
<       dimension idimsd(maxbl),jdimsd(maxbl),kdimsd(maxbl)
< c
---
>       integer stats
> 
>       real, allocatable :: g_x(:,:,:,:)
>       real, allocatable :: g_y(:,:,:,:)
>       real, allocatable :: g_z(:,:,:,:)
>       allocatable :: idim(:)
>       allocatable :: idimsd(:)
>       allocatable :: jdim(:)
>       allocatable :: jdimsd(:)
>       allocatable :: kdim(:)
>       allocatable :: kdimsd(:)
>       real, allocatable :: x1(:,:,:)
>       allocatable :: x2(:,:,:)
>       real, allocatable :: y1(:,:,:)
>       allocatable :: y2(:,:,:)
>       real, allocatable :: z1(:,:,:)
>       allocatable :: z2(:,:,:)
> 
191,197d202
<       pointer (ip_x1,x1),(ip_y1,y1),(ip_z1,z1),
<      .        (ip_x2,x2),(ip_y2,y2),(ip_z2,z2),
<      .        (ip_g_x,g_x),(ip_g_y,g_y),(ip_g_z,g_z),
<      .        (ip_idim,idim),(ip_jdim,jdim),(ip_kdim,kdim),
<      .        (ip_idimsd,idimsd),(ip_jdimsd,jdimsd),
<      .        (ip_kdimsd,kdimsd)
< c
199d203
<       icall  = 0
204,218c208,237
<       call umalloc_c(ip_idim,maxbl,1,icall,memuse)
<       call umalloc_c(ip_jdim,maxbl,1,icall,memuse)
<       call umalloc_c(ip_kdim,maxbl,1,icall,memuse)
<       call umalloc_c(ip_idimsd,maxbl,1,icall,memuse)
<       call umalloc_c(ip_jdimsd,maxbl,1,icall,memuse)
<       call umalloc_c(ip_kdimsd,maxbl,1,icall,memuse)
<       call umalloc_c(ip_x1,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_c(ip_y1,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_c(ip_z1,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_c(ip_x2,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_c(ip_y2,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_c(ip_z2,imax*jmax*kmax,0,icall,memuse)
<       call umalloc_c(ip_g_x,ndvmx*imax*jmax*kmax,0,icall,memuse)
<       call umalloc_c(ip_g_y,ndvmx*imax*jmax*kmax,0,icall,memuse)
<       call umalloc_c(ip_g_z,ndvmx*imax*jmax*kmax,0,icall,memuse)
---
>       allocate( g_x(ndvmx,jmax,kmax,imax), stat=stats )
>       call umalloc_r(ndvmx*jmax*kmax*imax,0,'g_x',memuse,stats)
>       allocate( g_y(ndvmx,jmax,kmax,imax), stat=stats )
>       call umalloc_r(ndvmx*jmax*kmax*imax,0,'g_y',memuse,stats)
>       allocate( g_z(ndvmx,jmax,kmax,imax), stat=stats )
>       call umalloc_r(ndvmx*jmax*kmax*imax,0,'g_z',memuse,stats)
>       allocate( idim(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'idim',memuse,stats)
>       allocate( idimsd(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'idimsd',memuse,stats)
>       allocate( jdim(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'jdim',memuse,stats)
>       allocate( jdimsd(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'jdimsd',memuse,stats)
>       allocate( kdim(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'kdim',memuse,stats)
>       allocate( kdimsd(maxbl), stat=stats )
>       call umalloc_c(maxbl,1,'kdimsd',memuse,stats)
>       allocate( x1(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'x1',memuse,stats)
>       allocate( x2(jmax,kmax,imax), stat=stats )
>       call umalloc_c(jmax*kmax*imax,0,'x2',memuse,stats)
>       allocate( y1(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'y1',memuse,stats)
>       allocate( y2(jmax,kmax,imax), stat=stats )
>       call umalloc_c(jmax*kmax*imax,0,'y2',memuse,stats)
>       allocate( z1(jmax,kmax,imax), stat=stats )
>       call umalloc_r(jmax*kmax*imax,0,'z1',memuse,stats)
>       allocate( z2(jmax,kmax,imax), stat=stats )
>       call umalloc_c(jmax*kmax*imax,0,'z2',memuse,stats)
361,375c380,394
<       call ufree_c(ip_idim)
<       call ufree_c(ip_jdim)
<       call ufree_c(ip_kdim)
<       call ufree_c(ip_idimsd)
<       call ufree_c(ip_jdimsd)
<       call ufree_c(ip_kdimsd)
<       call ufree_c(ip_x1)
<       call ufree_c(ip_y1)
<       call ufree_c(ip_z1)
<       call ufree_c(ip_x2)
<       call ufree_c(ip_y2)
<       call ufree_c(ip_z2)
<       call ufree_c(ip_g_x)
<       call ufree_c(ip_g_y)
<       call ufree_c(ip_g_z)
---
>       deallocate(idim)
>       deallocate(jdim)
>       deallocate(kdim)
>       deallocate(idimsd)
>       deallocate(jdimsd)
>       deallocate(kdimsd)
>       deallocate(x1)
>       deallocate(y1)
>       deallocate(z1)
>       deallocate(x2)
>       deallocate(y2)
>       deallocate(z2)
>       deallocate(g_x)
>       deallocate(g_y)
>       deallocate(g_z)
Index: source/tools/initialize_field.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/initialize_field.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
17c17
< c     f90 -64 -r8 initialize_field.f umalloc_r.o ufree_r.o -o initialize_field
---
> c     f90 -64 -r8 initialize_field.f umalloc_r.o -o initialize_field
111c111,112
<         write(6,'('' How many levels down are you starting?'')')
---
>         write(6,'('' How many levels down are you starting'',
>      .   '' (mseq-1)?'')')
204,206c205
<       dimension q(jdim1,kdim1,idim1,5)
<       dimension qi0(jdim1,kdim1,5,4),qj0(kdim1,idim1,5,4),
<      .          qk0(jdim1,idim1,5,4)
---
>       integer stats
208c207,210
<       pointer (ip_q,q),(ip_qi0,qi0),(ip_qj0,qj0),(ip_qk0,qk0)
---
>       allocatable :: q(:,:,:,:)
>       allocatable :: qi0(:,:,:,:)
>       allocatable :: qj0(:,:,:,:)
>       allocatable :: qk0(:,:,:,:)
212d213
<       icall  = 0
214,217c215,222
<       call umalloc_r(ip_q,jdim1*kdim1*idim1*5,0,icall,memuse)
<       call umalloc_r(ip_qi0,jdim1*kdim1*20,0,icall,memuse)
<       call umalloc_r(ip_qj0,kdim1*idim1*20,0,icall,memuse)
<       call umalloc_r(ip_qk0,jdim1*idim1*20,0,icall,memuse)
---
>       allocate( q(jdim1,kdim1,idim1,5), stat=stats )
>       call umalloc_r(jdim1*kdim1*idim1*5,0,'q',memuse,stats)
>       allocate( qi0(jdim1,kdim1,5,4), stat=stats )
>       call umalloc_r(jdim1*kdim1*5*4,0,'qi0',memuse,stats)
>       allocate( qj0(kdim1,idim1,5,4), stat=stats )
>       call umalloc_r(kdim1*idim1*5*4,0,'qj0',memuse,stats)
>       allocate( qk0(jdim1,idim1,5,4), stat=stats )
>       call umalloc_r(jdim1*idim1*5*4,0,'qk0',memuse,stats)
371,374c376,379
<          call ufree_r(ip_q)
<          call ufree_r(ip_qi0)
<          call ufree_r(ip_qj0)
<          call ufree_r(ip_qk0)
---
>          deallocate(q)
>          deallocate(qi0)
>          deallocate(qj0)
>          deallocate(qk0)
Index: source/tools/moovmaker.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/moovmaker.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
24c24,27
< c     call asnfile(g_in, '-F f77 -N ieee', IER)
---
> #if defined ASN_P3D
>       call asnfile(g_in, '-F f77 -N ieee', IER)
>       call asnfile(q_in, '-F f77 -N ieee', IER)
> #endif
26d28
< c     call asnfile(q_in, '-F f77 -N ieee', IER)
70c72
<       dimension itemp(maxbl),jtemp(maxbl),ktemp(maxbl)
---
>       integer stats
72c74,76
<       pointer (ip_itemp,itemp),(ip_jtemp,jtemp),(ip_ktemp,ktemp)
---
>       allocatable :: itemp(:)
>       allocatable :: jtemp(:)
>       allocatable :: ktemp(:)
77,80c81,86
<       icall  = 0
<       call umalloc_r(ip_itemp,maxbl,1,icall,memuse)
<       call umalloc_r(ip_jtemp,maxbl,1,icall,memuse)
<       call umalloc_r(ip_ktemp,maxbl,1,icall,memuse)
---
>       allocate( itemp(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'itemp',memuse,stats)
>       allocate( jtemp(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jtemp',memuse,stats)
>       allocate( ktemp(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'ktemp',memuse,stats)
103a110,116
>           else
>              write(6,*)'error - for 3-D movies, one output dimension',
>      +        ' must be of dimension 1'
>              write(6,*)'... (kstart=kend=1 or jstart=jend=1 or',
>      +        ' istart=iend=1 in input file)'
>              write(6,*)'stopping'
>              stop
110,112c123,125
<       call ufree_r(ip_itemp)
<       call ufree_r(ip_jtemp)
<       call ufree_r(ip_ktemp)
---
>       deallocate(itemp)
>       deallocate(jtemp)
>       deallocate(ktemp)
128,136c141,153
<       dimension x(jmax,kmax,ntime,maxbl),y(jmax,kmax,ntime,maxbl),
<      .          z(jmax,kmax,ntime,maxbl),
<      .          q(jmax,kmax,ntime,maxbl,5),jdim(maxbl),kdim(maxbl),
<      .          idim(maxbl),time(ntime),iblank(jmax,kmax,maxbl),
<      .          jjdim(maxbl),kkdim(maxbl)
< c
<       pointer (ip_x,x),(ip_y,y),(ip_z,z),(ip_q,q),(ip_time,time),
<      .        (ip_iblank,iblank),(ip_jdim,jdim),(ip_kdim,kdim),
<      .        (ip_idim,idim),(ip_jjdim,jjdim),(ip_kkdim,kkdim)
---
>       integer stats
> 
>       allocatable :: iblank(:,:,:)
>       allocatable :: idim(:)
>       allocatable :: jdim(:)
>       allocatable :: jjdim(:)
>       allocatable :: kdim(:)
>       allocatable :: kkdim(:)
>       allocatable :: q(:,:,:,:,:)
>       allocatable :: time(:)
>       allocatable :: x(:,:,:,:)
>       allocatable :: y(:,:,:,:)
>       allocatable :: z(:,:,:,:)
138d154
<       icall  = 0
141,151c157,178
<       call umalloc_r(ip_x,jmax*kmax*ntime*maxbl,0,icall,memuse)
<       call umalloc_r(ip_y,jmax*kmax*ntime*maxbl,0,icall,memuse)
<       call umalloc_r(ip_z,jmax*kmax*ntime*maxbl,0,icall,memuse)
<       call umalloc_r(ip_q,jmax*kmax*ntime*maxbl*5,0,icall,memuse)
<       call umalloc_r(ip_iblank,jmax*kmax*maxbl,1,icall,memuse)
<       call umalloc_r(ip_idim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_jdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_kdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_jjdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_kkdim,maxbl,1,icall,memuse)
<       call umalloc_r(ip_time,ntime,0,icall,memuse)
---
>       allocate( iblank(jmax,kmax,maxbl), stat=stats )
>       call umalloc_r(jmax*kmax*maxbl,1,'iblank',memuse,stats)
>       allocate( idim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'idim',memuse,stats)
>       allocate( jdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jdim',memuse,stats)
>       allocate( jjdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'jjdim',memuse,stats)
>       allocate( kdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'kdim',memuse,stats)
>       allocate( kkdim(maxbl), stat=stats )
>       call umalloc_r(maxbl,1,'kkdim',memuse,stats)
>       allocate( q(jmax,kmax,ntime,maxbl,5), stat=stats )
>       call umalloc_r(jmax*kmax*ntime*maxbl*5,0,'q',memuse,stats)
>       allocate( time(ntime), stat=stats )
>       call umalloc_r(ntime,0,'time',memuse,stats)
>       allocate( x(jmax,kmax,ntime,maxbl), stat=stats )
>       call umalloc_r(jmax*kmax*ntime*maxbl,0,'x',memuse,stats)
>       allocate( y(jmax,kmax,ntime,maxbl), stat=stats )
>       call umalloc_r(jmax*kmax*ntime*maxbl,0,'y',memuse,stats)
>       allocate( z(jmax,kmax,ntime,maxbl), stat=stats )
>       call umalloc_r(jmax*kmax*ntime*maxbl,0,'z',memuse,stats)
260,261c287,290
< c     call asnfile('g.bin', '-F f77 -N ieee', IER)
< c     call asnfile('q.bin', '-F f77 -N ieee', IER)
---
> #if defined ASN_P3D
>       call asnfile('g.bin', '-F f77 -N ieee', IER)
>       call asnfile('q.bin', '-F f77 -N ieee', IER)
> #endif
306,316c335,345
<       call ufree_r(ip_x)
<       call ufree_r(ip_y)
<       call ufree_r(ip_z)
<       call ufree_r(ip_q)
<       call ufree_r(ip_iblank)
<       call ufree_r(ip_idim)
<       call ufree_r(ip_jdim)
<       call ufree_r(ip_kdim)
<       call ufree_r(ip_jjdim)
<       call ufree_r(ip_kkdim)
<       call ufree_r(ip_time)
---
>       deallocate(x)
>       deallocate(y)
>       deallocate(z)
>       deallocate(q)
>       deallocate(iblank)
>       deallocate(idim)
>       deallocate(jdim)
>       deallocate(kdim)
>       deallocate(jjdim)
>       deallocate(kkdim)
>       deallocate(time)
Index: source/tools/p3d_to_INGRID.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/p3d_to_INGRID.F,v
retrieving revision 1.2
retrieving revision 1.3
diff -r1.2 -r1.3
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
263,266d262
<       dimension x(lmax,jmax,kmax),y(lmax,jmax,kmax),z(lmax,jmax,kmax)
<       dimension xcc(lmax,jmax,kmax),ycc(lmax,jmax,kmax),
<      .          zcc(lmax,jmax,kmax)
<       dimension ldim(10000),jdim(10000),kdim(10000)
269,270c265,276
<       pointer (ip_x,x),(ip_y,y),(ip_z,z)
<       pointer (ip_xcc,xcc),(ip_ycc,ycc),(ip_zcc,zcc)
---
>       integer stats
> c
>       dimension jdim(10000)
>       dimension kdim(10000)
>       dimension ldim(10000)
> c
>       allocatable :: x(:,:,:)
>       allocatable :: xcc(:,:,:)
>       allocatable :: y(:,:,:)
>       allocatable :: ycc(:,:,:)
>       allocatable :: z(:,:,:)
>       allocatable :: zcc(:,:,:)
274d279
<       icall  = 0
276,281c281,292
<       call umalloc_r(ip_x,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_y,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_z,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_xcc,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_ycc,lmax*jmax*kmax,0,icall,memuse)
<       call umalloc_r(ip_zcc,lmax*jmax*kmax,0,icall,memuse)
---
>       allocate( x(lmax,jmax,kmax), stat=stats )
>       call umalloc_r(lmax*jmax*kmax,0,'x',memuse,stats)
>       allocate( xcc(lmax,jmax,kmax), stat=stats )
>       call umalloc_r(lmax*jmax*kmax,0,'xcc',memuse,stats)
>       allocate( y(lmax,jmax,kmax), stat=stats )
>       call umalloc_r(lmax*jmax*kmax,0,'y',memuse,stats)
>       allocate( ycc(lmax,jmax,kmax), stat=stats )
>       call umalloc_r(lmax*jmax*kmax,0,'ycc',memuse,stats)
>       allocate( z(lmax,jmax,kmax), stat=stats )
>       call umalloc_r(lmax*jmax*kmax,0,'z',memuse,stats)
>       allocate( zcc(lmax,jmax,kmax), stat=stats )
>       call umalloc_r(lmax*jmax*kmax,0,'zcc',memuse,stats)
528,533c539,544
<          call ufree_r(ip_x)
<          call ufree_r(ip_y)
<          call ufree_r(ip_z)
<          call ufree_r(ip_xcc)
<          call ufree_r(ip_ycc)
<          call ufree_r(ip_zcc)
---
>          deallocate(x)
>          deallocate(y)
>          deallocate(z)
>          deallocate(xcc)
>          deallocate(ycc)
>          deallocate(zcc)
Index: source/tools/p3d_to_cfl3drst.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/p3d_to_cfl3drst.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
17c17
< c     f90 -64 -r8 p3d_to_cfl3drst.f umalloc_r.o ufree_r.o -o p3d_to_cfl3drst
---
> c     f90 -64 -r8 p3d_to_cfl3drst.f umalloc_r.o -o p3d_to_cfl3drst
43a44
> #if defined ASN_P3D
49a51
> #endif
126a129,130
>       integer stats
> c
128,133c132,158
<       real*4 q(imax,jmax,kmax,5,nblk)
<       dimension q2(imax,jmax,kmax,5,nblk)
<       dimension qi0(jmax,kmax,5,4),qj0(kmax,imax,5,4),
<      .          qk0(jmax,imax,5,4)
<       dimension id(nblock),jd(nblock),kd(nblock)
<       dimension idsav(nblock),jdsav(nblock),kdsav(nblock)
---
> c
>       dimension cdpw(1)
>       dimension cdvw(1)
>       dimension cdw(1)
>       dimension cftmomw(1)
>       dimension cftpw(1)
>       dimension cfttotw(1)
>       dimension cftvw(1)
>       dimension clw(1)
>       dimension cmxw(1)
>       dimension cmyw(1)
>       dimension cmzw(1)
>       dimension cxw(1)
>       dimension cyw(1)
>       dimension czw(1)
>       dimension fmdotw(1)
>       dimension id(nblock)
>       dimension idsav(nblock)
>       dimension jd(nblock)
>       dimension jdsav(nblock)
>       dimension kd(nblock)
>       dimension kdsav(nblock)
>       dimension nneg1(1)
>       dimension nneg2(1)
>       dimension rms(1)
>       dimension rmstr1(1)
>       dimension rmstr2(1)
135,141d159
<       dimension rms(1),clw(1),cdw(1),cdpw(1),
<      .          cdvw(1),cxw(1),cyw(1),czw(1),
<      .          cmxw(1),cmyw(1),cmzw(1),
<      .          fmdotw(1),cftmomw(1),cftpw(1),
<      .          cftvw(1),cfttotw(1),
<      .          rmstr1(1),rmstr2(1)
<       dimension nneg1(1),nneg2(1)
143,144c161,165
<       pointer (ip_q,q),(ip_q2,q2),(ip_qi0,qi0),
<      .        (ip_qj0,qj0),(ip_qk0,qk0)
---
>       real(4), allocatable :: q(:,:,:,:,:)
>       allocatable :: q2(:,:,:,:,:)
>       allocatable :: qi0(:,:,:,:)
>       allocatable :: qj0(:,:,:,:)
>       allocatable :: qk0(:,:,:,:)
148d168
<       icall  = 0
150,154c170,179
<       call umalloc_r(ip_q,imax*jmax*kmax*5*nblk,0,icall,memuse)
<       call umalloc_r(ip_q2,imax*jmax*kmax*5*nblk,0,icall,memuse)
<       call umalloc_r(ip_qi0,jmax*kmax*20,0,icall,memuse)
<       call umalloc_r(ip_qj0,kmax*imax*20,0,icall,memuse)
<       call umalloc_r(ip_qk0,jmax*imax*20,0,icall,memuse)
---
>       allocate( q(imax,jmax,kmax,5,nblk), stat=stats )
>       call umalloc_r(imax*jmax*kmax*5*nblk,0,'q',memuse,stats)
>       allocate( q2(imax,jmax,kmax,5,nblk), stat=stats )
>       call umalloc_r(imax*jmax*kmax*5*nblk,0,'q2',memuse,stats)
>       allocate( qi0(jmax,kmax,5,4), stat=stats )
>       call umalloc_r(jmax*kmax*5*4,0,'qi0',memuse,stats)
>       allocate( qj0(kmax,imax,5,4), stat=stats )
>       call umalloc_r(kmax*imax*5*4,0,'qj0',memuse,stats)
>       allocate( qk0(jmax,imax,5,4), stat=stats )
>       call umalloc_r(jmax*imax*5*4,0,'qk0',memuse,stats)
413,417c438,442
<          call ufree_r(ip_q)
<          call ufree_r(ip_q2)
<          call ufree_r(ip_qi0)
<          call ufree_r(ip_qj0)
<          call ufree_r(ip_qk0)
---
>          deallocate(q)
>          deallocate(q2)
>          deallocate(qi0)
>          deallocate(qj0)
>          deallocate(qk0)
Index: source/tools/plot3dg_to_cgns.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/plot3dg_to_cgns.F,v
retrieving revision 1.2
retrieving revision 1.4
diff -r1.2 -r1.4
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
9a10
> c   Currently, you must be linked to CGNS V2.2 or later
30a32,33
>       write(6,'('' Note:  currently, you must be linked to CGNS V2.2'',
>      +  '' or later'',/)')
94,119c97,139
<       dimension x(idm,jdm,kdm,nblock),y(idm,jdm,kdm,nblock),
<      +          z(idm,jdm,kdm,nblock)
<       dimension idim(nblock),jdim(nblock),kdim(nblock)
<       dimension iz(nblock),iv1(nblock),iv2(nblock),iv3(nblock)
<       dimension iblk1(n11),ilo1(n11),jlo1(n11),klo1(n11),ihi1(n11),
<      +          jhi1(n11),khi1(n11),isva1(n11),isvb1(n11)
<       dimension iblk2(n11),ilo2(n11),jlo2(n11),klo2(n11),ihi2(n11),
<      +          jhi2(n11),khi2(n11),isva2(n11),isvb2(n11)
<       dimension i0(nblock),im(nblock),j0(nblock),jm(nblock),
<      +          k0(nblock),km(nblock)
<       dimension irange(3,2),iranged(3,2),itransform(3)
<       dimension data(7),ipnts(3,2),isize(9)
< c
<       pointer (ip_x,x),(ip_y,y),(ip_z,z),(ip_idim,idim),(ip_jdim,jdim),
<      +        (ip_kdim,kdim),(ip_iz,iz),(ip_iv1,iv1),
<      +        (ip_iv2,iv2),(ip_iv3,iv3)
<       pointer (ip_iblk1,iblk1),(ip_jlo1,jlo1),
<      +        (ip_klo1,klo1),(ip_ilo1,ilo1),(ip_jhi1,jhi1),
<      +        (ip_khi1,khi1),(ip_ihi1,ihi1),(ip_isva1,isva1),
<      +        (ip_isvb1,isvb1)
<       pointer (ip_iblk2,iblk2),(ip_jlo2,jlo2),
<      +        (ip_klo2,klo2),(ip_ilo2,ilo2),(ip_jhi2,jhi2),
<      +        (ip_khi2,khi2),(ip_ihi2,ihi2),(ip_isva2,isva2),
<      +        (ip_isvb2,isvb2)
<       pointer (ip_i0,i0),(ip_im,im),(ip_j0,j0),(ip_jm,jm),
<      +        (ip_k0,k0),(ip_km,km)
---
>       integer stats
> c
>       dimension data(7)
>       dimension ipnts(3,2)
>       dimension irange(3,2)
>       dimension iranged(3,2)
>       dimension isize(9)
>       dimension itransform(3)
> c
>       allocatable :: i0(:)
>       allocatable :: iblk1(:)
>       allocatable :: iblk2(:)
>       allocatable :: idim(:)
>       allocatable :: ihi1(:)
>       allocatable :: ihi2(:)
>       allocatable :: ilo1(:)
>       allocatable :: ilo2(:)
>       allocatable :: im(:)
>       allocatable :: isva1(:)
>       allocatable :: isva2(:)
>       allocatable :: isvb1(:)
>       allocatable :: isvb2(:)
>       allocatable :: iv1(:)
>       allocatable :: iv2(:)
>       allocatable :: iv3(:)
>       allocatable :: iz(:)
>       allocatable :: j0(:)
>       allocatable :: jdim(:)
>       allocatable :: jhi1(:)
>       allocatable :: jhi2(:)
>       allocatable :: jlo1(:)
>       allocatable :: jlo2(:)
>       allocatable :: jm(:)
>       allocatable :: k0(:)
>       allocatable :: kdim(:)
>       allocatable :: khi1(:)
>       allocatable :: khi2(:)
>       allocatable :: klo1(:)
>       allocatable :: klo2(:)
>       allocatable :: km(:)
>       allocatable :: x(:,:,:,:)
>       allocatable :: y(:,:,:,:)
>       allocatable :: z(:,:,:,:)
143,177c163,230
<       icall  = 0
<       call umalloc_r(ip_x,idm*jdm*kdm*nblock,0,icall,memuse)
<       call umalloc_r(ip_y,idm*jdm*kdm*nblock,0,icall,memuse)
<       call umalloc_r(ip_z,idm*jdm*kdm*nblock,0,icall,memuse)
<       call umalloc_r(ip_idim,nblock,1,icall,memuse)
<       call umalloc_r(ip_jdim,nblock,1,icall,memuse)
<       call umalloc_r(ip_kdim,nblock,1,icall,memuse)
<       call umalloc_r(ip_iz,nblock,1,icall,memuse)
<       call umalloc_r(ip_iv1,nblock,1,icall,memuse)
<       call umalloc_r(ip_iv2,nblock,1,icall,memuse)
<       call umalloc_r(ip_iv3,nblock,1,icall,memuse)
<       call umalloc_r(ip_iblk1,n11,1,icall,memuse)
<       call umalloc_r(ip_ilo1,n11,1,icall,memuse)
<       call umalloc_r(ip_jlo1,n11,1,icall,memuse)
<       call umalloc_r(ip_klo1,n11,1,icall,memuse)
<       call umalloc_r(ip_ihi1,n11,1,icall,memuse)
<       call umalloc_r(ip_jhi1,n11,1,icall,memuse)
<       call umalloc_r(ip_khi1,n11,1,icall,memuse)
<       call umalloc_r(ip_isva1,n11,1,icall,memuse)
<       call umalloc_r(ip_isvb1,n11,1,icall,memuse)
<       call umalloc_r(ip_iblk2,n11,1,icall,memuse)
<       call umalloc_r(ip_ilo2,n11,1,icall,memuse)
<       call umalloc_r(ip_jlo2,n11,1,icall,memuse)
<       call umalloc_r(ip_klo2,n11,1,icall,memuse)
<       call umalloc_r(ip_ihi2,n11,1,icall,memuse)
<       call umalloc_r(ip_jhi2,n11,1,icall,memuse)
<       call umalloc_r(ip_khi2,n11,1,icall,memuse)
<       call umalloc_r(ip_isva2,n11,1,icall,memuse)
<       call umalloc_r(ip_isvb2,n11,1,icall,memuse)
<       call umalloc_r(ip_i0,nblock,1,icall,memuse)
<       call umalloc_r(ip_im,nblock,1,icall,memuse)
<       call umalloc_r(ip_j0,nblock,1,icall,memuse)
<       call umalloc_r(ip_jm,nblock,1,icall,memuse)
<       call umalloc_r(ip_k0,nblock,1,icall,memuse)
<       call umalloc_r(ip_km,nblock,1,icall,memuse)
---
>       allocate( i0(nblock), stat=stats )
>       call umalloc_r(nblock,1,'i0',memuse,stats)
>       allocate( iblk1(n11), stat=stats )
>       call umalloc_r(n11,1,'iblk1',memuse,stats)
>       allocate( iblk2(n11), stat=stats )
>       call umalloc_r(n11,1,'iblk2',memuse,stats)
>       allocate( idim(nblock), stat=stats )
>       call umalloc_r(nblock,1,'idim',memuse,stats)
>       allocate( ihi1(n11), stat=stats )
>       call umalloc_r(n11,1,'ihi1',memuse,stats)
>       allocate( ihi2(n11), stat=stats )
>       call umalloc_r(n11,1,'ihi2',memuse,stats)
>       allocate( ilo1(n11), stat=stats )
>       call umalloc_r(n11,1,'ilo1',memuse,stats)
>       allocate( ilo2(n11), stat=stats )
>       call umalloc_r(n11,1,'ilo2',memuse,stats)
>       allocate( im(nblock), stat=stats )
>       call umalloc_r(nblock,1,'im',memuse,stats)
>       allocate( isva1(n11), stat=stats )
>       call umalloc_r(n11,1,'isva1',memuse,stats)
>       allocate( isva2(n11), stat=stats )
>       call umalloc_r(n11,1,'isva2',memuse,stats)
>       allocate( isvb1(n11), stat=stats )
>       call umalloc_r(n11,1,'isvb1',memuse,stats)
>       allocate( isvb2(n11), stat=stats )
>       call umalloc_r(n11,1,'isvb2',memuse,stats)
>       allocate( iv1(nblock), stat=stats )
>       call umalloc_r(nblock,1,'iv1',memuse,stats)
>       allocate( iv2(nblock), stat=stats )
>       call umalloc_r(nblock,1,'iv2',memuse,stats)
>       allocate( iv3(nblock), stat=stats )
>       call umalloc_r(nblock,1,'iv3',memuse,stats)
>       allocate( iz(nblock), stat=stats )
>       call umalloc_r(nblock,1,'iz',memuse,stats)
>       allocate( j0(nblock), stat=stats )
>       call umalloc_r(nblock,1,'j0',memuse,stats)
>       allocate( jdim(nblock), stat=stats )
>       call umalloc_r(nblock,1,'jdim',memuse,stats)
>       allocate( jhi1(n11), stat=stats )
>       call umalloc_r(n11,1,'jhi1',memuse,stats)
>       allocate( jhi2(n11), stat=stats )
>       call umalloc_r(n11,1,'jhi2',memuse,stats)
>       allocate( jlo1(n11), stat=stats )
>       call umalloc_r(n11,1,'jlo1',memuse,stats)
>       allocate( jlo2(n11), stat=stats )
>       call umalloc_r(n11,1,'jlo2',memuse,stats)
>       allocate( jm(nblock), stat=stats )
>       call umalloc_r(nblock,1,'jm',memuse,stats)
>       allocate( k0(nblock), stat=stats )
>       call umalloc_r(nblock,1,'k0',memuse,stats)
>       allocate( kdim(nblock), stat=stats )
>       call umalloc_r(nblock,1,'kdim',memuse,stats)
>       allocate( khi1(n11), stat=stats )
>       call umalloc_r(n11,1,'khi1',memuse,stats)
>       allocate( khi2(n11), stat=stats )
>       call umalloc_r(n11,1,'khi2',memuse,stats)
>       allocate( klo1(n11), stat=stats )
>       call umalloc_r(n11,1,'klo1',memuse,stats)
>       allocate( klo2(n11), stat=stats )
>       call umalloc_r(n11,1,'klo2',memuse,stats)
>       allocate( km(nblock), stat=stats )
>       call umalloc_r(nblock,1,'km',memuse,stats)
>       allocate( x(idm,jdm,kdm,nblock), stat=stats )
>       call umalloc_r(idm*jdm*kdm*nblock,0,'x',memuse,stats)
>       allocate( y(idm,jdm,kdm,nblock), stat=stats )
>       call umalloc_r(idm*jdm*kdm*nblock,0,'y',memuse,stats)
>       allocate( z(idm,jdm,kdm,nblock), stat=stats )
>       call umalloc_r(idm*jdm*kdm*nblock,0,'z',memuse,stats)
518c571
<      +            data(2) .eq. 0 .and. iv1(n) .gt. 0) then
---
>      +            data(2) .eq. 0 .and. abs(iv1(n)) .gt. 0) then
543a597,601
>               call cg_bc_wallfunction_write_f(iccg,ibase,iz(n),
>      +          ibc,Generic,ier)
>               call cg_bc_wallfunction_write_f(iccgr,ibase,iz(n),
>      +          ibc,Generic,ier)
>               if (ier .ne. 0) call cg_error_exit_f
646c704
<      +            data(2) .eq. 0 .and. iv1(n) .gt. 0) then
---
>      +            data(2) .eq. 0 .and. abs(iv1(n)) .gt. 0) then
671a730,734
>               call cg_bc_wallfunction_write_f(iccg,ibase,iz(n),
>      +          ibc,Generic,ier)
>               call cg_bc_wallfunction_write_f(iccgr,ibase,iz(n),
>      +          ibc,Generic,ier)
>               if (ier .ne. 0) call cg_error_exit_f
774c837
<      +            data(2) .eq. 0 .and. iv2(n) .gt. 0) then
---
>      +            data(2) .eq. 0 .and. abs(iv2(n)) .gt. 0) then
799a863,867
>               call cg_bc_wallfunction_write_f(iccg,ibase,iz(n),
>      +          ibc,Generic,ier)
>               call cg_bc_wallfunction_write_f(iccgr,ibase,iz(n),
>      +          ibc,Generic,ier)
>               if (ier .ne. 0) call cg_error_exit_f
902c970
<      +            data(2) .eq. 0 .and. iv2(n) .gt. 0) then
---
>      +            data(2) .eq. 0 .and. abs(iv2(n)) .gt. 0) then
927a996,1000
>               call cg_bc_wallfunction_write_f(iccg,ibase,iz(n),
>      +          ibc,Generic,ier)
>               call cg_bc_wallfunction_write_f(iccgr,ibase,iz(n),
>      +          ibc,Generic,ier)
>               if (ier .ne. 0) call cg_error_exit_f
1030c1103
<      +            data(2) .eq. 0 .and. iv3(n) .gt. 0) then
---
>      +            data(2) .eq. 0 .and. abs(iv3(n)) .gt. 0) then
1055a1129,1133
>               call cg_bc_wallfunction_write_f(iccg,ibase,iz(n),
>      +          ibc,Generic,ier)
>               call cg_bc_wallfunction_write_f(iccgr,ibase,iz(n),
>      +          ibc,Generic,ier)
>               if (ier .ne. 0) call cg_error_exit_f
1158c1236
<      +            data(2) .eq. 0 .and. iv3(n) .gt. 0) then
---
>      +            data(2) .eq. 0 .and. abs(iv3(n)) .gt. 0) then
1183a1262,1266
>               call cg_bc_wallfunction_write_f(iccg,ibase,iz(n),
>      +          ibc,Generic,ier)
>               call cg_bc_wallfunction_write_f(iccgr,ibase,iz(n),
>      +          ibc,Generic,ier)
>               if (ier .ne. 0) call cg_error_exit_f
1451,1484c1534,1567
<       call ufree_r(ip_x)
<       call ufree_r(ip_y)
<       call ufree_r(ip_z)
<       call ufree_r(ip_idim)
<       call ufree_r(ip_jdim)
<       call ufree_r(ip_kdim)
<       call ufree_r(ip_iz)
<       call ufree_r(ip_iv1)
<       call ufree_r(ip_iv2)
<       call ufree_r(ip_iv3)
<       call ufree_r(ip_iblk1)
<       call ufree_r(ip_ilo1)
<       call ufree_r(ip_jlo1)
<       call ufree_r(ip_klo1)
<       call ufree_r(ip_ihi1)
<       call ufree_r(ip_jhi1)
<       call ufree_r(ip_khi1)
<       call ufree_r(ip_isva1)
<       call ufree_r(ip_isvb1)
<       call ufree_r(ip_iblk2)
<       call ufree_r(ip_ilo2)
<       call ufree_r(ip_jlo2)
<       call ufree_r(ip_klo2)
<       call ufree_r(ip_ihi2)
<       call ufree_r(ip_jhi2)
<       call ufree_r(ip_khi2)
<       call ufree_r(ip_isva2)
<       call ufree_r(ip_isvb2)
<       call ufree_r(ip_i0)
<       call ufree_r(ip_im)
<       call ufree_r(ip_j0)
<       call ufree_r(ip_jm)
<       call ufree_r(ip_k0)
<       call ufree_r(ip_km)
---
>       deallocate(x)
>       deallocate(y)
>       deallocate(z)
>       deallocate(idim)
>       deallocate(jdim)
>       deallocate(kdim)
>       deallocate(iz)
>       deallocate(iv1)
>       deallocate(iv2)
>       deallocate(iv3)
>       deallocate(iblk1)
>       deallocate(ilo1)
>       deallocate(jlo1)
>       deallocate(klo1)
>       deallocate(ihi1)
>       deallocate(jhi1)
>       deallocate(khi1)
>       deallocate(isva1)
>       deallocate(isvb1)
>       deallocate(iblk2)
>       deallocate(ilo2)
>       deallocate(jlo2)
>       deallocate(klo2)
>       deallocate(ihi2)
>       deallocate(jhi2)
>       deallocate(khi2)
>       deallocate(isva2)
>       deallocate(isvb2)
>       deallocate(i0)
>       deallocate(im)
>       deallocate(j0)
>       deallocate(jm)
>       deallocate(k0)
>       deallocate(km)
Index: source/tools/v6_restart_mod.F
===================================================================
RCS file: /ump/fldmd/home/biedron/CVS_REPOSITORIES/cfl3dv6/source/tools/v6_restart_mod.F,v
retrieving revision 1.2
retrieving revision 1.5
diff -r1.2 -r1.5
3c3
< c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
---
> c     $Id: cvs_diff_Oct_01_2002,v 1.1 2002/10/25 14:38:31 rumsey Exp $
27c27
< c     f90 -64 -r8 v6_restart_mod.f umalloc_r.o ufree_r.o -o v6_restart_mod
---
> c     f90 -64 -r8 v6_restart_mod.f umalloc_r_r.o -o v6_restart_mod
29,34c29,30
< c f90 -DASN_P3D -DCRAY_TIME -DWKSTN_OFF -Oscalar3,vector3 -c umalloc_c.F
< c f90 -DASN_P3D -DCRAY_TIME -DWKSTN_OFF -Oscalar3,vector3 -c ufree_c.F
< c f90 -DASN_P3D -DCRAY_TIME -DWKSTN_OFF -Oscalar3,vector3 -c ufree_r.F
< c f90 -DASN_P3D -DCRAY_TIME -DWKSTN_OFF -Oscalar3,vector3 -c umalloc_r.F
< c ar ruc libs.a umalloc_c.o ufree_c.o umalloc_r.o ufree_r.o
< c f90 -DASN_P3D -DCRAY_TIME -DWKSTN_OFF -Oscalar3,vector3 v6_restart_mod.f -o v6_restart_mod libs.a
---
> c f90 -DASN_P3D -DCRAY_TIME -DWKSTN_OFF -Oscalar3,vector3 -c umalloc_r_r.F
> c f90 -DASN_P3D -DCRAY_TIME -DWKSTN_OFF -Oscalar3,vector3 v6_restart_mod.f umalloc_r_r.o -o v6_restart_mod
52a49,58
>       write(6,'('' input 0 if restart file is 2nd-order-time-accurate'',
>      +  '' and is an older file'')')
>       write(6,'(''   (does NOT contain turb info from last time step'',
>      +  '' or dt) (1=new CFL3D default)'')')
>       read(5,*) itime2read
>       if (itime2read .eq. 0) then
>         write(6,'(/,'' Note: this program will NOT add this info.'')')
>         write(6,'('' You must use keyword itime2read=0 when you run'',
>      +    '' CFL3D.'')')
>       end if
284c290
<      . ihalf,nblk,imaxc,jmaxc,kmaxc,ic,jc,kc,titlw)
---
>      . ihalf,nblk,imaxc,jmaxc,kmaxc,ic,jc,kc,itime2read,titlw)
294c300
<      . ihalf,nblk,idimc,jdimc,kdimc,ic,jc,kc,titlw)
---
>      . ihalf,nblk,idimc,jdimc,kdimc,ic,jc,kc,itime2read,titlw)
296,310c302
<       dimension q(jdim,kdim,idim,5)
<       dimension qc(jdimc,kdimc,idimc,5)
<       dimension work(jdimc,kdimc,idimc,5)
<       dimension qi0(jdim+1,kdim+1,5,4),qj0(kdim+1,idim,5,4),
<      .          qk0(jdim+1,idim,5,4)
<       dimension qi0c(jdimc+1,kdimc+1,5,4),qj0c(kdimc+1,idimc,5,4),
<      .          qk0c(jdimc+1,idimc,5,4)
<       dimension rms(ncycmax),clw(ncycmax),cdw(ncycmax),cdpw(ncycmax),
<      .          cdvw(ncycmax),cxw(ncycmax),cyw(ncycmax),czw(ncycmax),
<      .          cmxw(ncycmax),cmyw(ncycmax),cmzw(ncycmax),
<      .          fmdotw(ncycmax),cftmomw(ncycmax),cftpw(ncycmax),
<      .          cftvw(ncycmax),cfttotw(ncycmax),
<      .          rmstr1(ncycmax),rmstr2(ncycmax)
<       dimension nneg1(ncycmax),nneg2(ncycmax)
<       dimension titlw(20)
---
>       integer stats
312,321c304,334
<       pointer (ip_q,q),(ip_qc,qc),(ip_qi0,qi0),(ip_qj0,qj0),(ip_qk0,qk0)
<       pointer (ip_qi0c,qi0c),(ip_qj0c,qj0c),(ip_qk0c,qk0c)
<       pointer (ip_rms,rms),(ip_clw,clw),(ip_cdw,cdw),(ip_cdpw,cdpw),
<      .        (ip_cdvw,cdvw),(ip_cxw,cxw),(ip_cyw,cyw),(ip_czw,czw),
<      .        (ip_cmxw,cmxw),(ip_cmyw,cmyw),(ip_cmzw,cmzw),
<      .        (ip_fmdotw,fmdotw),(ip_cftmomw,cftmomw),(ip_cftpw,cftpw),
<      .        (ip_cftvw,cftvw),(ip_cfttotw,cfttotw),
<      .        (ip_rmstr1,rmstr1),(ip_rmstr2,rmstr2)
<       pointer (ip_work,work)
<       pointer (ip_nneg1,nneg1),(ip_nneg2,nneg2)
---
>       dimension titlw(20)
> c 
>       allocatable :: cdpw(:)
>       allocatable :: cdvw(:)
>       allocatable :: cdw(:)
>       allocatable :: cftmomw(:)
>       allocatable :: cftpw(:)
>       allocatable :: cfttotw(:)
>       allocatable :: cftvw(:)
>       allocatable :: clw(:)
>       allocatable :: cmxw(:)
>       allocatable :: cmyw(:)
>       allocatable :: cmzw(:)
>       allocatable :: cxw(:)
>       allocatable :: cyw(:)
>       allocatable :: czw(:)
>       allocatable :: fmdotw(:)
>       allocatable :: nneg1(:)
>       allocatable :: nneg2(:)
>       allocatable :: q(:,:,:,:)
>       allocatable :: qc(:,:,:,:)
>       allocatable :: qi0(:,:,:,:)
>       allocatable :: qi0c(:,:,:,:)
>       allocatable :: qj0(:,:,:,:)
>       allocatable :: qj0c(:,:,:,:)
>       allocatable :: qk0(:,:,:,:)
>       allocatable :: qk0c(:,:,:,:)
>       allocatable :: rms(:)
>       allocatable :: rmstr1(:)
>       allocatable :: rmstr2(:)
>       allocatable :: work(:,:,:,:)
325d337
<       icall  = 0
327,355c339,396
<       call umalloc_r(ip_q,jdim*kdim*idim*5,0,icall,memuse)
<       call umalloc_r(ip_qc,jdimc*kdimc*idimc*5,0,icall,memuse)
<       call umalloc_r(ip_qi0,(jdim+1)*(kdim+1)*20,0,icall,memuse)
<       call umalloc_r(ip_qj0,(kdim+1)*idim*20,0,icall,memuse)
<       call umalloc_r(ip_qk0,(jdim+1)*idim*20,0,icall,memuse)
<       call umalloc_r(ip_qi0c,(jdimc+1)*(kdimc+1)*20,0,icall,memuse)
<       call umalloc_r(ip_qj0c,(kdimc+1)*idimc*20,0,icall,memuse)
<       call umalloc_r(ip_qk0c,(jdimc+1)*idimc*20,0,icall,memuse)
<       call umalloc_r(ip_rms,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_clw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cdw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cdpw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cdvw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cxw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cyw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_czw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cmxw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cmyw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cmzw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_fmdotw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cftmomw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cftpw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cftvw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_cfttotw,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_rmstr1,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_rmstr2,ncycmax,0,icall,memuse)
<       call umalloc_r(ip_work,jdimc*kdimc*idimc*5,0,icall,memuse)
<       call umalloc_r(ip_nneg1,ncycmax,1,icall,memuse)
<       call umalloc_r(ip_nneg2,ncycmax,1,icall,memuse)
---
>       allocate( cdpw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cdpw',memuse,stats)
>       allocate( cdvw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cdvw',memuse,stats)
>       allocate( cdw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cdw',memuse,stats)
>       allocate( cftmomw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cftmomw',memuse,stats)
>       allocate( cftpw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cftpw',memuse,stats)
>       allocate( cfttotw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cfttotw',memuse,stats)
>       allocate( cftvw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cftvw',memuse,stats)
>       allocate( clw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'clw',memuse,stats)
>       allocate( cmxw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cmxw',memuse,stats)
>       allocate( cmyw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cmyw',memuse,stats)
>       allocate( cmzw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cmzw',memuse,stats)
>       allocate( cxw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cxw',memuse,stats)
>       allocate( cyw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'cyw',memuse,stats)
>       allocate( czw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'czw',memuse,stats)
>       allocate( fmdotw(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'fmdotw',memuse,stats)
>       allocate( nneg1(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,1,'nneg1',memuse,stats)
>       allocate( nneg2(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,1,'nneg2',memuse,stats)
>       allocate( q(jdim,kdim,idim,5), stat=stats )
>       call umalloc_r(jdim*kdim*idim*5,0,'q',memuse,stats)
>       allocate( qc(jdimc,kdimc,idimc,5), stat=stats )
>       call umalloc_r(jdimc*kdimc*idimc*5,0,'qc',memuse,stats)
>       allocate( qi0(jdim+1,kdim+1,5,4), stat=stats )
>       call umalloc_r((jdim+1)*(kdim+1)*5*4,0,'qi0',memuse,stats)
>       allocate( qi0c(jdimc+1,kdimc+1,5,4), stat=stats )
>       call umalloc_r((jdimc+1)*(kdimc+1)*5*4,0,'qi0c',memuse,stats)
>       allocate( qj0(kdim+1,idim,5,4), stat=stats )
>       call umalloc_r((kdim+1)*idim*5*4,0,'qj0',memuse,stats)
>       allocate( qj0c(kdimc+1,idimc,5,4), stat=stats )
>       call umalloc_r((kdimc+1)*idimc*5*4,0,'qj0c',memuse,stats)
>       allocate( qk0(jdim+1,idim,5,4), stat=stats )
>       call umalloc_r((jdim+1)*idim*5*4,0,'qk0',memuse,stats)
>       allocate( qk0c(jdimc+1,idimc,5,4), stat=stats )
>       call umalloc_r((jdimc+1)*idimc*5*4,0,'qk0c',memuse,stats)
>       allocate( rms(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'rms',memuse,stats)
>       allocate( rmstr1(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'rmstr1',memuse,stats)
>       allocate( rmstr2(ncycmax), stat=stats )
>       call umalloc_r(ncycmax,0,'rmstr2',memuse,stats)
>       allocate( work(jdimc,kdimc,idimc,5), stat=stats )
>       call umalloc_r(jdimc*kdimc*idimc*5,0,'work',memuse,stats)
1013a1055,1102
>       if (itime2read .ne. 0) then
>         if (iunfi .eq. 1) then
>           read(2) dtold
>         else
>           read(2,*) dtold
>         end if
>         if (iunfo .eq. 1) then
>           write(3) dtold
>         else
>           write(3,*) dtold
>         end if
> c   tursav2 data:
>            if (iunfi .eq. 1) then
>            read(2) ((((q(j,k,i,l),j=1,jdim1),k=1,kdim1),i=1,idim1),
>      .             l=1,2)
>            else
>            read(2,*) ((((q(j,k,i,l),j=1,jdim1),k=1,kdim1),i=1,idim1),
>      .             l=1,2)
>            end if
>       if (ihalf .eq. 1) then
> c       Make finer:
>         call makefin(q,qc,idim,jdim,kdim,idimc,jdimc,kdimc,
>      +    idim1,jdim1,kdim1,idim1c,jdim1c,kdim1c,ic,jc,kc,2,
>      +    work)
>       else if (ihalf .eq. 0) then
> c       Coarsen
>         call makecoar(q,qc,idim,jdim,kdim,idimc,jdimc,kdimc,
>      +    idim1,jdim1,kdim1,ic,jc,kc,it,2)
>       else
> c       Don't coarsen
>         do l=1,2
>         do j=1,jdim1
>         do k=1,kdim1
>         do i=1,idim1
>           qc(j,k,i,l)=q(j,k,i,l)
>         enddo
>         enddo
>         enddo
>         enddo
>       end if
>            if (iunfo .eq. 1) then
>            write(3) ((((qc(j,k,i,l),j=1,jdim1c),k=1,kdim1c),
>      +      i=1,idim1c),l=1,2)
>            else
>            write(3,*) ((((qc(j,k,i,l),j=1,jdim1c),k=1,kdim1c),
>      +      i=1,idim1c),l=1,2)
>            end if
>       end if
1145,1173c1234,1262
<          call ufree_r(ip_q)
<          call ufree_r(ip_qc)
<          call ufree_r(ip_qi0)
<          call ufree_r(ip_qj0)
<          call ufree_r(ip_qk0)
<          call ufree_r(ip_qi0c)
<          call ufree_r(ip_qj0c)
<          call ufree_r(ip_qk0c)
<          call ufree_r(ip_rms)
<          call ufree_r(ip_clw)
<          call ufree_r(ip_cdw)
<          call ufree_r(ip_cdpw)
<          call ufree_r(ip_cdvw)
<          call ufree_r(ip_cxw)
<          call ufree_r(ip_cyw)
<          call ufree_r(ip_czw)
<          call ufree_r(ip_cmxw)
<          call ufree_r(ip_cmyw)
<          call ufree_r(ip_cmzw)
<          call ufree_r(ip_fmdotw)
<          call ufree_r(ip_cftmomw)
<          call ufree_r(ip_cftpw)
<          call ufree_r(ip_cftvw)
<          call ufree_r(ip_cfttotw)
<          call ufree_r(ip_rmstr1)
<          call ufree_r(ip_rmstr2)
<          call ufree_r(ip_work)
<          call ufree_r(ip_nneg1)
<          call ufree_r(ip_nneg2)
---
>          deallocate(q)
>          deallocate(qc)
>          deallocate(qi0)
>          deallocate(qj0)
>          deallocate(qk0)
>          deallocate(qi0c)
>          deallocate(qj0c)
>          deallocate(qk0c)
>          deallocate(rms)
>          deallocate(clw)
>          deallocate(cdw)
>          deallocate(cdpw)
>          deallocate(cdvw)
>          deallocate(cxw)
>          deallocate(cyw)
>          deallocate(czw)
>          deallocate(cmxw)
>          deallocate(cmyw)
>          deallocate(cmzw)
>          deallocate(fmdotw)
>          deallocate(cftmomw)
>          deallocate(cftpw)
>          deallocate(cftvw)
>          deallocate(cfttotw)
>          deallocate(rmstr1)
>          deallocate(rmstr2)
>          deallocate(work)
>          deallocate(nneg1)
>          deallocate(nneg2)
